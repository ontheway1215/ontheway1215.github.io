<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChenBlog-chenqiangyi.cn</title>
  <subtitle>IT技术分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.chenqiangyi.cn/"/>
  <updated>2017-06-28T03:54:33.000Z</updated>
  <id>http://www.chenqiangyi.cn/</id>
  
  <author>
    <name>ontheway1215</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript中的this</title>
    <link href="http://www.chenqiangyi.cn/2017/06/22/javascript%E4%B8%AD%E7%9A%84this/"/>
    <id>http://www.chenqiangyi.cn/2017/06/22/javascript中的this/</id>
    <published>2017-06-22T03:06:29.000Z</published>
    <updated>2017-06-28T03:54:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>JavaScript 中的this一直是初学者比较困惑的知识点，当然我也不例外。因为this很重要，所以面试中基本都有涉及this相关的问题，在曾经的面试中也被问过this，比较容易弄混，今天就来整理一下this相关的知识。</p>
</blockquote>
<p>首先要知道this指的是什么？简单概括就是：</p>
<ul>
<li>上下文是在函数调用的时候被创建的。</li>
<li>this是组成上下文的一部分。</li>
</ul>
<p>因此每次函数被调用的时候就会产生一个新的this。具体分为下面几种。</p>
<h1 id="作为普通函数在全局中被调用"><a href="#作为普通函数在全局中被调用" class="headerlink" title="作为普通函数在全局中被调用"></a>作为普通函数在全局中被调用</h1><p>在全局环境里面，this永远指向window，因此在全局环境里作为普通函数被调用的时候，this也是window(这里仅指在浏览器环境下，不靠路Node)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var name = &apos;chen&apos;;</div><div class="line">function fn() &#123;</div><div class="line">    console.log(this);  //window</div><div class="line">    console.log(this.name)  //chen</div><div class="line">&#125;</div><div class="line">fn();</div></pre></td></tr></table></figure>
<p>这里，fn其实是作为window的一个方法被调用的，而name也是window的一个属性，因此fn()实际上就是window.fn().就如上面的window.name == ‘chen’</p>
<h1 id="作为对象的属性被调用"><a href="#作为对象的属性被调用" class="headerlink" title="作为对象的属性被调用"></a>作为对象的属性被调用</h1><p>如果函数作为一个对象的属性方法，并且被调用的时候，this就指向这个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name = &apos;chen&apos;;</div><div class="line">var person = &#123;</div><div class="line">    name: &apos;yi&apos;,</div><div class="line">    sayName: function() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var sayNameWin = person.sayName;</div><div class="line"></div><div class="line">person.sayName();  //yi</div><div class="line">sayNameWin();  //chen  作为window的方法被调用</div></pre></td></tr></table></figure>
<p>在这里sayName方法是作为person的一个属性方法被调用的，因此指向person，但是sayNameWin方法确实作为window的一个属性方法被调用的，因此console.log的值是chen。<br>我们再看一个变形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var person1 = &#123;</div><div class="line">    name: &apos;chen&apos;,</div><div class="line">    sayName: function()&#123;</div><div class="line">        console.log(this.name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person2 = &#123;</div><div class="line">    name: &apos;yi&apos;,</div><div class="line">    sayName: person1.sayName</div><div class="line">&#125;</div><div class="line"></div><div class="line">person2.sayName();  //yi  作为person2的属性方法被调用</div></pre></td></tr></table></figure>
<p>但是当在对象方法中再定义函数，这时候this又是<code>window</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var name = &apos;chen&apos;;</div><div class="line">var person = &#123;</div><div class="line">    name: &apos;yi&apos;,</div><div class="line">    sayName: function() &#123;</div><div class="line">        function fn() &#123;</div><div class="line">            console.log(this);  //window</div><div class="line">            console.log(this.name);  //chen</div><div class="line">        &#125;</div><div class="line">        fn();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">person.sayName();</div></pre></td></tr></table></figure>
<p>如果想让this指向person的话，只需要用that保存下来this的值即可，也可以使用apply等改变this。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var name = &apos;chen&apos;;</div><div class="line">var person = &#123;</div><div class="line">    name: &apos;yi&apos;,</div><div class="line">    sayName: function() &#123;</div><div class="line">        var that = this;</div><div class="line">        function fn() &#123;</div><div class="line">            console.log(that);  //Object &#123;name: &apos;yi&apos;, ...&#125;</div><div class="line">            console.log(that.name);  //yi</div><div class="line">        &#125;</div><div class="line">        fn();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">person.sayName();</div></pre></td></tr></table></figure>
<h1 id="作为构造函数被调用"><a href="#作为构造函数被调用" class="headerlink" title="作为构造函数被调用"></a>作为构造函数被调用</h1><p>作为构造函数被调用的时候，<code>this</code>代表它即将<code>new</code>出来的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    console.log(this);  //Person &#123;name: &apos;chen&apos;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person = new Person(&apos;chen&apos;);</div><div class="line">console.log(person.name);  //chen</div></pre></td></tr></table></figure>
<p>如果不加<code>new</code>，表示即作为普通函数调用，指向<code>window</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    console.log(this);  //window</div><div class="line">    console.log(this.name);  //chen</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person(&apos;chen&apos;);</div><div class="line">console.log(window.name);  //chen</div></pre></td></tr></table></figure>
<h1 id="作为call-apply-bind方法的调用"><a href="#作为call-apply-bind方法的调用" class="headerlink" title="作为call/apply/bind方法的调用"></a>作为call/apply/bind方法的调用</h1><p>作为<code>call/apply/bind</code>方法被调用的时候指向传入的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &apos;chen&apos;</div><div class="line">&#125;;</div><div class="line">function fn() &#123;</div><div class="line">    console.log(this);  //Object &#123;name: &apos;chen&apos;&#125;</div><div class="line">    console.log(this.name);  //chen</div><div class="line">&#125;</div><div class="line">fn.apply(person);</div></pre></td></tr></table></figure>
<h1 id="严格模式下"><a href="#严格模式下" class="headerlink" title="严格模式下"></a>严格模式下</h1><p>在严格模式下，在全局环境中执行函数调用的时候是会指向<code>undefined</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line">function person() &#123;</div><div class="line">    console.log(this);  //undefined</div><div class="line">&#125;;</div><div class="line">person();</div></pre></td></tr></table></figure>
<h1 id="setTimeout、setInterval中的this"><a href="#setTimeout、setInterval中的this" class="headerlink" title="setTimeout、setInterval中的this"></a>setTimeout、setInterval中的this</h1><p>《javascript高级程序设计》中写到：”超时调用的代码都是在全局执行域中执行的”。setTimeout/setInterval执行的时候，this默认指向window对象，除非手动改变this指向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name = &apos;chen&apos;;</div><div class="line">function Person()&#123;</div><div class="line">    this.name = &apos;yi&apos;;</div><div class="line">    this.sayName = function() &#123;</div><div class="line">        console.log(this);  //window</div><div class="line">        console.log(this.name);  //chen</div><div class="line">    &#125;;</div><div class="line">    setTimeout(this.sayName, 10);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person = new Person();</div></pre></td></tr></table></figure>
<p>在这里如果想改变this，可以使用apply/call/bind等，也可以使用that保存this。setTimeout中的回调函数在严格模下也指向<code>window</code>而不是undefined（是个坑）。因为setTimeout的回调函数如果没有指定的this，会做一个隐式的操作，将全局上下问注入进去，不管是在严格模式还是非严格模式下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line">function person() &#123;</div><div class="line">    console.log(this);  //window</div><div class="line">&#125;</div><div class="line">setTimeout(person, 0);</div></pre></td></tr></table></figure>
<h1 id="构造函数prototype属性"><a href="#构造函数prototype属性" class="headerlink" title="构造函数prototype属性"></a>构造函数prototype属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var name = &apos;chen&apos;;</div><div class="line">function Person() &#123;</div><div class="line">    this.name = &apos;yi&apos;;</div><div class="line">&#125;</div><div class="line">Person.prototype.sayName = function() &#123;</div><div class="line">    console.log(this);  //Person &#123;name: &apos;yi&apos;&#125;</div><div class="line">    console.log(this.name);  //yi</div><div class="line">&#125;</div><div class="line">var person = new Person();</div><div class="line">person.sayName();</div></pre></td></tr></table></figure>
<p>在Person.prototype.sayName函数中，this指向的Person对象。即便是在整个原型链中，this也代表当前对象的值。</p>
<h1 id="Eval函数"><a href="#Eval函数" class="headerlink" title="Eval函数"></a>Eval函数</h1><p>在Eval中，this指向当前作用域的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var name = &apos;chen&apos;;</div><div class="line">var person = &#123;</div><div class="line">    name: &apos;yi&apos;,</div><div class="line">    getName: function() &#123;</div><div class="line">        eval(&quot;console.log(this)&quot;);</div><div class="line">        eval(&quot;console.log(this.name)&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">person.getName();  //Object &#123;name: &apos;yi&apos;, ...&#125; yi</div><div class="line"></div><div class="line">var getNameWin = person.getName;  //window chen</div><div class="line">getNameWin();</div></pre></td></tr></table></figure>
<p>在这里，和不适用Eval，作为对象的方法调用的时候的出来的结果是一样的。</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数里面this始终指向外部对象，因为箭头函数没有this，因此它自身不能进行new实例化，同时也不能使用call,apply,bind等方法来改变this的指向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &apos;chen&apos;,</div><div class="line">    sayName: function() &#123;</div><div class="line">        var fn = () =&gt; &#123;</div><div class="line">            return () =&gt; &#123;</div><div class="line">                console.log(this);  //Object &#123;name: &apos;chen&apos;, ...&#125;</div><div class="line">                coneole.log(this.name);  //chen</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        fn()();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">person.sayName();</div></pre></td></tr></table></figure>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/wangfupeng1988/p/3988422.html" target="_blank" rel="external">深入理解javascript原型和闭包（10）——this</a></p>
<p><a href="http://www.cnblogs.com/wangfupeng1988/p/3996037.html" target="_blank" rel="external">深入理解javascript原型和闭包（17）——补this</a></p>
<p><a href="http://www.cnblogs.com/justany/archive/2012/11/01/the_keyword_this_in_javascript.html" target="_blank" rel="external">Javascript中this关键字详解 - Justany_WhiteSnow - 博客园</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JavaScript 中的this一直是初学者比较困惑的知识点，当然我也不例外。因为this很重要，所以面试中基本都有涉及this相关的问题，在曾经的面试中也被问过this，比较容易弄混，今天就来整理一下this相关的知识。&lt;/p&gt;
&lt;/block
    
    </summary>
    
      <category term="this" scheme="http://www.chenqiangyi.cn/categories/this/"/>
    
    
      <category term="JavaScript" scheme="http://www.chenqiangyi.cn/tags/JavaScript/"/>
    
      <category term="this" scheme="http://www.chenqiangyi.cn/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>网站部署https</title>
    <link href="http://www.chenqiangyi.cn/2017/06/21/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2https/"/>
    <id>http://www.chenqiangyi.cn/2017/06/21/网站部署https/</id>
    <published>2017-06-21T09:27:55.000Z</published>
    <updated>2017-06-22T03:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>以下不是一篇指南式的教程，只是记录了将我的博客升级为https的过程，主要记录了一些配置nginx时遇到的问题，但也可以做一下参考 😁</p>
</blockquote>
<h1 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a>什么是HTTPS</h1><p>简单地说就是 HTTP + SSL,SSL是Secure Socket Layer的缩写，字面意思上看就是在HTTP上又加了一层SSL层使传输更安全。HTTP数据是以明文传输的，没有加密。传输中会遇到以下风险：</p>
<ul>
<li>窃听风险（eavesdropping）：第三方可以获知通信内容</li>
<li>篡改风险（tampering）：第三方可以篡改通信内容</li>
<li>冒充风险（pretending）：第三方可以冒充他人身份参与通信</li>
</ul>
<p>而 HTTPS 则可以通过 SSL/TLS 来解决以上三个问题。</p>
<h1 id="获取SSL"><a href="#获取SSL" class="headerlink" title="获取SSL"></a>获取SSL</h1><p>这里我选择的是腾讯云的域名型（DV）SSL证书，可以免费使用一年，到期后需要续费，续费金额还是挺高的。</p>
<p>因为腾讯云提供中文文档，申请到安装还是挺顺利的，申请成功后如图：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://orw66421u.bkt.clouddn.com/SSL.jpeg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>证书到手，然后下载下来，传到放到<code>/etc/nginx/</code>目录下，注意两个文件需要和Nginx的配置文件在同一个目录下（腾讯云指导书上说可以随意放一个到同一个目录下，但是我的不知道为什么会报错）<br>按照文档的指示配置Nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen 443;</div><div class="line">        server_name www.domain.com; #填写绑定证书的域名</div><div class="line">        ssl on;</div><div class="line">        ssl_certificate 1_www.domain.com_bundle.crt;</div><div class="line">        ssl_certificate_key 2_www.domain.com.key;</div><div class="line">        ssl_session_timeout 5m;</div><div class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</div><div class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</div><div class="line">        ssl_prefer_server_ciphers on;</div><div class="line">        location / &#123;</div><div class="line">            root   html; #站点目录</div><div class="line">            index  index.html index.htm;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>配置完成后用nginx -t测试一下配置文件是否有误，正确无误的话重启Nginx，就可以使用了。<br>然而，我用https访问一直报500的错误，最后才发现HTTPS默认使用的端口是443，需要我们开放443端口。</p>
<p>然后可以正常使用<a href="https:www.chenqiangyi.cn" target="_blank" rel="external">https:www.chenqiangyi.cn</a>正常访问。<br>但是，当使用<a href="http://www.chenqiangyi.cn">http://www.chenqiangyi.cn</a>访问的时候又报错。需要我们对http的请求强制转为https访问。</p>
<h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><p>https服务器监听443端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen       443;</div><div class="line">        server_name  www.chenqiangyi.cn;</div><div class="line">	ssl on;</div><div class="line">        ssl_certificate      1_www.chenqiangyi.cn_bundle.crt;</div><div class="line">        ssl_certificate_key  2_www.chenqiangyi.cn.key;</div><div class="line"></div><div class="line">        ssl_session_cache    shared:SSL:1m;</div><div class="line">        ssl_session_timeout  5m;</div><div class="line">	ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">	ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</div><div class="line"> 	ssl_prefer_server_ciphers  on;</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>把http的请求重定向到https</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  chenqiangyi.cn;</div><div class="line">	rewrite  ^(.*) https://$host$1 permanent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就ok了，请求<a href="www.chenqiangyi.cn">www.chenqiangyi.cn</a> 和 <a href="chenqiangyi.cn">chenqiangyi.cn</a>都能跳转到<a href="https://www.chenqiangyi.cn">https://www.chenqiangyi.cn</a>访问。</p>
<p>但是有时候会发现访问<a href="chenqiangyi.cn">chenqiangyi.cn</a>会出现无限重定向，不知道是为什么，现在还在探索。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;以下不是一篇指南式的教程，只是记录了将我的博客升级为https的过程，主要记录了一些配置nginx时遇到的问题，但也可以做一下参考 😁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;什么是HTTPS&quot;&gt;&lt;a href=&quot;#什么是HTTPS&quot;
    
    </summary>
    
      <category term="https" scheme="http://www.chenqiangyi.cn/categories/https/"/>
    
    
      <category term="https" scheme="http://www.chenqiangyi.cn/tags/https/"/>
    
      <category term="nginx" scheme="http://www.chenqiangyi.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的递归</title>
    <link href="http://www.chenqiangyi.cn/2017/06/14/JavaScript%E4%B8%AD%E7%9A%84%E9%80%92%E5%BD%92/"/>
    <id>http://www.chenqiangyi.cn/2017/06/14/JavaScript中的递归/</id>
    <published>2017-06-14T02:52:26.000Z</published>
    <updated>2017-06-14T14:25:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>译者按: 程序员应该知道递归，但是你真的知道是怎么回事么？</p>
<p>原文: <a href="http://lucasfcosta.com/2017/05/08/All-About-Recursion-PTC-TCO-and-STC-in-JavaScript.html" target="_blank" rel="external">All About Recursion, PTC, TCO and STC in JavaScript</a></p>
<p>译者: <a href="https://fundebug.com/" target="_blank" rel="external">Fundebug</a></p>
<p>为了保证可读性，本文采用意译而非直译。</p>
<blockquote>
<p>一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。</p>
</blockquote>
<p>我们来举个例子，我们可以用4的阶乘乘以4来定义5的阶乘，3的阶乘乘以4来定义4的阶乘，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">factorial(5) = factorial(4) * 5</div><div class="line">factorial(5) = factorial(3) * 4 * 5</div><div class="line">factorial(5) = factorial(2) * 3 * 4 * 5</div><div class="line">factorial(5) = factorial(1) * 2 * 3 * 4 * 5</div><div class="line">factorial(5) = factorial(0) * 1 * 2 * 3 * 4 * 5</div><div class="line">factorial(5) = 1 * 1 * 2 * 3 * 4 * 5</div></pre></td></tr></table></figure>
<p>用Haskell的Pattern matching 可以很直观的定义factorial函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">factorial n = factorial (n-1)  * n</div><div class="line">factorial 0 = 1</div></pre></td></tr></table></figure>
<p>在递归的例子中，从第一个调用factorial(5)开始，一直递归调用factorial函数自身直到参数的值为0。下面是一个形象的图例：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://blog.fundebug.com/2017/06/14/all-about-recursions/factorial-calls.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h1 id="递归的调用栈"><a href="#递归的调用栈" class="headerlink" title="递归的调用栈"></a>递归的调用栈</h1><p>为了理解调用栈，我们回到factorial函数的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function factorial(n) &#123;</div><div class="line">    if (n === 0) &#123;</div><div class="line">        return 1</div><div class="line">    &#125;</div><div class="line">    return n * factorial(n - 1)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们传入参数3，将会递归调用factorial(2)、factorial(1)和factorial(0)，因此会额外再调用factorial三次。</p>
<p>每次函数调用都会压入调用栈，整个调用栈如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">factorial(0) // 0的阶乘为1</div><div class="line">factorial(1) // 该调用依赖factorial(0)</div><div class="line">factorial(2) // 该调用依赖factorial(1)</div><div class="line">factorial(3) // 该掉用依赖factorial(2)</div></pre></td></tr></table></figure>
<p>现在我们修改代码，插入console.trace()来查看每一次当前的调用栈的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function factorial(n) &#123;</div><div class="line">    console.trace()</div><div class="line">    if (n === 0) &#123;</div><div class="line">        return 1</div><div class="line">    &#125;</div><div class="line">    return n * factorial(n - 1)</div><div class="line">&#125;</div><div class="line">factorial(3)</div></pre></td></tr></table></figure>
<p>接下来我们看看调用栈是怎样的。</p>
<ul>
<li>第一个：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Trace</div><div class="line">    at factorial (repl:2:9)</div><div class="line">    at repl:1:1 // 请忽略以下底层实现细节代码</div><div class="line">    at realRunInThisContextScript (vm.js:22:35)</div><div class="line">    at sigintHandlersWrap (vm.js:98:12)</div><div class="line">    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</div><div class="line">    at REPLServer.defaultEval (repl.js:313:29)</div><div class="line">    at bound (domain.js:280:14)</div><div class="line">    at REPLServer.runBound [as eval] (domain.js:293:12)</div><div class="line">    at REPLServer.onLine (repl.js:513:10)</div><div class="line">    at emitOne (events.js:101:20)</div></pre></td></tr></table></figure>
<p>你会发现，该调用栈包含一个对factorial函数的调用，这里是factorial(3)。接下来就更加有趣了，我们来看第二次打印出来的调用栈：</p>
<p>现在我们有两个对factorial函数的调用。</p>
<ul>
<li>第三次：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Trace</div><div class="line">    at factorial (repl:2:9)</div><div class="line">    at factorial (repl:7:12)</div><div class="line">    at factorial (repl:7:12)</div><div class="line">    at repl:1:1</div><div class="line">    at realRunInThisContextScript (vm.js:22:35)</div><div class="line">    at sigintHandlersWrap (vm.js:98:12)</div><div class="line">    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</div><div class="line">    at REPLServer.defaultEval (repl.js:313:29)</div><div class="line">    at bound (domain.js:280:14)</div><div class="line">    at REPLServer.runBound [as eval] (domain.js:293:12)</div></pre></td></tr></table></figure>
<ul>
<li>第四次：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Trace</div><div class="line">    at factorial (repl:2:9)</div><div class="line">    at factorial (repl:7:12)</div><div class="line">    at factorial (repl:7:12)</div><div class="line">    at factorial (repl:7:12)</div><div class="line">    at repl:1:1</div><div class="line">    at realRunInThisContextScript (vm.js:22:35)</div><div class="line">    at sigintHandlersWrap (vm.js:98:12)</div><div class="line">    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</div><div class="line">    at REPLServer.defaultEval (repl.js:313:29)</div><div class="line">    at bound (domain.js:280:14)</div></pre></td></tr></table></figure>
<p>设想，如果传入的参数值特别大，那么这个调用栈将会非常之大，最终可能超出调用栈的缓存大小而崩溃导致程序执行失败。那么如何解决这个问题呢？使用尾递归。</p>
<h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h1><p>尾递归是一种递归的写法，可以避免不断的将函数压栈最终导致堆栈溢出。通过设置一个累加参数，并且每一次都将当前的值累加上去，然后递归调用。</p>
<p>我们来看如何改写之前定义factorial函数为尾递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function factorial(n, total = 1) &#123;</div><div class="line">    if (n === 0) &#123;</div><div class="line">        return total</div><div class="line">    &#125;</div><div class="line">    return factorial(n - 1, n * total)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>factorial(3)的执行步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">factorial(3, 1)</div><div class="line">factorial(2, 3)</div><div class="line">factorial(1, 6)</div><div class="line">factorial(0, 6)</div></pre></td></tr></table></figure>
<p>调用栈不再需要多次对factorial进行压栈处理，因为每一个递归调用都不在依赖于上一个递归调用的值。因此，空间的复杂度为o(1)而不是0(n)。</p>
<p>接下来，通过console.trace()函数将调用栈打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function factorial(n, total = 1) &#123;</div><div class="line">    console.trace()</div><div class="line">    if (n === 0) &#123;</div><div class="line">        return total</div><div class="line">    &#125;</div><div class="line">    return factorial(n - 1, n * total)</div><div class="line">&#125;</div><div class="line">factorial(3)</div></pre></td></tr></table></figure>
<p>很惊讶的发现，依然有很多压栈!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// ...</div><div class="line">// 下面是最后两次对factorial的调用</div><div class="line">Trace</div><div class="line">    at factorial (repl:2:9) // 3次压栈</div><div class="line">    at factorial (repl:7:8)</div><div class="line">    at factorial (repl:7:8)</div><div class="line">    at repl:1:1 // 请忽略以下底层实现细节代码</div><div class="line">    at realRunInThisContextScript (vm.js:22:35)</div><div class="line">    at sigintHandlersWrap (vm.js:98:12)</div><div class="line">    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</div><div class="line">    at REPLServer.defaultEval (repl.js:313:29)</div><div class="line">    at bound (domain.js:280:14)</div><div class="line">    at REPLServer.runBound [as eval] (domain.js:293:12)</div><div class="line">Trace</div><div class="line">    at factorial (repl:2:9) // 最后第一调用再次压栈</div><div class="line">    at factorial (repl:7:8)</div><div class="line">    at factorial (repl:7:8)</div><div class="line">    at factorial (repl:7:8)</div><div class="line">    at repl:1:1 // 请忽略以下底层实现细节代码</div><div class="line">    at realRunInThisContextScript (vm.js:22:35)</div><div class="line">    at sigintHandlersWrap (vm.js:98:12)</div><div class="line">    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</div><div class="line">    at REPLServer.defaultEval (repl.js:313:29)</div><div class="line">    at bound (domain.js:280:14)</div></pre></td></tr></table></figure>
<p>这是为什么呢？<br>在Nodejs下面，我们可以通过开启strict mode, 并且使用–harmony_tailcalls来开启尾递归(proper tail call)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;</div><div class="line">function factorial(n, total = 1) &#123;</div><div class="line">    console.trace()</div><div class="line">    if (n === 0) &#123;</div><div class="line">        return total</div><div class="line">    &#125;</div><div class="line">    return factorial(n - 1, n * total)</div><div class="line">&#125;</div><div class="line">factorial(3)</div></pre></td></tr></table></figure>
<p>使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node --harmony_tailcalls factorial.js</div></pre></td></tr></table></figure>
<p>调用栈信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">Trace</div><div class="line">    at factorial (/Users/stefanzan/factorial.js:3:13)</div><div class="line">    at Object.&lt;anonymous&gt; (/Users/stefanzan/factorial.js:9:1)</div><div class="line">    at Module._compile (module.js:570:32)</div><div class="line">    at Object.Module._extensions..js (module.js:579:10)</div><div class="line">    at Module.load (module.js:487:32)</div><div class="line">    at tryModuleLoad (module.js:446:12)</div><div class="line">    at Function.Module._load (module.js:438:3)</div><div class="line">    at Module.runMain (module.js:604:10)</div><div class="line">    at run (bootstrap_node.js:394:7)</div><div class="line">    at startup (bootstrap_node.js:149:9)</div><div class="line">Trace</div><div class="line">    at factorial (/Users/stefanzan/factorial.js:3:13)</div><div class="line">    at Object.&lt;anonymous&gt; (/Users/stefanzan/factorial.js:9:1)</div><div class="line">    at Module._compile (module.js:570:32)</div><div class="line">    at Object.Module._extensions..js (module.js:579:10)</div><div class="line">    at Module.load (module.js:487:32)</div><div class="line">    at tryModuleLoad (module.js:446:12)</div><div class="line">    at Function.Module._load (module.js:438:3)</div><div class="line">    at Module.runMain (module.js:604:10)</div><div class="line">    at run (bootstrap_node.js:394:7)</div><div class="line">    at startup (bootstrap_node.js:149:9)</div><div class="line">Trace</div><div class="line">    at factorial (/Users/stefanzan/factorial.js:3:13)</div><div class="line">    at Object.&lt;anonymous&gt; (/Users/stefanzan/factorial.js:9:1)</div><div class="line">    at Module._compile (module.js:570:32)</div><div class="line">    at Object.Module._extensions..js (module.js:579:10)</div><div class="line">    at Module.load (module.js:487:32)</div><div class="line">    at tryModuleLoad (module.js:446:12)</div><div class="line">    at Function.Module._load (module.js:438:3)</div><div class="line">    at Module.runMain (module.js:604:10)</div><div class="line">    at run (bootstrap_node.js:394:7)</div><div class="line">    at startup (bootstrap_node.js:149:9)</div><div class="line">Trace</div><div class="line">    at factorial (/Users/stefanzan/factorial.js:3:13)</div><div class="line">    at Object.&lt;anonymous&gt; (/Users/stefanzan/factorial.js:9:1)</div><div class="line">    at Module._compile (module.js:570:32)</div><div class="line">    at Object.Module._extensions..js (module.js:579:10)</div><div class="line">    at Module.load (module.js:487:32)</div><div class="line">    at tryModuleLoad (module.js:446:12)</div><div class="line">    at Function.Module._load (module.js:438:3)</div><div class="line">    at Module.runMain (module.js:604:10)</div><div class="line">    at run (bootstrap_node.js:394:7)</div><div class="line">    at startup (bootstrap_node.js:149:9)</div></pre></td></tr></table></figure>
<p>你会发现，不会在每次调用的时候压栈，只有一个factorial。</p>
<p>注意：尾递归不一定会将你的代码执行速度提高；相反，可能会变慢。不过，尾递归可以让你使用更少的内存，使你的递归函数更加安全 (前提是你要开启harmony模式)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;译者按: 程序员应该知道递归，但是你真的知道是怎么回事么？&lt;/p&gt;
&lt;p&gt;原文: &lt;a href=&quot;http://lucasfcosta.com/2017/05/08/All-About-Recursion-PTC-TCO-and-STC-in-JavaScript.htm
    
    </summary>
    
    
      <category term="Javascript 递归" scheme="http://www.chenqiangyi.cn/tags/Javascript-%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>vue键盘事件小技巧</title>
    <link href="http://www.chenqiangyi.cn/2017/05/10/vue%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.chenqiangyi.cn/2017/05/10/vue键盘事件小技巧/</id>
    <published>2017-05-10T14:04:01.000Z</published>
    <updated>2017-06-14T14:05:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近用Vue做一个运营工具，需求是当在编辑完成的时候可以知接按住Alt+S提交表单并保存,查询vue文档发现尤大已经把常用的按键封装到框架中了，然而所有的绑定都必须在表单元素中进行，显然不符合我那个开发工具的需求，最后不断查文档，并没有找到相关的文章。最后只能用原生的keydown事件了，监听整个windowd,代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mounted() &#123;</div><div class="line">     var that = this;</div><div class="line">     document.onkeydown=function(e) &#123;</div><div class="line">           if(e &amp;amp;&amp;amp; e.keyCode==83 &amp;amp;&amp;amp; e.altKey )&#123;     //同时按下Alt+S</div><div class="line">                   that.submitBtn(e);</div><div class="line">           &#125;</div><div class="line">      &#125;</div><div class="line">&#125;,</div><div class="line">methods: &#123;</div><div class="line">    submitBtn(e) &#123;</div><div class="line">        //相关函数</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就总结一下vue中的键盘事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;&lt;/title&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;</div><div class="line"></div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        window.onload = function()&#123;</div><div class="line">            var vm = new Vue(&#123;</div><div class="line">                el:&apos;#box&apos;,</div><div class="line">                methods:&#123;</div><div class="line">                    show:function(ev)&#123;</div><div class="line">                        if(ev.keyCode == 13)&#123;</div><div class="line">                            alert(&apos;你按回车键了&apos;);</div><div class="line">                        &#125;</div><div class="line">                    &#125;,</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=&quot;box&quot;&gt;</div><div class="line">        &lt;input type=&quot;text&quot; placeholder=&quot;请输入&quot; @keyup=&quot;show($event)&quot;&gt;</div><div class="line"></div><div class="line">        &lt;input type=&quot;text&quot; placeholder=&quot;请输入&quot; @keyup.13=&quot;show($event)&quot;&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<ul>
<li>.enter</li>
<li>.tab</li>
<li>.delete&nbsp;(捕获 “删除” 和 “退格” 键)</li>
<li>.esc</li>
<li>.space</li>
<li>.up</li>
<li>.down</li>
<li>.left</li>
<li>.right</li>
</ul>
<p>可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应</p>
<ul>
<li>.ctrl</li>
<li>.alt</li>
<li>.shift</li>
<li>.meta</li>
</ul>
<p>注意：在Mac系统键盘上，meta对应命令键 (⌘)。在Windows系统键盘meta对应windows徽标键(⊞)。在Sun操作系统键盘上，meta对应实心宝石键 (◆)。在其他特定键盘上，尤其在MIT和Lisp键盘及其后续，比如Knight键盘，space-cadet键盘，meta被标记为“META”。在Symbolics键盘上，meta被标记为“META” 或者 “Meta”。</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- Alt + C --&gt;</div><div class="line">&lt;input @keyup.alt.67=&quot;clear&quot;&gt;</div><div class="line"></div><div class="line">&lt;!-- Ctrl + Click --&gt;</div><div class="line">&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近用Vue做一个运营工具，需求是当在编辑完成的时候可以知接按住Alt+S提交表单并保存,查询vue文档发现尤大已经把常用的按键封装到框架中了，然而所有的绑定都必须在表单元素中进行，显然不符合我那个开发工具的需求，最后不断查文档，并没有找到相关的文
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.chenqiangyi.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.chenqiangyi.cn/tags/JavaScript/"/>
    
      <category term="vue" scheme="http://www.chenqiangyi.cn/tags/vue/"/>
    
      <category term="键盘事件" scheme="http://www.chenqiangyi.cn/tags/%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>ES6新特性总结</title>
    <link href="http://www.chenqiangyi.cn/2017/04/25/ES6%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://www.chenqiangyi.cn/2017/04/25/ES6新特性总结/</id>
    <published>2017-04-25T04:28:31.000Z</published>
    <updated>2017-06-14T11:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6语法已经出来很久了，为了加强学习和记忆，总结一下ES6中出现的新特性，参考文章<a href="http://es6.ruanyifeng.com/。" target="_blank" rel="external">http://es6.ruanyifeng.com/。</a></p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>function() 函数的简写表示法，但它不绑定 this。</p>
<p>ES6 代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var odds = evens.map(v =&amp;gt; v + 1);  // no parentes and no brackets</div><div class="line">var nums = evens.map((v, i) =&amp;gt; v + i);</div><div class="line">var pairs = evens.map(v =&amp;gt; (&#123;even: v, odd: v + 1&#125;));</div><div class="line"></div><div class="line">// Statement bodies</div><div class="line">nums.forEach(v =&amp;gt; &#123;</div><div class="line">  if (v % 5 === 0)</div><div class="line">    fives.push(v);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="this是如何工作的"><a href="#this是如何工作的" class="headerlink" title="this是如何工作的"></a>this是如何工作的</h1><p>ES6 代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var object = &#123;</div><div class="line">    name: &quot;Name&quot;,</div><div class="line">    arrowGetName: () =&amp;gt; this.name,</div><div class="line">    regularGetName: function() &#123; return this.name &#125;,</div><div class="line">    arrowGetThis: () =&amp;gt; this,</div><div class="line">    regularGetThis: function() &#123; return this &#125;</div><div class="line">&#125;</div><div class="line">console.log(object);</div><div class="line">console.log(object.name)</div><div class="line">console.log(object.arrowGetName());</div><div class="line">console.log(object.arrowGetThis());</div><div class="line">console.log(this);</div><div class="line">console.log(object.regularGetName());</div><div class="line">console.log(object.regularGetThis());</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">console.log(object);</div><div class="line"></div><div class="line">Object &#123;</div><div class="line">    name: &quot;Name&quot;,</div><div class="line">    arrowGetName: function,</div><div class="line">    regularGetName: function,</div><div class="line">    arrowGetThis: function,</div><div class="line">    regularGetThis: function</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(object.name) ;</div><div class="line">Name</div><div class="line"></div><div class="line">console.log(object.arrowGetName());</div><div class="line">undefined</div><div class="line"></div><div class="line">console.log(object.arrowGetThis());  // [object Window]</div><div class="line">Window &#123;</div><div class="line">    stop: function,</div><div class="line">    open: function,</div><div class="line">    alert: function,</div><div class="line">    confirm: function,</div><div class="line">    prompt: function,</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(this);  同上</div><div class="line"></div><div class="line">console.log(object.regularGetName());</div><div class="line"></div><div class="line">Name</div><div class="line"></div><div class="line">console.log(object.regularGetThis());</div><div class="line">Object &#123;</div><div class="line">    name: &quot;Name&quot;,</div><div class="line">    arrowGetName: function,</div><div class="line">    regularGetName: function,</div><div class="line">    arrowGetThis: function,</div><div class="line">    regularGetThis: function</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道“真正”语言中的类(Classes)。在 ES6 中类(Classes)其实是原型继承的语法糖。</p>
<p>ES6代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class SkinnedMesh extends THREE.Mesh &#123;</div><div class="line">  constructor(geometry, materials) &#123;</div><div class="line">    super(geometry, materials);</div><div class="line"></div><div class="line">    this.idMatrix = SkinnedMesh.defaultMatrix();</div><div class="line">    this.bones = [];</div><div class="line">    this.boneMatrices = [];</div><div class="line">    //...</div><div class="line">  &#125;</div><div class="line">  update(camera) &#123;</div><div class="line">    //...</div><div class="line">    super.update();</div><div class="line">  &#125;</div><div class="line">  get boneCount() &#123;</div><div class="line">    return this.bones.length;</div><div class="line">  &#125;</div><div class="line">  set matrixType(matrixType) &#123;</div><div class="line">    this.idMatrix = SkinnedMesh[matrixType]();</div><div class="line">  &#125;</div><div class="line">  static defaultMatrix() &#123;</div><div class="line">    return new THREE.Matrix4();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="增强的对象字面量"><a href="#增强的对象字面量" class="headerlink" title="增强的对象字面量"></a>增强的对象字面量</h1><p>ES6代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var theProtoObj = &#123;</div><div class="line">  toString: function() &#123;</div><div class="line">    return &quot;The ProtoOBject To string&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var handler = () =&amp;gt; &quot;handler&quot;</div><div class="line">var obj = &#123;</div><div class="line">    // __proto__</div><div class="line">    __proto__: theProtoObj,</div><div class="line">    // Shorthand for ‘handler: handler’</div><div class="line">    handler,</div><div class="line">    // Methods</div><div class="line">    toString() &#123;</div><div class="line">     // Super calls</div><div class="line">     return &quot;d &quot; + super.toString();</div><div class="line">    &#125;,</div><div class="line">    // Computed (dynamic) property names</div><div class="line">    [ &quot;prop_&quot; + (() =&amp;gt; 42)() ]: 42</div><div class="line">&#125;;</div><div class="line"></div><div class="line">console.log(obj.handler)</div><div class="line">console.log(obj.handler())</div><div class="line">console.log(obj.toString())</div><div class="line">console.log(obj.prop_42)</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">obj.handler // () =&amp;gt; &quot;handler&quot;</div><div class="line">obj.handler() // handler</div><div class="line">obj.toString() // d The ProtoOBject To string</div><div class="line">obj.prop_42 //</div><div class="line">(() =&amp;gt; 42)()  是一个立即执行函数 (() =&amp;gt; 42)() 相当于</div><div class="line">(function() &#123;</div><div class="line">    return 42;</div><div class="line">&#125;)()</div><div class="line">42</div></pre></td></tr></table></figure>
<h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var name = &quot;Bob&quot;, time = &quot;today&quot;;</div><div class="line"></div><div class="line">var multiLine = `This Line Spans Multiple Lines`；</div><div class="line"></div><div class="line">console.log(`Hello $&#123;name&#125;,how are you $&#123;time&#125;?`)</div><div class="line">console.log(multiLine)</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a // 1</div><div class="line">b // 3</div></pre></td></tr></table></figure>
<h2 id="对象也能很好的解构"><a href="#对象也能很好的解构" class="headerlink" title="对象也能很好的解构"></a>对象也能很好的解构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nodes = () =&gt; &#123; return &#123;op: &quot;a&quot;, lhs: &quot;b&quot;, rhs: &quot;c&quot;&#125;&#125;</div><div class="line">var &#123; op: a, lhs: b , rhs: c &#125; = nodes()</div><div class="line">console.log(a)</div><div class="line">console.log(b)</div><div class="line">console.log(c)</div></pre></td></tr></table></figure>
<p>##结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a // a</div><div class="line">b // b</div><div class="line">c // c</div></pre></td></tr></table></figure>
<h2 id="使用速记表示法"><a href="#使用速记表示法" class="headerlink" title="使用速记表示法"></a>使用速记表示法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">nodes = () =&gt; &#123; return &#123;lhs: &quot;a&quot;, op: &quot;b&quot;, rhs: &quot;c&quot;&#125;&#125;</div><div class="line"></div><div class="line">// binds `op`, `lhs` and `rhs` in scope</div><div class="line">var &#123;op, lhs, rhs&#125; = nodes()</div><div class="line"></div><div class="line">console.log(op)</div><div class="line">console.log(lhs)</div><div class="line">console.log(rhs)</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">op // b</div><div class="line">lhs // a</div><div class="line">rhs // c</div></pre></td></tr></table></figure>
<h2 id="可在参数位置使用"><a href="#可在参数位置使用" class="headerlink" title="可在参数位置使用"></a>可在参数位置使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function g(&#123;name: x&#125;) &#123;</div><div class="line">  return x</div><div class="line">&#125;</div><div class="line"></div><div class="line">function m(&#123;name&#125;) &#123;</div><div class="line">  return name</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(g(&#123;name: 5&#125;))</div><div class="line">console.log(m(&#123;name: 5&#125;))</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g(&#123;name: 5&#125;) // 5</div><div class="line">m(&#123;name: 5&#125;) // 5</div></pre></td></tr></table></figure>
<h1 id="故障弱化解构"><a href="#故障弱化解构" class="headerlink" title="故障弱化解构"></a>故障弱化解构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var [a] = []</div><div class="line">var [b = 1] = []</div><div class="line">var c = [];</div><div class="line">console.log(a)</div><div class="line">console.log(b);</div><div class="line">console.log(c);</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a // undefined</div><div class="line">b // 1</div><div class="line">c // []</div></pre></td></tr></table></figure>
<h1 id="参数默认值（Default）"><a href="#参数默认值（Default）" class="headerlink" title="参数默认值（Default）"></a>参数默认值（Default）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function f(x, y=12) &#123;</div><div class="line">  return x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(f(3))</div><div class="line">console.log(f(3,2))</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f(3) // 15</div><div class="line">f(3,2) // 5</div></pre></td></tr></table></figure>
<h1 id="扩展（Spread）"><a href="#扩展（Spread）" class="headerlink" title="扩展（Spread）"></a>扩展（Spread）</h1><p>在函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function f(x, y, z) &#123;</div><div class="line">  return x + y + z;</div><div class="line">&#125;</div><div class="line">// 传递数组的每个元素作为参数</div><div class="line">console.log(f(...[1,2,3]))</div></pre></td></tr></table></figure>
<p>##结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(...[1,2,3]) // 6</div></pre></td></tr></table></figure>
<h1 id="在数组中"><a href="#在数组中" class="headerlink" title="在数组中"></a>在数组中</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var parts = [&quot;shoulders&quot;, &quot;knees&quot;];</div><div class="line">var lyrics = [&quot;head&quot;, ...parts, &quot;and&quot;, &quot;toes&quot;];</div><div class="line"></div><div class="line">console.log(lyrics)</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var parts = [&quot;shoulders&quot;, &quot;knees&quot;];</div><div class="line">var lyrics = [&quot;head&quot;, ...parts, &quot;and&quot;, &quot;toes&quot;];</div><div class="line"></div><div class="line">console.log(lyrics)</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lyrics // [&quot;head&quot;,&quot;shoulders&quot;,&quot;knees&quot;,&quot;and&quot;,&quot;toes&quot;]</div></pre></td></tr></table></figure>
<h2 id="扩展-对象字面量"><a href="#扩展-对象字面量" class="headerlink" title="扩展 + 对象字面量"></a>扩展 + 对象字面量</h2><p>我们可以使用这个创造很酷的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;</div><div class="line">console.log(x); // 1</div><div class="line">console.log(y); // 2</div><div class="line">console.log(z); // &#123; a: 3, b: 4 &#125;</div><div class="line"></div><div class="line">// Spread properties</div><div class="line">let n = &#123; x, y, ...z &#125;;</div><div class="line">console.log(n); // &#123; x: 1, y: 2, a: 3, b: 4 &#125;</div><div class="line">console.log(obj)</div><div class="line">可惜的是它还不支持：</div><div class="line"></div><div class="line">npm install --save-dev babel-plugin-transform-object-rest-spread</div></pre></td></tr></table></figure>
<h1 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h1><p>我们可以使用 rest 操作符来允许无限参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function demo(part1, ...part2) &#123;</div><div class="line">    return &#123;part1, part2&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(demo(1,2,3,4,5,6))</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">demo(1,2,3,4,5,6) // &#123;&quot;part1&quot;:1,&quot;part2&quot;:[2,3,4,5,6]&#125;</div></pre></td></tr></table></figure>
<h1 id="Let"><a href="#Let" class="headerlink" title="Let"></a>Let</h1><p>let是新的var。 因为它有块级作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   var globalVar = &quot;from demo1&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">   let globalLet = &quot;from demo2&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(globalVar)</div><div class="line">console.log(globalLet)</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">globalVar // from demo1</div><div class="line">globalLet // ReferenceError: globalLet is not defined</div></pre></td></tr></table></figure>
<p>但是，它不会向window分配任何内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let me = &quot;go&quot;;  // 全局作用域</div><div class="line">var i = &quot;able&quot;; // 全局作用域</div><div class="line"></div><div class="line">console.log(window.me);</div><div class="line">console.log(window.i);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">window.me // undefined</div><div class="line">window.i // able</div></pre></td></tr></table></figure>
<p>不能使用let重新声明一个变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let me = &quot;foo&quot;;</div><div class="line">let me = &quot;bar&quot;;</div><div class="line">console.log(me);</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SyntaxError: Identifier &apos;me&apos; has already been declared</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var me = &quot;foo&quot;;</div><div class="line">var me = &quot;bar&quot;;</div><div class="line">console.log(me)</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">me // bar</div></pre></td></tr></table></figure>
<h1 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h1><p>const 是只读变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const a = &quot;b&quot;</div><div class="line">a = &quot;a&quot;</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TypeError: Assignment to constant variable.</div></pre></td></tr></table></figure>
<p>const 对象仍然可以被改变的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const a = &#123; a: &quot;a&quot; &#125;</div><div class="line">a.a = &quot;b&quot;</div><div class="line">console.log(a)</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a // &#123;&quot;a&quot;:&quot;b&quot;&#125;</div></pre></td></tr></table></figure>
<h1 id="For-of"><a href="#For-of" class="headerlink" title="For..of"></a>For..of</h1><p>迭代器的新类型，可以替代for..in。它返回的是值而不是keys</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let list = [4, 5, 6];</div><div class="line">console.log(list)</div><div class="line">for (let i in list) &#123;</div><div class="line">   console.log(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list // [4,5,6]</div><div class="line">i // 0</div><div class="line">i // 1</div><div class="line">i // 2</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let list = [4, 5, 6];</div><div class="line">console.log(list)</div><div class="line">for (let i of list) &#123;</div><div class="line">   console.log(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list // [4,5,6]</div><div class="line">i // 4</div><div class="line">i // 5</div><div class="line">i // 6</div></pre></td></tr></table></figure>
<h1 id="迭代器（Iterators）"><a href="#迭代器（Iterators）" class="headerlink" title="迭代器（Iterators）"></a>迭代器（Iterators）</h1><p>迭代器是一个比数组更动态的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let infinite = &#123;</div><div class="line">  [Symbol.iterator]() &#123;</div><div class="line">    let c = 0;</div><div class="line">    return &#123;</div><div class="line">      next() &#123;</div><div class="line">        c++;</div><div class="line">        return &#123; done: false, value: c &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(&quot;start&quot;);</div><div class="line"></div><div class="line">for (var n of infinite) &#123;</div><div class="line">  // truncate the sequence at 1000</div><div class="line">  if (n &amp;gt; 10)</div><div class="line">    break;</div><div class="line">  console.log(n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&quot;start&quot; // start</div><div class="line">n // 1</div><div class="line">n // 2</div><div class="line">n // 3</div><div class="line">n // 4</div><div class="line">n // 5</div><div class="line">n // 6</div><div class="line">n // 7</div><div class="line">n // 8</div><div class="line">n // 9</div><div class="line">n // 10</div></pre></td></tr></table></figure>
<p>使用Typescript，我们可以看到它接口的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Typescript 代码:</div><div class="line">interface IteratorResult &#123;</div><div class="line">  done: boolean;</div><div class="line">  value: any;</div><div class="line">&#125;</div><div class="line">interface Iterator &#123;</div><div class="line">  next(): IteratorResult;</div><div class="line">&#125;</div><div class="line">interface Iterable &#123;</div><div class="line">  [Symbol.iterator](): Iterator</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="生成器（Generators）"><a href="#生成器（Generators）" class="headerlink" title="生成器（Generators）"></a>生成器（Generators）</h1><p>生成器创建迭代器，并且比迭代器更具动态性。他们不必以相同的方式跟踪状态 并不支持 done 的概念。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var infinity = &#123;</div><div class="line">  [Symbol.iterator]: function*() &#123;</div><div class="line">    var c = 1;</div><div class="line">    for (;;) &#123;   </div><div class="line">      yield c++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(&quot;start&quot;)</div><div class="line">for (var n of infinity) &#123;</div><div class="line">  // truncate the sequence at 1000</div><div class="line">  if (n &amp;gt; 10)</div><div class="line">    break;</div><div class="line">  console.log(n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&quot;start&quot; // start</div><div class="line">n // 1</div><div class="line">n // 2</div><div class="line">n // 3</div><div class="line">n // 4</div><div class="line">n // 5</div><div class="line">n // 6</div><div class="line">n // 7</div><div class="line">n // 8</div><div class="line">n // 9</div><div class="line">n // 10</div></pre></td></tr></table></figure>
<p>使用Typescript 再次显示接口：</p>
<p>Typescript 代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface Generator extends Iterator &#123;</div><div class="line">    next(value?: any): IteratorResult;</div><div class="line">    throw(exception: any);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="function-Iterators-and-generator"><a href="#function-Iterators-and-generator" class="headerlink" title="function* Iterators and generator"></a>function* Iterators and generator</h1><p>一个产量的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function* anotherGenerator(i) &#123;</div><div class="line">  yield i + 1;</div><div class="line">  yield i + 2;</div><div class="line">  yield i + 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function* generator(i) &#123;</div><div class="line">  yield i;</div><div class="line">  yield* anotherGenerator(i);</div><div class="line">  yield i + 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var gen = generator(10);</div><div class="line"></div><div class="line">console.log(gen.next().value);</div><div class="line">console.log(gen.next().value);</div><div class="line">console.log(gen.next().value);</div><div class="line">console.log(gen.next().value);</div><div class="line">console.log(gen.next().value);</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gen.next().value // 10</div><div class="line">gen.next().value // 11</div><div class="line">gen.next().value // 12</div><div class="line">gen.next().value // 13</div><div class="line">gen.next().value // 20</div></pre></td></tr></table></figure>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>ES6 为Unicode 提供了更好的支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var regex = new RegExp(&apos;\u&#123;61&#125;&apos;, &apos;u&apos;);</div><div class="line"></div><div class="line">console.log(regex.unicode)</div><div class="line">console.log(&quot;\uD842\uDFD7&quot;)</div><div class="line">console.log(&quot;\uD842\uDFD7&quot;.codePointAt())</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">regex.unicode // true</div><div class="line">&quot;&quot; //</div><div class="line">&quot;&quot;.codePointAt() // 134103</div></pre></td></tr></table></figure>
<h1 id="模块和模块加载器"><a href="#模块和模块加载器" class="headerlink" title="模块和模块加载器"></a>模块和模块加载器</h1><p>原生支持模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">import defaultMember from &quot;module-name&quot;;</div><div class="line">import * as name from &quot;module-name&quot;;</div><div class="line">import &#123; member &#125; from &quot;module-name&quot;;</div><div class="line">import &#123; member as alias &#125; from &quot;module-name&quot;;</div><div class="line">import &#123; member1 , member2 &#125; from &quot;module-name&quot;;</div><div class="line">import &#123; member1 , member2 as alias2 , [...] &#125; from &quot;module-name&quot;;</div><div class="line">import defaultMember, &#123; member [ , [...] ] &#125; from &quot;module-name&quot;;</div><div class="line">import defaultMember, * as name from &quot;module-name&quot;;</div><div class="line">import &quot;module-name&quot;;</div><div class="line">export &#123; name1, name2, …, nameN &#125;;</div><div class="line">export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;</div><div class="line">export let name1, name2, …, nameN; // also var</div><div class="line">export let name1 = …, name2 = …, …, nameN; // also var, const</div><div class="line"></div><div class="line">export expression;</div><div class="line">export default expression;</div><div class="line">export default function (…) &#123; … &#125; // also class, function*</div><div class="line">export default function name1(…) &#123; … &#125; // also class, function*</div><div class="line">export &#123; name1 as default, … &#125;;</div><div class="line"></div><div class="line">export * from …;</div><div class="line">export &#123; name1, name2, …, nameN &#125; from …;</div><div class="line">export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;</div><div class="line">Import Export</div></pre></td></tr></table></figure>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 为数学对应，其中所有项目都是唯一的。对于知道SQL的人来说，这相当于distinct。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var set = new Set();</div><div class="line">set.add(&quot;Potato&quot;).add(&quot;Tomato&quot;).add(&quot;Tomato&quot;);</div><div class="line">console.log(set.size)</div><div class="line">console.log(set.has(&quot;Tomato&quot;))</div><div class="line"></div><div class="line">for(var item of set) &#123;</div><div class="line">   console.log(item)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">set.size // 2</div><div class="line">set.has(&quot;Tomato&quot;) // true</div><div class="line">item // Potato</div><div class="line">item // Tomato</div></pre></td></tr></table></figure>
<h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><p>WeakSet对象允许您在集合中存储弱持有的对象。没有引用的对象将被垃圾回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var item = &#123; a:&quot;Potato&quot;&#125;</div><div class="line">var set = new WeakSet();</div><div class="line">set.add(&#123; a:&quot;Potato&quot;&#125;).add(item).add(&#123; a:&quot;Tomato&quot;&#125;).add(&#123; a:&quot;Tomato&quot;&#125;);</div><div class="line">console.log(set.size)</div><div class="line">console.log(set.has(&#123;a:&quot;Tomato&quot;&#125;))</div><div class="line">console.log(set.has(item))</div><div class="line"></div><div class="line">for(let item of set) &#123;</div><div class="line">   console.log(item)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">set.size // undefined</div><div class="line">set.has(&#123;a:&quot;Tomato&quot;&#125;) // false</div><div class="line">set.has(item) // true</div><div class="line">TypeError: set[Symbol.iterator] is not a function</div></pre></td></tr></table></figure>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map也称词典</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var map = new Map();</div><div class="line">map.set(&quot;Potato&quot;, 12);</div><div class="line">map.set(&quot;Tomato&quot;, 34);</div><div class="line"></div><div class="line">console.log(map.get(&quot;Potato&quot;))</div><div class="line"></div><div class="line">for(let item of map) &#123;</div><div class="line">   console.log(item)</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(let item in map) &#123;</div><div class="line">   console.log(item)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">map.get(&quot;Potato&quot;) // 12</div><div class="line">item // [&quot;Potato&quot;,12]</div><div class="line">item // [&quot;Tomato&quot;,34]</div></pre></td></tr></table></figure>
<p>可以使用除字符串之外的其他类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var map = new Map();</div><div class="line">var key = &#123;a: &quot;a&quot;&#125;</div><div class="line">map.set(key, 12);</div><div class="line"></div><div class="line">console.log(map.get(key))</div><div class="line">console.log(map.get(&#123;a: &quot;a&quot;&#125;))</div></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">map.get(key) // 12</div><div class="line">map.get(&#123;a: &quot;a&quot;&#125;) // undefined</div></pre></td></tr></table></figure>
<h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><p>使用键的对象，并且只保留对键的弱引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var wm = new WeakMap();</div><div class="line"></div><div class="line">var o1  = &#123;&#125;</div><div class="line">var o2  = &#123;&#125;</div><div class="line">var o3  = &#123;&#125;</div><div class="line">wm.set(o1, 1);</div><div class="line">wm.set(o2, 2);</div><div class="line">wm.set(o3, &#123;a: &quot;a&quot;&#125;);</div><div class="line">wm.set(&#123;&#125;, 4);</div><div class="line"></div><div class="line">console.log(wm.get(o2));</div><div class="line">console.log(wm.has(&#123;&#125;))</div><div class="line"></div><div class="line">delete o2;</div><div class="line"></div><div class="line">console.log(wm.get(o3));</div><div class="line"></div><div class="line">for(let item in wm) &#123;</div><div class="line">   console.log(item)</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(let item of wm) &#123;</div><div class="line">   console.log(item)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wm.get(o2) // 2</div><div class="line">wm.has(&#123;&#125;) // false</div><div class="line">wm.get(o3) // &#123;&quot;a&quot;:&quot;a&quot;&#125;</div><div class="line">TypeError: wm[Symbol.iterator] is not a function</div></pre></td></tr></table></figure>
<h1 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h1><p>代理可以用来改变对象的行为。 它们允许我们定义 trap 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var obj = function ProfanityGenerator() &#123;</div><div class="line">    return &#123;</div><div class="line">       words: &quot;Horrible words&quot;    </div><div class="line">    &#125;</div><div class="line">&#125;()</div><div class="line"></div><div class="line">var handler = function CensoringHandler() &#123;</div><div class="line">        return &#123;</div><div class="line">        get: function (target, key) &#123;</div><div class="line">            return target[key].replace(&quot;Horrible&quot;, &quot;Nice&quot;);</div><div class="line">        &#125;,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;()</div><div class="line"></div><div class="line">var proxy = new Proxy(obj, handler);</div><div class="line"></div><div class="line">console.log(proxy.words);</div></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy.words // Nice words</div></pre></td></tr></table></figure>
<p>提供以下 trap ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var handler =</div><div class="line">&#123;</div><div class="line">  get:...,</div><div class="line">  set:...,</div><div class="line">  has:...,</div><div class="line">  deleteProperty:...,</div><div class="line">  apply:...,</div><div class="line">  construct:...,</div><div class="line">  getOwnPropertyDescriptor:...,</div><div class="line">  defineProperty:...,</div><div class="line">  getPrototypeOf:...,</div><div class="line">  setPrototypeOf:...,</div><div class="line">  enumerate:...,</div><div class="line">  ownKeys:...,</div><div class="line">  preventExtensions:...,</div><div class="line">  isExtensible:...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Symbols 是一个新类型。 可用于创建匿名属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var typeSymbol = Symbol(&quot;type&quot;);</div><div class="line"></div><div class="line">class Pet &#123;</div><div class="line"></div><div class="line">  constructor(type) &#123;</div><div class="line"></div><div class="line">    this[typeSymbol] = type;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  getType() &#123;</div><div class="line">     return this[typeSymbol];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = new Pet(&quot;dog&quot;);</div><div class="line">console.log(a.getType());</div><div class="line">console.log(Object.getOwnPropertyNames(a))</div><div class="line"></div><div class="line">console.log(Symbol(&quot;a&quot;) === Symbol(&quot;a&quot;))</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a.getType() // dog</div><div class="line">Object.getOwnPropertyNames(a) // []</div><div class="line">Symbol(&quot;a&quot;) === Symbol(&quot;a&quot;) // false</div></pre></td></tr></table></figure>
<h1 id="可继承内置函数"><a href="#可继承内置函数" class="headerlink" title="可继承内置函数"></a>可继承内置函数</h1><p>我们现在可以继承原生类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class CustomArray extends Array &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">var a = new CustomArray();</div><div class="line"></div><div class="line">a[0] = 2</div><div class="line">console.log(a[0])</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[0] // 2</div></pre></td></tr></table></figure>
<p>不能使用数组的代理(Proxy)来覆盖getter函数。</p>
<h1 id="新类库"><a href="#新类库" class="headerlink" title="新类库"></a>新类库</h1><p>各种新的方法和常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">console.log(Number.EPSILON)</div><div class="line">console.log(Number.isInteger(Infinity))</div><div class="line">console.log(Number.isNaN(&quot;NaN&quot;))</div><div class="line"></div><div class="line">console.log(Math.acosh(3))</div><div class="line">console.log(Math.hypot(3, 4))</div><div class="line">console.log(Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2))</div><div class="line"></div><div class="line">console.log(&quot;abcde&quot;.includes(&quot;cd&quot;) )</div><div class="line">console.log(&quot;abc&quot;.repeat(3) )</div><div class="line"></div><div class="line">console.log(Array.of(1, 2, 3) )</div><div class="line">console.log([0, 0, 0].fill(7, 1) )</div><div class="line">console.log([1, 2, 3].find(x =&amp;gt; x == 3) )</div><div class="line">console.log([1, 2, 3].findIndex(x =&amp;gt; x == 2))</div><div class="line">console.log([1, 2, 3, 4, 5].copyWithin(3, 0))</div><div class="line">console.log([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() )</div><div class="line">console.log([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() )</div><div class="line">console.log([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() )</div><div class="line"></div><div class="line">console.log(Object.assign(&#123;&#125;, &#123; origin: new Point(0,0) &#125;))</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Number.EPSILON // 2.220446049250313e-16</div><div class="line">Number.isInteger(Infinity) // false</div><div class="line">Number.isNaN(&quot;NaN&quot;) // false</div><div class="line">Math.acosh(3) // 1.7627471740390859</div><div class="line">Math.hypot(3, 4) // 5</div><div class="line">Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2</div><div class="line">&quot;abcde&quot;.includes(&quot;cd&quot;) // true</div><div class="line">&quot;abc&quot;.repeat(3) // abcabcabc</div><div class="line">Array.of(1, 2, 3) // [1,2,3]</div><div class="line">[0, 0, 0].fill(7, 1) // [0,7,7]</div><div class="line">[1, 2, 3].find(x =&amp;gt; x == 3) // 3</div><div class="line">[1, 2, 3].findIndex(x =&amp;gt; x == 2) // 1</div><div class="line">[1, 2, 3, 4, 5].copyWithin(3, 0) // [1,2,3,1,2]</div><div class="line">[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // &#123;&#125;</div><div class="line">[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // &#123;&#125;</div><div class="line">[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // TypeError: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;].values is not a function</div><div class="line">Object.assign(&#123;&#125;, &#123; origin: new Point(0,0) &#125;) // ReferenceError: Point is not defined</div><div class="line">文档: Number, Math, Array.from, Array.of, Array.prototype.copyWithin, Object.assign</div></pre></td></tr></table></figure>
<h1 id="二进制和八进制"><a href="#二进制和八进制" class="headerlink" title="二进制和八进制"></a>二进制和八进制</h1><p>二进制和八进制数字的字面量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(0b11111)</div><div class="line">console.log(0o2342)</div><div class="line"></div><div class="line">console.log(0xff); // also in es5</div></pre></td></tr></table></figure>
<p>结果：</p>
<p>ES6 代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0b11111 // 31</div><div class="line">0o2342 // 1250</div><div class="line">0xff // 255</div></pre></td></tr></table></figure></p>
<h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>异步编程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise((resolve, reject) =&amp;gt; &#123;</div><div class="line">  setTimeout(() =&amp;gt; resolve(&quot;1&quot;), 101)</div><div class="line">&#125;)</div><div class="line">var p2 = new Promise((resolve, reject) =&amp;gt; &#123;</div><div class="line">  setTimeout(() =&amp;gt; resolve(&quot;2&quot;), 100)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">Promise.race([p1, p2]).then((res) =&amp;gt; &#123;</div><div class="line">   console.log(res)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">Promise.all([p1, p2]).then((res) =&amp;gt; &#123;</div><div class="line">   console.log(res)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">res // 2</div><div class="line">res // [&quot;1&quot;,&quot;2&quot;]</div></pre></td></tr></table></figure>
<h2 id="快速的Promise"><a href="#快速的Promise" class="headerlink" title="快速的Promise"></a>快速的Promise</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var p1 = Promise.resolve(&quot;1&quot;)</div><div class="line">var p2 = Promise.reject(&quot;2&quot;)</div><div class="line"></div><div class="line">Promise.race([p1, p2]).then((res) =&amp;gt; &#123;</div><div class="line">   console.log(res)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">res // 1</div></pre></td></tr></table></figure>
<h2 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h2><p>如果一个 promise 失败，all和race也将 reject(拒绝)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise((resolve, reject) =&amp;gt; &#123;</div><div class="line">  setTimeout(() =&amp;gt; resolve(&quot;1&quot;), 1001)</div><div class="line">&#125;)</div><div class="line">var p2 = new Promise((resolve, reject) =&amp;gt; &#123;</div><div class="line">  setTimeout(() =&amp;gt; reject(&quot;2&quot;), 1)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">Promise.race([p1, p2]).then((res) =&amp;gt; &#123;</div><div class="line">   console.log(&quot;success&quot; + res)</div><div class="line">&#125;, res =&amp;gt; &#123;</div><div class="line">   console.log(&quot;error &quot; + res)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">Promise.all([p1, p2]).then((res) =&amp;gt; &#123;</div><div class="line">   console.log(&quot;success&quot; + res)</div><div class="line">&#125;, res =&amp;gt; &#123;</div><div class="line">   console.log(&quot;error &quot; + res)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;error &quot; + res // error 2</div><div class="line">&quot;error &quot; + res // error 2</div></pre></td></tr></table></figure>
<h1 id="反射（Reflect）"><a href="#反射（Reflect）" class="headerlink" title="反射（Reflect）"></a>反射（Reflect）</h1><p>新类型的元编程与新的API现有的还有一些新的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var z = &#123;w: &quot;Super Hello&quot;&#125;</div><div class="line">var y = &#123;x: &quot;hello&quot;, __proto__: z&#125;;</div><div class="line"></div><div class="line">console.log(Reflect.getOwnPropertyDescriptor(y, &quot;x&quot;));</div><div class="line">console.log(Reflect.has(y, &quot;w&quot;));</div><div class="line">console.log(Reflect.ownKeys(y, &quot;w&quot;));</div><div class="line"></div><div class="line">console.log(Reflect.has(y, &quot;x&quot;));</div><div class="line">console.log(Reflect.deleteProperty(y,&quot;x&quot;))</div><div class="line">console.log(Reflect.has(y, &quot;x&quot;));</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Reflect.getOwnPropertyDescriptor(y, &quot;x&quot;) // &#123;&quot;value&quot;:&quot;hello&quot;,&quot;writable&quot;:true,&quot;enumerable&quot;:true,&quot;configurable&quot;:true&#125;</div><div class="line">Reflect.has(y, &quot;w&quot;) // true</div><div class="line">Reflect.ownKeys(y, &quot;w&quot;) // [&quot;x&quot;]</div><div class="line">Reflect.has(y, &quot;x&quot;) // true</div><div class="line">Reflect.deleteProperty(y,&quot;x&quot;) // true</div><div class="line">Reflect.has(y, &quot;x&quot;) // false</div></pre></td></tr></table></figure>
<h1 id="尾调用-Tail-Call-优化"><a href="#尾调用-Tail-Call-优化" class="headerlink" title="尾调用(Tail Call)优化"></a>尾调用(Tail Call)优化</h1><p>尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<p>ES6可以确保尾调用不会造成堆栈溢出。 （不是所有的实现工作）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function factorial(n, acc = 1) &#123;</div><div class="line">    if (n &amp;lt;= 1) return acc;</div><div class="line">    return factorial(n - 1, n * acc);</div><div class="line">&#125;</div><div class="line">console.log(factorial(10))</div><div class="line">console.log(factorial(100))</div><div class="line">console.log(factorial(1000))</div><div class="line">console.log(factorial(10000))</div><div class="line">console.log(factorial(100000))</div><div class="line">console.log(factorial(1000000))</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">factorial(10) // 3628800</div><div class="line">factorial(100) // 9.332621544394418e+157</div><div class="line">factorial(1000) // Infinity</div><div class="line">factorial(10000) // Infinity</div><div class="line">factorial(100000) // RangeError: Maximum call stack size exceeded</div><div class="line">factorial(1000000) // RangeError: Maximum call stack size exceeded</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6语法已经出来很久了，为了加强学习和记忆，总结一下ES6中出现的新特性，参考文章&lt;a href=&quot;http://es6.ruanyifeng.com/。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://es6.ruanyifeng.com/
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.chenqiangyi.cn/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://www.chenqiangyi.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>hexo 常用命令</title>
    <link href="http://www.chenqiangyi.cn/2017/03/16/hexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.chenqiangyi.cn/2017/03/16/hexo-常用命令/</id>
    <published>2017-03-15T16:19:46.000Z</published>
    <updated>2017-06-15T17:24:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install hexo -g #安装</div><div class="line">npm update hexo -g #升级</div><div class="line">hexo init #初始化</div></pre></td></tr></table></figure>
<h1 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h1><p><code>hexo n &quot;我的博客&quot;</code> == <code>hexo new &quot;我的博客&quot;</code> #新建文章</p>
<p><code>hexo p</code> == <code>hexo publish</code></p>
<p><code>hexo g</code> == <code>hexo generate</code> #生成</p>
<p><code>hexo s</code> == <code>hexo server</code> #启动服务预览</p>
<p><code>hexo d</code> == <code>hexo deploy</code> #部署</p>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p><code>hexo server</code> #Hexo 会监视文件变动并自动更新，您无须重启服务器。</p>
<p><code>hexo server -s</code> #静态模式</p>
<p><code>hexo server -p 5000</code> #更改端口</p>
<p><code>hexo server -i 192.168.1.1</code> #自定义IP</p>
<p><code>hexo clean</code> #清除缓存 网页正常情况下可以忽略词条命令</p>
<p><code>hexo g</code> #生成静态网页</p>
<p><code>hexo d</code> #开始部署</p>
<h1 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">两个命令的作用是相同的</div><div class="line">hexo generate --deploy</div><div class="line">hexo deploy --generate</div></pre></td></tr></table></figure>
<p><code>hexo deploy -g</code></p>
<p><code>hexo server -g</code></p>
<h1 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h1><p><code>hexo publish [layout] &lt;title&gt;</code></p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p><code>hexo new &quot;postName&quot;</code> #新建文章</p>
<p><code>hexo new page &quot;pageName&quot;</code> #新建页面</p>
<p><code>hexo generate</code> #生成静态页面至public目录</p>
<p><code>hexo server</code> #开启预览访问端口（默认端口4000, ‘ctrl + c’关闭server）</p>
<p><code>hexo deploy</code> #将.deploy目录部署到Github</p>
<p><code>hexo new [layout] &lt;title&gt;</code></p>
<p><code>hexo new photo &quot;My Gallery&quot;</code></p>
<p><code>hexo new &quot;Hello World&quot; --chen</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">layout</td>
<td style="text-align:center">布局</td>
</tr>
<tr>
<td style="text-align:center">title</td>
<td style="text-align:center">标题</td>
</tr>
<tr>
<td style="text-align:center">date</td>
<td style="text-align:center">文件建立日期</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">title: 使用Hexo搭建个人博客</div><div class="line">layout: post</div><div class="line">date: 2014-03-03 19:07:43</div><div class="line">comments: true</div><div class="line">categories: Blog</div><div class="line">tags: [Hexo]</div><div class="line">keywords: Hexo, Blog</div><div class="line">description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。</div></pre></td></tr></table></figure>
<h1 id="模板（Scaffold）"><a href="#模板（Scaffold）" class="headerlink" title="模板（Scaffold）"></a>模板（Scaffold）</h1><p><code>hexo new photo &quot;My Gallery&quot;</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">layout</td>
<td style="text-align:center">布局</td>
</tr>
<tr>
<td style="text-align:center">title</td>
<td style="text-align:center">标题</td>
</tr>
<tr>
<td style="text-align:center">date</td>
<td style="text-align:center">文件建立日期</td>
</tr>
</tbody>
</table>
<h1 id="设置文章摘要"><a href="#设置文章摘要" class="headerlink" title="设置文章摘要"></a>设置文章摘要</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">以上是文章摘要 &lt;!--more--&gt; 以下是余下全文</div></pre></td></tr></table></figure>
<h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><p><code>hexo new page &lt;title&gt;</code></p>
<p><code>hexo new post &lt;title&gt;</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">:title</td>
<td style="text-align:center">标题</td>
</tr>
<tr>
<td style="text-align:center">:year</td>
<td style="text-align:center">建立的年份（4 位数）</td>
</tr>
<tr>
<td style="text-align:center">:month</td>
<td style="text-align:center">建立的月份（2 位数）</td>
</tr>
<tr>
<td style="text-align:center">:i_month</td>
<td style="text-align:center">建立的月份（去掉开头的零）</td>
</tr>
<tr>
<td style="text-align:center">:day</td>
<td style="text-align:center">建立的日期（2 位数）</td>
</tr>
<tr>
<td style="text-align:center">:i_day</td>
<td style="text-align:center">建立的日期（去掉开头的零）</td>
</tr>
</tbody>
</table>
<h1 id="推送到服务器上"><a href="#推送到服务器上" class="headerlink" title="推送到服务器上"></a>推送到服务器上</h1><p><code>hexo n</code> #写文章</p>
<p><code>hexo g</code> #生成</p>
<p><code>hexo d</code> #部署 可与 <code>hexo g</code> 合并为 <code>hexo d -g</code></p>
<p>一般部署步骤：</p>
<ul>
<li><code>hexo clean</code></li>
<li><code>hexo d -g</code></li>
</ul>
<h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><h2 id="找不到git部署"><a href="#找不到git部署" class="headerlink" title="找不到git部署"></a>找不到git部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR Deployer not found: git</div></pre></td></tr></table></figure>
<p>解决方法</p>
<p><code>npm install hexo-deployer-git --save</code></p>
<h2 id="部署类型设置git"><a href="#部署类型设置git" class="headerlink" title="部署类型设置git"></a>部署类型设置git</h2><p>hexo 3.0 部署类型不再是github, _config.yml 中修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: http://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repository: git@***.github.com:***/***.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<h2 id="xcodebuild"><a href="#xcodebuild" class="headerlink" title="xcodebuild"></a>xcodebuild</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcode-select: error: tool &apos;xcodebuild&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instance</div></pre></td></tr></table></figure>
<p><code>npm install bcrypt</code></p>
<h2 id="RSS-不显示"><a href="#RSS-不显示" class="headerlink" title="RSS 不显示"></a>RSS 不显示</h2><h3 id="安装RSS插件"><a href="#安装RSS插件" class="headerlink" title="安装RSS插件"></a>安装RSS插件</h3><p><code>npm install hexo-generator-feed --save</code></p>
<h3 id="开启RSS功能"><a href="#开启RSS功能" class="headerlink" title="开启RSS功能"></a>开启RSS功能</h3><p>编辑hexo/_config.yml，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rss: /atom.xml #rss地址  默认即可</div></pre></td></tr></table></figure>
<h2 id="开启评论"><a href="#开启评论" class="headerlink" title="开启评论"></a>开启评论</h2><p>多说已被关闭，推荐使用网易云</p>
<p>编辑theme目录下的_config.yml,添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">angyi_ygt: 506ecdd478bc49caab66fa9b5144  #这个为网易云申请的key</div></pre></td></tr></table></figure>
<p>相关文章：</p>
<ul>
<li><a href="https://hexo.io/" target="_blank" rel="external">hexo官网</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hexo&quot;&gt;&lt;a href=&quot;#hexo&quot; class=&quot;headerlink&quot; title=&quot;hexo&quot;&gt;&lt;/a&gt;hexo&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
    
    </summary>
    
      <category term="hexo 常用命令" scheme="http://www.chenqiangyi.cn/categories/hexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="hexo" scheme="http://www.chenqiangyi.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>call与apply详解</title>
    <link href="http://www.chenqiangyi.cn/2017/02/14/call%E4%B8%8Eapply%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.chenqiangyi.cn/2017/02/14/call与apply详解/</id>
    <published>2017-02-14T07:45:29.000Z</published>
    <updated>2017-06-25T15:06:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>JS apply和js call方法总是让初学者困惑，下文就apply和call的区别，什么情况下用apply,什么情况下用call、apply的巧妙用法来阐述js apply和js call方法的详细使用方法。</p>
</blockquote>
<p>call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。因为 JavaScript 的函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。二者的作用完全一样，只是接受参数的方式不太一样。例如，有一个函数 func1 定义如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>就可以通过</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func1.call(<span class="keyword">this</span>, arg1, arg2);</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func1.apply(<span class="keyword">this</span>, [arg1, arg2]);</div></pre></td></tr></table></figure>
<p>来调用。其中 this 是你想指定的上下文，他可以任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。</p>
<p>JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时，用 call，而不确定的时候，用apply，然后把参数 push 进数组传递进去。<br>当参数数量不确定时，函数内部也可以通过 arguments这个数组来便利所有的参数。</p>
<p>在javascript OOP中，我们经常会这样定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cat</span>(<span class="params"></span>) </span>&#123; &#125;</div><div class="line">cat.prototype = &#123;</div><div class="line">    <span class="attr">food</span>: <span class="string">"fish"</span>,</div><div class="line">    <span class="attr">say</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">"I love "</span>+<span class="keyword">this</span>.food);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> blackCat = <span class="keyword">new</span> cat;</div><div class="line">blackCat.say();</div></pre></td></tr></table></figure>
<p>但是如果我们有一个对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">whiteDog = &#123;<span class="attr">food</span>:<span class="string">"bone"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>我们不想对它重新定义say方法，那么我们可以通过call或apply用blackCat的say方法：blackCat.say.call(whiteDog);所以,可以看出call和apply是为了动态改变this而出现的，当一个object没有某个方法,但是其他的有，我们可以借助call或apply用其它对象的方法来操作。用的比较多的，通过document.getElementsByTagName选择的dom 节点是一种类似array的array。它不能应用Array下的push,pop等方法。我们可以通过：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> domNodes = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>));</div></pre></td></tr></table></figure>
<p>这样domNodes就可以应用Array下的所有方法了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">obj.call(thisObj, arg1, arg2, ...);</div><div class="line">obj.apply(thisObj, [arg1, arg2, ...]);</div></pre></td></tr></table></figure>
<p>两者作用一致，都是把obj(即this)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj『继承』了obj的属性和方法。唯一区别是apply接受的是数组参数，call接受的是连续参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">j, k</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> j+k;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">j, k</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> j-k;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在控制台运行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">add(<span class="number">5</span>,<span class="number">3</span>); <span class="comment">//8</span></div><div class="line">add.call(sub, <span class="number">5</span>, <span class="number">3</span>); <span class="comment">//8</span></div><div class="line">add.apply(sub, [<span class="number">5</span>, <span class="number">3</span>]); <span class="comment">//8</span></div><div class="line"></div><div class="line">sub(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">//2</span></div><div class="line">sub.call(add, <span class="number">5</span>, <span class="number">3</span>); <span class="comment">//2</span></div><div class="line">sub.apply(add, [<span class="number">5</span>, <span class="number">3</span>]); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>通过call和apply，我们可以实现对象继承。示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"yjc"</span>;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">22</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> child = &#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(child);<span class="comment">//Object &#123;&#125; ,空对象</span></div><div class="line">Parent.call(child);</div><div class="line"><span class="built_in">console</span>.log(child); <span class="comment">//Object &#123;name: "yjc", age: 22&#125;</span></div></pre></td></tr></table></figure>
<p>以上实现了对象的继承。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JS apply和js call方法总是让初学者困惑，下文就apply和call的区别，什么情况下用apply,什么情况下用call、apply的巧妙用法来阐述js apply和js call方法的详细使用方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.chenqiangyi.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.chenqiangyi.cn/tags/JavaScript/"/>
    
      <category term="call" scheme="http://www.chenqiangyi.cn/tags/call/"/>
    
      <category term="apply" scheme="http://www.chenqiangyi.cn/tags/apply/"/>
    
  </entry>
  
  <entry>
    <title>垂直水平居中总结</title>
    <link href="http://www.chenqiangyi.cn/2017/01/08/%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    <id>http://www.chenqiangyi.cn/2017/01/08/垂直水平居中总结/</id>
    <published>2017-01-08T10:48:00.000Z</published>
    <updated>2017-06-14T06:39:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>既然写到flex布局了，那就总结一下垂直水平居中遇到的问题吧</p>
<h1 id="宽高不定，上下左右垂直居中。"><a href="#宽高不定，上下左右垂直居中。" class="headerlink" title="宽高不定，上下左右垂直居中。"></a>宽高不定，上下左右垂直居中。</h1><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>绝对定位top left 各50%，然后 transform 负数撑回来</p>
<p>代码如下：</p>
<p>HTML代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;toast&quot;&gt;提交成功&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>CSS代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.toast &#123;</div><div class="line">  position: fixed;</div><div class="line">  top: 50%;</div><div class="line">  left: 50%;</div><div class="line">  transform: translate(-50%, -50%);</div><div class="line">  padding: 13px 16px;</div><div class="line">  font-size: 14px;</div><div class="line">  color: #ccc;</div><div class="line">  background-color: rgba(37, 38, 45, 0.9);</div><div class="line">  border-radius: 2px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://webapp.didistatic.com/static/webapp/shield/img01.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>But !这时候产品突然需要增加一个需求，Toast 组件一行最多只能有12个中文字符，超过的时候折行</p>
<p>看起来这个要求也不高 ~ 我们修改一下代码</p>
<p>CSS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.toast &#123;</div><div class="line">  position: fixed;</div><div class="line">  top: 50%;</div><div class="line">  left: 50%;</div><div class="line">  transform: translate(-50%, -50%);</div><div class="line">  padding: 13px 16px;</div><div class="line">  font-size: 14px;</div><div class="line">  color: #ccc;</div><div class="line">  background-color: rgba(37, 38, 45, 0.9);</div><div class="line">  border-radius: 2px;</div><div class="line">  // 新增代码如下</div><div class="line">  width: auto;</div><div class="line">  max-width: 12em;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下图</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://webapp.didistatic.com/static/webapp/shield/img02.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>可以看到，最终实现效果在第 9 个字的时候便折行了。这是为什么呢？我们把</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">transform: translate(-50%, -50%)</div></pre></td></tr></table></figure>
<p>去掉看一下</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://webapp.didistatic.com/static/webapp/shield/img03.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>可以看到容器宽度在到达屏幕边界的时候就被截断折行了。现在我们设定 left: 90% 看一下</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://webapp.didistatic.com/static/webapp/shield/img04.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>可以明显的看到容器被截断的更加严重。</p>
<p>至此我们分析得知，设置为 position: fixed 的元素不仅位置是相对于屏幕边界定位，如果不指定元素宽高的话，宽高同样也会相对于屏幕边界被截断。</p>
<p>那么如何解决这个问题呢 ~</p>
<p>代码如下 ~</p>
<p>HTML：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;toast-container&quot;&gt;</div><div class="line">  &lt;div class=&quot;toast&quot;&gt;测试十二个字提交成功状态&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>CSS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">.toast-container &#123;</div><div class="line">  position: fixed;</div><div class="line">  width: 100%;</div><div class="line">  height: 100%;</div><div class="line">  left: 100%;</div><div class="line">  top: 100%;</div><div class="line">&#125;</div><div class="line">.toast &#123;</div><div class="line">  position: absolute;</div><div class="line">  top: -50%;</div><div class="line">  left: -50%;</div><div class="line">  transform: translate(-50%, -50%);</div><div class="line">  width: auto;</div><div class="line">  max-width: 12em;</div><div class="line">  padding: 13px 16px;</div><div class="line">  font-size: 14px;</div><div class="line">  color: #ccc;</div><div class="line">  background-color: rgba(37, 38, 45, 0.9);</div><div class="line">  border-radius: 2px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 .toast 外加一个和屏幕宽高相同 .container 容器，将 .container 容器 fixed 定位到窗口外层，再将 .toast 通过 absolute 定位翻转过来即可。</p>
<p>效果如下:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://webapp.didistatic.com/static/webapp/shield/img05.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="用white-space-nowrap"><a href="#用white-space-nowrap" class="headerlink" title="用white-space:nowrap"></a>用white-space:nowrap</h2><p>代码：</p>
<p>HTML</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;toast&quot;&gt;提交成功提交成功提交成功&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>CSS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.toast &#123;</div><div class="line">  position: fixed;</div><div class="line">  top: 50%;</div><div class="line">  left: 50%;</div><div class="line">  transform: translate(-50%,-50%);</div><div class="line">  padding: 13px 16px;</div><div class="line">  font-size: 14px;</div><div class="line">  color: #ccc;</div><div class="line">  background-color: rgba(37, 38, 45, 0.9);</div><div class="line">  border-radius: 2px;</div><div class="line">  width: auto;</div><div class="line">  max-width: 12em;</div><div class="line">  white-space:nowrap ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://webapp.didistatic.com/static/webapp/shield/img05.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然写到flex布局了，那就总结一下垂直水平居中遇到的问题吧&lt;/p&gt;
&lt;h1 id=&quot;宽高不定，上下左右垂直居中。&quot;&gt;&lt;a href=&quot;#宽高不定，上下左右垂直居中。&quot; class=&quot;headerlink&quot; title=&quot;宽高不定，上下左右垂直居中。&quot;&gt;&lt;/a&gt;宽高不定，上
    
    </summary>
    
      <category term="垂直水平居中" scheme="http://www.chenqiangyi.cn/categories/%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/"/>
    
    
      <category term="css" scheme="http://www.chenqiangyi.cn/tags/css/"/>
    
      <category term="flex" scheme="http://www.chenqiangyi.cn/tags/flex/"/>
    
      <category term="垂直水平居中" scheme="http://www.chenqiangyi.cn/tags/%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>flex布局详解</title>
    <link href="http://www.chenqiangyi.cn/2017/01/08/flex%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.chenqiangyi.cn/2017/01/08/flex布局详解/</id>
    <published>2017-01-08T08:09:18.000Z</published>
    <updated>2017-06-14T11:31:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写东西了，既然定了每周一篇文章的计划，就要确保认真完成，这就当做是新年的第一篇文章吧！</p>
<p>最近在做微信小程序，微信小程序中的wxss中的布局用的flex布局，今天来总结一下flex布局。</p>
<h1 id="Flex布局是什么？"><a href="#Flex布局是什么？" class="headerlink" title="Flex布局是什么？"></a>Flex布局是什么？</h1><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为Flex布局。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>行内元素也可以使用Flex布局。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: inline-flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Webkit内核的浏览器，必须加上 -webkit 前缀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  display: -webkit-flex; /* Safari */</div><div class="line">  display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，设为Flex布局以后，子元素的float clear 和 vertical-align属性将失效。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<h1 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h1><p>以下6个属性设置在容器上。</p>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<h2 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h2><p>flex-direction属性决定主轴的方向（即项目的排列方向）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">  flex-direction: row | row-reverse | column | column-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>它可能有4个值。</p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
<h2 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h2><p>默认情况下，项目都排在一条线（又称”轴线”）上。属性定义，如果一条轴线排不下，如何换行。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它可能取三个值。</p>
<h3 id="默认-：不换行。"><a href="#默认-：不换行。" class="headerlink" title="(默认)：不换行。"></a>(默认)：不换行。</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="换行，第一行在上方。"><a href="#换行，第一行在上方。" class="headerlink" title="换行，第一行在上方。"></a>换行，第一行在上方。</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="换行，第一行在下方。"><a href="#换行，第一行在下方。" class="headerlink" title="换行，第一行在下方。"></a>换行，第一行在下方。</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2><p>flex-flow属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为row nowrap。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">  flex-flow: &amp;lt;flex-direction&amp;gt; || &amp;lt;flex-wrap&amp;gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h2><p>justify-content属性定义了项目在主轴上的对齐方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<h2 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h2><p>align-items 属性定义项目在交叉轴上如何对齐。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<h2 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h2><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>该属性可能取6个值。</p>
<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ul>
<h1 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h1><p>以下6个属性设置在项目上。</p>
<ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
<h2 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h2><p>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.item &#123;</div><div class="line">  order: &amp;lt;integer&amp;gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h2><p>flex-grow属性定义项目的放大比例，默认为，即如果存在剩余空间，也不放大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.item &#123;</div><div class="line">  flex-grow: &amp;lt;number&amp;gt;; /* default 0 */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><span 如果所有项目的属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。="" ##="" flex-shrink属性="" flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.item &#123;</div><div class="line">  flex-shrink: &amp;lt;number&amp;gt;; /* default 1 */</div><div class="line">&#125;</div></pre></td></tr></table>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>如果所有项目的属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。</p>
<h2 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h2><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;pre class=&quot;prettyprint lang-js&quot;&gt;.item &#123;</div><div class="line">  flex-basis: &amp;lt;length&amp;gt; | auto; /* default auto */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它可以设为跟 width 或 height 属性一样的值（比如350px），则项目将占据固定空间。</p>
<h2 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h2><p>flex属性是 flex-grow 和 flex-basis 的简写，默认值为0 1 auto。后两个属性可选。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.item &#123;</div><div class="line">  flex: none | [ &amp;lt;&apos;flex-grow&apos;&amp;gt; &amp;lt;&apos;flex-shrink&apos;&amp;gt;? || &amp;lt;&apos;flex-basis&apos;&amp;gt; ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该属性有两个快捷值：auto(1 1 auto) 和 none (0 0 auto)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h2 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h2><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch 。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
<hr>
<p>本文参考阮一峰老师的文章 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
</span>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没写东西了，既然定了每周一篇文章的计划，就要确保认真完成，这就当做是新年的第一篇文章吧！&lt;/p&gt;
&lt;p&gt;最近在做微信小程序，微信小程序中的wxss中的布局用的flex布局，今天来总结一下flex布局。&lt;/p&gt;
&lt;h1 id=&quot;Flex布局是什么？&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="css" scheme="http://www.chenqiangyi.cn/categories/css/"/>
    
    
      <category term="css" scheme="http://www.chenqiangyi.cn/tags/css/"/>
    
      <category term="flex" scheme="http://www.chenqiangyi.cn/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>回首2016，展望2017</title>
    <link href="http://www.chenqiangyi.cn/2017/01/01/%E5%9B%9E%E9%A6%962016%EF%BC%8C%E5%B1%95%E6%9C%9B2017/"/>
    <id>http://www.chenqiangyi.cn/2017/01/01/回首2016，展望2017/</id>
    <published>2016-12-31T17:58:18.000Z</published>
    <updated>2017-06-14T05:05:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本来是打算在年末写年度总结，结果就一直拖，一下拖到现在。一直说没时间其实就是懒。在去年年末的时候在知乎上看到好多人写的年度总结以及新的一年的展望，自己当时没有写，现在2016年结束了，总感觉少了点什么，大概就是当时年初没有定目标造成的空落感，所以今年加班也一定要把年度总结写完。本文分两部分，一部分回首2016年的种种，另一部分展望2017年，并制定年度计划。</p>
</blockquote>
<p>一、回首过去</p>
<ul>
<li>2016年初来的上海，在这里实习，学习，以及毕业找工作，期间结束了大学生活，走上了社会。在6月份的时候加入到了现在的公司，来到公司后先是熟悉公司所用的框架以及工作流程，后期慢慢开始进行对官网的升级以及修改。再往后就做了一个礼物直播的管理系统，再后来就是完成了支付宝表情搜搜的小程序，以及现在表情搜搜官网的设计与修改，还有未完成的表情搜搜微信小程序。在工作中学到了一些新技术，然而在做支付宝小程序的时候由于自己技术的不足造成了项目的进展缓慢，在这期间也学到了许多。后期就是微信小程序，现在还没开始动手，在最近几天将着手微信小程序。对于工作，由于官网框架的缘故，使得一些新的技术无法使用。在今后的新项目中要多使用新技术，使得学以致用。</li>
<li>在这一年中学到了不少新的技术，同时也有好多新技术只是初步了解，并没有彻底的过一遍并用在工作中。在这一年中新技术不断，不管是框架还是打包工具还是新的语法功能，都有了翻天覆地的变化。新出现的Vue2，angular2只是简单的敲了一下demo，体会到它语法的简洁以及功能的强大。对于热的一塌糊涂的react还没有来的及看，技术债来年一定会慢慢补上的。还有比较强大的node.js，现在是无处不在，所有的工程项目都要依赖node来搭建，还有webpack用以构建完整的工程项目，这一些都是自己的弱项，当时只是不求甚解的看了一下，到真正使用的时候发现还是不会用。还有一个新的变化就是es6，以及es7的到来，现在还并没有使用新的语法，所以下个阶段还要完成新语法的平稳过度。还有就是新的微信小程序，是一个新的机会，现在只是大概的了解其中的原理，真正项目还没有开始。过几天就着手微信小程序的开发。</li>
<li>对于过去一年技术的总结刚开始还能每周一篇技术文章，到了后面就没有怎么写了，写博客当初的初衷是记录成长的点滴，所以初心不能忘，新的一年每一周或者每月四篇技术文章的总结，也算是对自己技术提升的一个总结。2016年自己在github工作了122天，相对于那些大神，差的太远了，即便是不能天天工作，也要多完成一些项目，争取多写代码，多提交代码。在知乎，掘金和segmentfault上面的技术回答也寥寥无几，所以在新的一年要突破自己，多回答问题，多逛技术论坛。</li>
</ul>
<p>二、展望未来</p>
<ul>
<li>完成webpack构建工具的使用以及微信小程序的开发</li>
<li>完成对Vue2框架的整体学习，从打包构建工具到模块化以及到模板整体尝试，必须要完成一整个Vue2项目</li>
<li>完成react项目的实施以及react native移动端的项目尝试，并包含react全家桶的学习</li>
<li>学习typescript以及angular2的学习</li>
<li>完成node.js的学习，从桌面端到服务端，再到数据库的尝试</li>
<li>完成es6或es7的学习</li>
<li>每周一篇技术性博客的书写或者每个月四篇技术性文章的总结。</li>
<li>就是不断逛技术博客，以及研究发现别人的优秀项目，多提交项目记录，多敲代码，希望能在年末的时候github有半年的工作记录;</li>
<li>年龄也不小啦，该找个女朋友了</li>
</ul>
<p>三、总结</p>
<ul>
<li>对于前端来说2016年变化太多了，每一天都有新技术的更新，在前端从业人数的日益增多，前端的就业压力会越来越大，所以要不断提高自己的技术，才能使自己立于不败之地。对于新技术的各种撕逼自己要稳住自己，不能人云亦云，要加强自身基础知识的提高，不能眼高手低。2017年的年度计划挑战很大，不过把整年的年度计划划分为每一个季度、每一个月、每一周、每一天的计划，只要完成每天的小计划，大计划就会完成。相信自己，要改掉拖延症的毛病，每天努力一点点，就会有新的突破，不忘初心，方得始终。</li>
</ul>
<hr>
<p>致2017年年末总结，到时候看看完成了什么还有什么没完成。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本来是打算在年末写年度总结，结果就一直拖，一下拖到现在。一直说没时间其实就是懒。在去年年末的时候在知乎上看到好多人写的年度总结以及新的一年的展望，自己当时没有写，现在2016年结束了，总感觉少了点什么，大概就是当时年初没有定目标造成的空落感，所以今
    
    </summary>
    
      <category term="生活感悟" scheme="http://www.chenqiangyi.cn/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="生活感悟" scheme="http://www.chenqiangyi.cn/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
      <category term="新年总结" scheme="http://www.chenqiangyi.cn/tags/%E6%96%B0%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>mac 命令行 安装 需要管理员 权限“Please try running this command again as root/Administrator”的解决办法</title>
    <link href="http://www.chenqiangyi.cn/2016/12/19/mac%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9/"/>
    <id>http://www.chenqiangyi.cn/2016/12/19/mac权限修改/</id>
    <published>2016-12-19T02:47:17.000Z</published>
    <updated>2017-06-14T13:52:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>我们在进行mac 命令行安装软件的时候，有的时候会遇见这样的问题：Please try running this command again as root/Administrator.</p>
</blockquote>
<p>如图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.chenqiangyi.com/wp-content/uploads/2016/12/1-300x48.png" alt="1" title="">
                </div>
                <div class="image-caption">1</div>
            </figure>
<p>解决办法是在终端输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chown -R $USER /usr/local</div></pre></td></tr></table></figure>
<p>然后输入安装的密码，在执行相关安装命令就行了</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们在进行mac 命令行安装软件的时候，有的时候会遇见这样的问题：Please try running this command again as root/Administrator.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="mac命令" scheme="http://www.chenqiangyi.cn/categories/mac%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="mac命令" scheme="http://www.chenqiangyi.cn/tags/mac%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://www.chenqiangyi.cn/2016/11/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://www.chenqiangyi.cn/2016/11/15/排序算法/</id>
    <published>2016-11-15T15:43:03.000Z</published>
    <updated>2017-06-19T02:53:08.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var array = [1, 5, 6, 2 , 11, 3, 4, 8, 9, 15, 100, 20, 31, 256]</div></pre></td></tr></table></figure>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 最佳情况：T(n) = O(n)</div><div class="line">// 最差情况：T(n) = O(n2)</div><div class="line">// 平均情况：T(n) = O(n2)</div><div class="line">function bubbleSort(data, type) &#123;</div><div class="line">  var arr = data ? data : []</div><div class="line">  var i = data.length -1</div><div class="line">  while (i &gt; 0) &#123;</div><div class="line">    var post = 0</div><div class="line">    for (var j = 0; j &lt; i; j++) &#123;</div><div class="line">      if (arr[j] &gt; arr[j+1]) &#123;</div><div class="line">        post = j</div><div class="line">        var t = arr[j]</div><div class="line">        arr[j] = arr[j+1]</div><div class="line">        arr[j+1] = t</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    i = post</div><div class="line">  &#125;</div><div class="line">  arr =  type === &apos;max&apos; ? arr.reverse() : arr</div><div class="line">  return arr</div><div class="line">&#125;</div><div class="line"></div><div class="line">//console.log(bubbleSort(array, &apos;min&apos;))</div><div class="line">//console.log(bubbleSort(array, &apos;max&apos;))</div></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 最佳情况：T(n) = O(n2)</div><div class="line">// 最差情况：T(n) = O(n2)</div><div class="line">// 平均情况：T(n) = O(n2)</div><div class="line">function chooseSort(data, type) &#123;</div><div class="line">  var arr = data ? data : []</div><div class="line">  var l = arr.length</div><div class="line">  var minIndex, t</div><div class="line">  for (var i = 0; i &lt; l - 1; i++) &#123;</div><div class="line">    minIndex = i</div><div class="line">    for (var j = i + 1; j &lt; l - 1; j++) &#123;</div><div class="line">      if (arr[j] &lt; arr[minIndex]) &#123;</div><div class="line">        minIndex = j</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    t = arr[i]</div><div class="line">    arr[i] = arr[minIndex]</div><div class="line">    arr[minIndex] = t</div><div class="line">  &#125;</div><div class="line">  arr =  type === &apos;max&apos; ? arr.reverse() : arr</div><div class="line">  return arr</div><div class="line">&#125;</div><div class="line"></div><div class="line">// console.log(chooseSort(array, &apos;min&apos;))</div><div class="line">// console.log(chooseSort(array, &apos;max&apos;))</div></pre></td></tr></table></figure>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function insertSort(data, type) &#123;</div><div class="line">  var arr = data ? data : []</div><div class="line">  for (var i = 1; i &lt; arr.length; i ++) &#123;</div><div class="line">    var key = arr[i]</div><div class="line">    var j = i - 1</div><div class="line">    while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) &#123;</div><div class="line">      arr[j + 1] = arr[j]</div><div class="line">      j--</div><div class="line">    &#125;</div><div class="line">    arr[j + 1] = key</div><div class="line">  &#125;</div><div class="line">  arr =  type === &apos;max&apos; ? arr.reverse() : arr</div><div class="line">  return arr</div><div class="line">&#125;</div><div class="line"></div><div class="line">// console.log(insertSort(array, &apos;min&apos;))</div><div class="line">// console.log(insertSort(array, &apos;max&apos;))</div></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var array = [1, 5, 6, 2 , 11, 3, 4, 8, 9, 15, 100, 20, 31, 256, 1024]</div><div class="line"></div><div class="line">function quickSort (arr, type) &#123;</div><div class="line">  if (arr.length &lt;= 1) &#123;</div><div class="line">    return arr  //如果数组只有一个数就返回</div><div class="line">  &#125;</div><div class="line">  var index = Math.floor(arr.length / 2)  //找到中间数的索引值，如果是浮点数就向下取整</div><div class="line">  var pivot = arr.splice(index, 1)[0]  //找到中间数的值</div><div class="line">  var left = []</div><div class="line">  var right = []</div><div class="line">  for (var i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">    if (type === &apos;min&apos;) &#123;</div><div class="line">      arr[i] &lt; pivot ? left.push(arr[i]) : right.push(arr[i])  //基准点左边的数传到数组的左边</div><div class="line">    &#125; else &#123;</div><div class="line">      arr[i] &gt; pivot ? left.push(arr[i]) : right.push(arr[i])  //基准点右边的数传到数组的右边</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return quickSort(left, type).concat([pivot], quickSort(right, type))  //递归不断重复排序</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(quickSort(array, &apos;min&apos;))</div><div class="line">console.log(quickSort(array, &apos;max&apos;))</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;lin
    
    </summary>
    
      <category term="排序算法" scheme="http://www.chenqiangyi.cn/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://www.chenqiangyi.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB常用语句</title>
    <link href="http://www.chenqiangyi.cn/2016/10/20/MongoDB%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/"/>
    <id>http://www.chenqiangyi.cn/2016/10/20/MongoDB常用语句/</id>
    <published>2016-10-20T15:53:42.000Z</published>
    <updated>2017-06-17T17:35:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>记录一下MongoDB常用语句，顺带与SQL做个简单的对比。</p>
</blockquote>
<h1 id="查询-find"><a href="#查询-find" class="headerlink" title="查询(find)"></a>查询(find)</h1><h2 id="查询所有结果"><a href="#查询所有结果" class="headerlink" title="查询所有结果"></a>查询所有结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from article</div><div class="line"></div><div class="line">db.article.find()</div></pre></td></tr></table></figure>
<h2 id="指定返回哪些键"><a href="#指定返回哪些键" class="headerlink" title="指定返回哪些键"></a>指定返回哪些键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select title, author from article</div><div class="line"></div><div class="line">db.article.find(&#123;&#125;, &#123;&quot;title&quot;: 1, &quot;author&quot;: 1&#125;)</div></pre></td></tr></table></figure>
<h2 id="where-条件"><a href="#where-条件" class="headerlink" title="where 条件"></a>where 条件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from article where title = &quot;mongodb&quot;</div><div class="line"></div><div class="line">db.article.find(&#123;&quot;title&quot;: &quot;mongodb&quot;&#125;)</div></pre></td></tr></table></figure>
<h2 id="and-条件"><a href="#and-条件" class="headerlink" title="and 条件"></a>and 条件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from article where title = &quot;mongodb&quot; and author = &quot;god&quot;</div><div class="line"></div><div class="line">db.article.find(&#123;&quot;title&quot;: &quot;mongodb&quot;, &quot;author&quot;: &quot;god&quot;&#125;)</div></pre></td></tr></table></figure>
<h2 id="or-条件"><a href="#or-条件" class="headerlink" title="or 条件"></a>or 条件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from article where title = &quot;mongodb&quot; or author = &quot;god&quot;</div><div class="line"></div><div class="line">db.article.find(&#123;&quot;&amp;or&quot;: [&#123;&quot;title&quot;: &quot;mongodb&quot;&#125;, &#123;&quot;author&quot;: &quot;god&quot;&#125;]&#125;)</div></pre></td></tr></table></figure>
<h2 id="比较条件"><a href="#比较条件" class="headerlink" title="比较条件"></a>比较条件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from article where read &gt;= 100;</div><div class="line"></div><div class="line">db.article.find(&#123;&quot;read&quot;: &#123;&quot;$gt&quot;: 100&#125;&#125;)</div></pre></td></tr></table></figure>
<p><code>$gt</code>(&gt;)、<code>$gte</code>(&gt;=)、<code>$lt</code>(&lt;)、<code>$lte</code>(&lt;=)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from article where read &gt;= 100 and read &lt;=200</div><div class="line"></div><div class="line">db.article.find(&#123;&quot;read&quot;: &#123;&quot;$gte&quot;: 100, &quot;$lte&quot;: 200&#125;&#125;)</div></pre></td></tr></table></figure>
<h2 id="in-条件"><a href="#in-条件" class="headerlink" title="in 条件"></a>in 条件</h2> <figure class="highlight plain"><figcaption><span>* from article where author in ("a", "b", "c")</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">db.article.find(&#123;&quot;author&quot;: &#123;&quot;$in&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#125;&#125;)</div></pre></td></tr></table></figure>
<h2 id="like"><a href="#like" class="headerlink" title="like"></a>like</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from article where title like &quot;%mongodb%&quot;</div><div class="line"></div><div class="line">db.article.find(&#123;&quot;title&quot;: /mongodb/&#125;)</div></pre></td></tr></table></figure>
<h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select count(*) from article</div><div class="line"></div><div class="line">db.article.count()</div></pre></td></tr></table></figure>
<h2 id="不等于"><a href="#不等于" class="headerlink" title="不等于"></a>不等于</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from article where author != &quot;a&quot;</div><div class="line"></div><div class="line">db.article.find(&#123;&quot;author&quot;: &#123;&quot;$ne&quot;: &quot;a&quot;&#125;&#125;)</div></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="升序："><a href="#升序：" class="headerlink" title="升序："></a>升序：</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from article where type = &quot;mongodb&quot; order by read desc</div><div class="line"></div><div class="line">db.article.find(&#123;&quot;type&quot;: &quot;mongodb&quot;&#125;).sort(&#123;&quot;read&quot;: -1&#125;)</div></pre></td></tr></table></figure>
<h3 id="降序："><a href="#降序：" class="headerlink" title="降序："></a>降序：</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from article where type = &quot;mongodb&quot; order by read asc</div><div class="line"></div><div class="line">db.article.find(&#123;&quot;type&quot;: &quot;mongodb&quot;&#125;).sort(&#123;&quot;read&quot;: 1&#125;)</div></pre></td></tr></table></figure>
<p> <code>findOne()</code>: 除了只返回一个查询结果外，使用方法与<code>find()</code>一样</p>
<h1 id="创建-insert"><a href="#创建-insert" class="headerlink" title="创建(insert)"></a>创建(insert)</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">insert into article(title, author, content) values(&quot;mongodb&quot;, &quot;tg&quot;, &quot;haha&quot;)</div><div class="line"></div><div class="line">db.article.insert(&#123;&quot;title&quot;: &quot;mongodb&quot;, &quot;author&quot;: &quot;tg&quot;, &quot;content&quot;: &quot;haha&quot;&#125;)</div></pre></td></tr></table></figure>
<h1 id="更新-update"><a href="#更新-update" class="headerlink" title="更新(update)"></a>更新(update)</h1><h2 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h2><p> 语法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.clooection.update(query, update[, options])</div></pre></td></tr></table></figure>
<ul>
<li><code>query</code>: 必选，查询条件，类似find中的查询条件</li>
<li><code>update</code>: 必选，update的对象和一些更新的操作符(如$,$inc…)等</li>
<li><code>options</code>: 可选，一些更新配置的对象。</li>
<li><code>upsert</code>: 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>
<li><code>multi</code>: 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li>
<li><p><code>writeConcern</code>: 可选，抛出异常的级别。</p>
<p>简单更新:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">update article set title = &quot;mongodb&quot; where read &gt; 100</div><div class="line"></div><div class="line">db.article.update(&#123;&quot;read&quot;: &#123;&quot;$gt&quot;: 100&#125;&#125;, &#123;&quot;$set&quot;: &#123;&quot;title&quot;: &quot;mongodb&quot;&#125;&#125;)</div></pre></td></tr></table></figure>
<h2 id="save"><a href="#save" class="headerlink" title="save()"></a>save()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.article.save(&#123;_id: 123, title: &quot;mongodb&quot;&#125;)</div></pre></td></tr></table></figure>
<p>执行上面的语句，如果集合中已经存在一个_id为123的文档，则更新对应字段;否则插入。</p>
<p>注：如果更新对象不存在_id，系统会自动生成并作为新的文档插入。</p>
<h2 id="更新操作符"><a href="#更新操作符" class="headerlink" title="更新操作符"></a>更新操作符</h2><p>MongoDB提供一些强大的更新操作符。</p>
<p>更新特定字段（<code>$set</code>）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">update game set count = 10000 where _id = 123</div><div class="line"></div><div class="line">db.game.update(&#123;&quot;_id&quot;: 123&#125;, &#123;&quot;$set&quot;: &#123;&quot;count&quot;: 10000&#125;&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>删除特定字段(<code>$unset</code>):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.game.update(&#123;&quot;_id&quot;: 123&#125;, &#123;&quot;$unset&quot;: &#123;&quot;author&quot;: 1&#125;&#125;)</div></pre></td></tr></table></figure>
<p>注：<code>$unset</code>指定字段的值只需是任意合法值即可。</p>
<p>（未完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录一下MongoDB常用语句，顺带与SQL做个简单的对比。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;查询-find&quot;&gt;&lt;a href=&quot;#查询-find&quot; class=&quot;headerlink&quot; title=&quot;查询(find)&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.chenqiangyi.cn/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.chenqiangyi.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>数组去重总结</title>
    <link href="http://www.chenqiangyi.cn/2016/09/10/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%80%BB%E7%BB%93/"/>
    <id>http://www.chenqiangyi.cn/2016/09/10/数组去重总结/</id>
    <published>2016-09-10T02:35:23.000Z</published>
    <updated>2017-06-24T03:38:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>数组去重是一个常见的需求，在面试中也经常被问到，曾经被问到写出几种方法来完成数组去重，当时没有做出来，今天就来总一下。主要是理清思路，以下方法网上都能找得到，这里简单做一下总结。</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>遍历数组，比较，比较到相同的就删除后面的</li>
<li>遍历数组，比较，比较相同的，跳过前面重复的，不相同的放入新数组</li>
<li>任取一个数组放入新数组，遍历剩下的数组元素任取一个，与新数组元素一一比较，如有不同的，放入新数组。</li>
<li>遍历数组，取一个元素，作为对象的属性，判断属性是否存在</li>
<li>利用ES6提供的 new Set(arr),可直接去重</li>
</ul>
<h1 id="代码示范"><a href="#代码示范" class="headerlink" title="代码示范"></a>代码示范</h1><h2 id="删除后面重复的"><a href="#删除后面重复的" class="headerlink" title="删除后面重复的"></a>删除后面重复的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">    var a1 = (new Date).getTime();</div><div class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">        for (var j = i + 1; j &lt; arr.length; j++) &#123;</div><div class="line">            if (arr[i] === arr[j]) &#123;</div><div class="line">                arr.splice(j, 1);</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.info((new Date).getTime() - a1);</div><div class="line">    return arr.sort((a, b) =&gt; &#123;return a - b&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="相同则跳出循环"><a href="#相同则跳出循环" class="headerlink" title="相同则跳出循环"></a>相同则跳出循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">    var a1 = (new Date()).getTime();</div><div class="line">    var b = [], n = arr.length, i, j;</div><div class="line">    for (i = 0; i &lt; n; i++) &#123;</div><div class="line">        for (j = i + 1; j &lt; n; j++) &#123;</div><div class="line">            if (arr[i] === arr[j]) &#123;</div><div class="line">                j = false;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (j) &#123;</div><div class="line">            b.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.info((new Date()).getTime() - a1);</div><div class="line">    return b.sort((a, b) =&gt; &#123;return a - b&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="不同则放入新数组"><a href="#不同则放入新数组" class="headerlink" title="不同则放入新数组"></a>不同则放入新数组</h2><p>这里j循环虽然继续了，但是i值已经变了。就等于是一个新的i循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">    var a1 = ((new Date()).getTime());</div><div class="line">    var b = [], n =arr.length, i, j;</div><div class="line">    for (var i = 0; i &lt; n; i++) &#123;</div><div class="line">        for (j = i + 1; j &lt; n; j++) &#123;</div><div class="line">            if (arr[i] === arr[j]) &#123;</div><div class="line">                j = ++i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        b.push(arr[i]);</div><div class="line">    &#125;</div><div class="line">    console.info((new Date()).getTime() - a1);</div><div class="line">    return b.sort((a, b) =&gt; &#123;return a -b&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="保证新数组中的数都是唯一的"><a href="#保证新数组中的数都是唯一的" class="headerlink" title="保证新数组中的数都是唯一的"></a>保证新数组中的数都是唯一的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">    var a1 = ((new Date()).getTime());</div><div class="line">    var m = [], f;</div><div class="line">    for (var i = 0; i&lt; arr.length; i++) &#123;</div><div class="line">        f = true;</div><div class="line">        for (var j = 0; j &lt; m.length; j++) &#123;</div><div class="line">            if (arr[i] === arr[j]) &#123;</div><div class="line">                f = false;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (f) &#123;</div><div class="line">            m.push(arr[i])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.info((new Date()).getTime() - a1);</div><div class="line">    return m.sort((a, b) =&gt; &#123; return a - b&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="用对象属性"><a href="#用对象属性" class="headerlink" title="用对象属性"></a>用对象属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function unique(arr) &#123;</div><div class="line">    var a1 = (new Date()).getTime();</div><div class="line">    var m, n = [], o = &#123;&#125;;</div><div class="line">    for (var i = 0; (m = arr[i]) !== undefined; i++) &#123;</div><div class="line">        if (!o[m]) &#123;</div><div class="line">            n.push(m);</div><div class="line">            o[m] = true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.info((new Date()).getTime() - a1);</div><div class="line">    return n.sort((a, b) =&gt; &#123;return a - b&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ES6新特性-new-Set"><a href="#ES6新特性-new-Set" class="headerlink" title="ES6新特性 new Set()"></a>ES6新特性 new Set()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [1, 3, 5, 2, 3, 1, 4, 2, 3];</div><div class="line">var a = new Set(arr);</div><div class="line">console.log([...a].sort((a, b) =&gt; &#123;return a - b&#125;));  // [1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;数组去重是一个常见的需求，在面试中也经常被问到，曾经被问到写出几种方法来完成数组去重，当时没有做出来，今天就来总一下。主要是理清思路，以下方法网上都能找得到，这里简单做一下总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="数组去重" scheme="http://www.chenqiangyi.cn/categories/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    
    
      <category term="数组去重" scheme="http://www.chenqiangyi.cn/tags/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    
      <category term="Array" scheme="http://www.chenqiangyi.cn/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>ES6新特性(2)——深刻而易懂的ES6解构教程</title>
    <link href="http://www.chenqiangyi.cn/2016/08/09/ES6%E6%96%B0%E7%89%B9%E6%80%A7(2)%E2%80%94%E2%80%94%E6%B7%B1%E5%88%BB%E8%80%8C%E6%98%93%E6%87%82%E7%9A%84ES6%E8%A7%A3%E6%9E%84%E6%95%99%E7%A8%8B/"/>
    <id>http://www.chenqiangyi.cn/2016/08/09/ES6新特性(2)——深刻而易懂的ES6解构教程/</id>
    <published>2016-08-09T10:49:50.000Z</published>
    <updated>2017-06-14T13:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>解构是ES6的新特性，用于从JavaScript对象和数组中提取数据，语法上比ES5所提供的更加简洁、紧凑、清晰。它不仅能减少你的代码量，还能从根本上改变你的编码方式。用的越多，你就会发现越多塑造数据和函数的方式，这些实现方式在过去几乎是不可能的。本文将深入探讨解构赋值，为你介绍该新特性中你所需要知悉的一切。</p>
</blockquote>
<h1 id="什么是解构？"><a href="#什么是解构？" class="headerlink" title="什么是解构？"></a>什么是解构？</h1><p>解构与构造数据截然相反。 例如，它不是构造一个新的对象或数组，而是逐个拆分现有的对象或数组，来提取你所需要的数据</p>
<p>ES6使用了一种新模式来匹配你想要提取的数值, 解构赋值就是采用了这种模式。 该模式会映射出你正在解构的数据结构，只有那些与该模式相匹配的数据，才会被提取出来。</p>
<p>被解构的数据项位于赋值运算符 = 的右侧，可以是任何数组和对象的组合，允许随意嵌套。用于给这些数据赋值的变量个数不限。</p>
<h1 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h1><p>数组解构 使用一个数组作为一个数据项，你可以根据 数组模式 （用于从数组中匹配你所需要的数值）从这个数组里面提取数值给一个或者多个变量赋值。</p>
<p>数组模式 是根据数值的位置来鉴别哪些值是你想要提取的。它必须能精确地映射数组的结构，来要让数组模式中的每个变量都被赋上 被解构数组中 位置与之相对应的值。</p>
<p>举几个例子来帮助我们理解吧：</p>
<h2 id="数组模式示例"><a href="#数组模式示例" class="headerlink" title="数组模式示例"></a>数组模式示例</h2><p>把数组中所有的数值赋给一个个单独的变量&lt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//设置数组</div><div class="line">const avengers = [&apos;Tony Stark&apos;, &apos;Steve Rogers&apos;, &apos;Natasha Romanoff&apos;];</div><div class="line">//b把数组结构赋值给变量。数组模式位于赋值运算符&apos;=&apos; 的左侧，被解构的数组在其右侧。</div><div class="line">const [ironMan, cap, blackWidow] = avengers;</div><div class="line">// ironMan = &apos;Tony Stark&apos;</div><div class="line">// cap = &apos;Steve Rogers&apos;</div><div class="line">//blackWidow = &apos;Natasha Romanoff&apos;</div><div class="line">//输出 ironMan:</div><div class="line">ironMan;</div><div class="line">&quot;Tony Stark&quot;</div></pre></td></tr></table></figure>
<p>提取除第一个外的所有数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const avengers = [&apos;Tony Stark&apos;, &apos;Steve rogers&apos;, &apos;Natasha Romanoff&apos;];</div><div class="line">const [, cap, blackWidow] = avengers;</div><div class="line">  //  ironMan = Error: undefined</div><div class="line">  //  cap = &apos;Steve Rogers&apos;</div><div class="line">  //  blackWidow = &apos;Natasha Romanoff</div><div class="line">  //  输出 cap: &lt;span style=&quot;font-size:13.2px;line-height:1.5;&quot;&gt;cap;&lt;/span&gt;</div></pre></td></tr></table></figure>
<p>提取除第二个外的所有数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const avengers = [&apos;Tony Stark&apos;, &apos;Steve rogers&apos;, &apos;Natasha Romanoff&apos;];</div><div class="line">const [ironMan, , blackWidow] = avengers;</div><div class="line">  //  ironMan = &apos;Tony Stark&apos;</div><div class="line">  //  cap = Error: undefined</div><div class="line">  //  blackWidow = &apos;Natasha Romanoff</div><div class="line">  //  输出 blackWidow:</div><div class="line">   blackWidow;</div></pre></td></tr></table></figure>
<p>提取除最后一个外的所有数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const avengers = [&apos;Tony Stark&apos;, &apos;Steve rogers&apos;, &apos;Natasha Romanoff&apos;];</div><div class="line">//  ironMan vs cap</div><div class="line">const [ironMan, cap] = avengers;</div><div class="line">  //  ironMan = &apos;Tony Stark&apos;</div><div class="line">  //  cap = &apos;Steve Rogers&apos;</div><div class="line">  //  blackWidow = Error: undefined</div><div class="line">  //  输出 b</div></pre></td></tr></table></figure>
<h2 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h2><p>这种匹配模式也支持嵌套数组，只要保证赋值运算符 = 左侧的数组模式与右侧的数组结构相匹配即可。再次说明一下，= 左边的变量都会被赋上 = 右侧数组中位置与之相对应的值。 无论你怎么深层次地嵌套，仍可以对它们进行解构。</p>
<h2 id="解构嵌套的数组"><a href="#解构嵌套的数组" class="headerlink" title="解构嵌套的数组"></a>解构嵌套的数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const avengers = [</div><div class="line">                   &apos;Natasha Romanoff&apos;,</div><div class="line">                   [&apos;Tony Stark&apos;, &apos;James Rhodes&apos;],</div><div class="line">                   [&apos;Steve Rogers&apos;, &apos;Sam Wilson&apos;] </div><div class="line">                 ];</div><div class="line">const [blackWidow, [ironMan, warMachine], [cap, falcon]] = avengers;</div><div class="line">//  blackWidow = &apos;Natasha Romanoff&apos;</div><div class="line">//  ironMan = &apos;Tony Stark&apos;</div><div class="line">//  varMachine = &apos;James Rhodes&apos;</div><div class="line">// cap = &apos;Steve Rogers&apos;</div><div class="line">//  falcon = &apos;sam Wilson&apos;</div><div class="line">//  Out warMachine:</div><div class="line">warMachine;</div></pre></td></tr></table></figure>
<p>从深层嵌套的数组中提取一个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const avengers = [</div><div class="line">                   &apos;Natasha Romanoff&apos;,</div><div class="line">                   [&apos;Tony Stark&apos;, &apos;James Rhodes&apos;],</div><div class="line">                   [&apos;Steve Rogers&apos;, &apos;Sam Wilson&apos;] </div><div class="line">                 ];</div><div class="line">const [ , //跳过 &apos;Natasha Romanoff&apos; [ironMan, warMachine], [cap, falcon]] = avengers;</div><div class="line">//  blackWidow = &apos;Natasha Romanoff&apos;</div><div class="line">//  ironMan = &apos;Tony Stark&apos;</div><div class="line">//  varMachine = &apos;James Rhodes&apos;</div><div class="line">// cap = &apos;Steve Rogers&apos;</div><div class="line">//  falcon = &apos;sam Wilson&apos;</div><div class="line">//  Out warMachine:</div><div class="line">warMachine;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;解构是ES6的新特性，用于从JavaScript对象和数组中提取数据，语法上比ES5所提供的更加简洁、紧凑、清晰。它不仅能减少你的代码量，还能从根本上改变你的编码方式。用的越多，你就会发现越多塑造数据和函数的方式，这些实现方式在过去几乎是不可能的。
    
    </summary>
    
      <category term="ES6" scheme="http://www.chenqiangyi.cn/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://www.chenqiangyi.cn/tags/ES6/"/>
    
      <category term="JavaScript" scheme="http://www.chenqiangyi.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6-手册</title>
    <link href="http://www.chenqiangyi.cn/2016/08/04/ES6-%E6%89%8B%E5%86%8C/"/>
    <id>http://www.chenqiangyi.cn/2016/08/04/ES6-手册/</id>
    <published>2016-08-04T01:05:52.000Z</published>
    <updated>2017-06-14T11:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇手册包含了 ES2015(ES6) 的使用小技巧、最佳实践以及可以给你每天的工作参考的代码片段。</p>
<h1 id="var-和-let-const-的比较"><a href="#var-和-let-const-的比较" class="headerlink" title="var 和 let/const 的比较"></a>var 和 let/const 的比较</h1><p>除了 var ，我们现在还可以使用两个新的标示符来定义一个变量 —— let 和 const。和 var 不一样的是，let 和 const 不存在变量提升。</p>
<p>使用 var 的栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> snack = <span class="string">'Meow Mix'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFood</span>(<span class="params">food</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(food) &#123;</div><div class="line">    <span class="keyword">var</span> snack = <span class="string">'Friskies'</span>;</div><div class="line">    <span class="keyword">return</span> snack;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> snack;</div><div class="line">&#125;</div><div class="line">getFood(<span class="literal">false</span>);    <span class="comment">//  undefined</span></div></pre></td></tr></table></figure>
<p>当我们用 let 代替 var 的时候，观察会发生什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> snack = <span class="string">'Meow Mix'</span> ;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFood</span>(<span class="params">food</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(food) &#123;</div><div class="line">    <span class="keyword">let</span> snack = <span class="string">'Friskies'</span>;</div><div class="line">    <span class="keyword">return</span> snack;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> snack;</div><div class="line">&#125; </div><div class="line">getFood(<span class="literal">false</span>);     <span class="comment">//  'Meow Mix'</span></div></pre></td></tr></table></figure>
<p>当我们重构使用 var 的老代码的时候应该注意上面的变化。盲目地使用 let 替换 var 可能会出现出乎意料的情况。</p>
<p>注意： let 和 const 是块级作用域，因此在变量未被定义之前使用它会产生一个 ReferenceError。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(x);       <span class="comment">//    Uncaught ReferenceError: x is not defined</span></div><div class="line"><span class="keyword">let</span> x = <span class="string">'hi'</span>;</div></pre></td></tr></table></figure>
<p>最佳实践： 在遗留代码中放弃使用 var 声明意味着需要很小心地重构；在新的项目代码中，使用 let 声明一个可以改变的变量，用 const 声明一个不能被重新赋值的变量。</p>
<h1 id="用块级作用域代替"><a href="#用块级作用域代替" class="headerlink" title="用块级作用域代替"></a>用块级作用域代替</h1><p>函数立即执行表达式 的通常用途是创造一个内部的作用域，在 ES6 中，我们能够创造一个块级作用域而不仅限于函数作用域：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> food = <span class="string">'Meow Mix'</span>;</div><div class="line">&#125;)();</div><div class="line"><span class="built_in">console</span>.log(food);      <span class="comment">//ReferenceError: food is not defined</span></div></pre></td></tr></table></figure>
<h2 id="使用-ES6-的块级作用域："><a href="#使用-ES6-的块级作用域：" class="headerlink" title="使用 ES6 的块级作用域："></a>使用 ES6 的块级作用域：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> food = <span class="string">'Meow Mix'</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(food);     <span class="comment">// ReferenceError: food is not defined</span></div></pre></td></tr></table></figure>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>我们经常需要给回调函数维护一个词法作用域的上下文 this。</p>
<p>看看这个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">character</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + character;</div><div class="line">&#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//    Cannot read property 'name' of undefined</span></div></pre></td></tr></table></figure>
<p>一个常用的解决办法是把 this 存在一个变量中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;      <span class="comment">// Store the context of this</span></div><div class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">character</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + character;</div><div class="line">&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们也可以传递一个合适的 this 上下文：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">character</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + character;</div><div class="line">&#125;,<span class="keyword">this</span>);</div><div class="line">&#125;;</div><div class="line">(arr) &#123;</div><div class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">character</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + character;</div><div class="line">&#125;,<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们还可以绑定上下文：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">character</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + character;</div><div class="line">&#125;.bind(<span class="keyword">this</span>));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用 箭头函数，this 将不会受到影响，并且我们可以重写上面的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype.prefixName = funciton (arr) &#123;</div><div class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="params">character</span> =&gt;</span> <span class="keyword">this</span>.name + character)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最佳实践：当你需要维护一个 this 上下文的时候使用 箭头函数。</p>
<p>在我们写一个函数的时候，箭头函数更加简洁并且可以很简单地返回一个值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Squares = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * X&#125;);  <span class="comment">//ReferenceError: arr is not defined</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>arr = [1, 2, 3, 4, 5];</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const squares = arr.map(x =&gt; x * x);</div><div class="line">//Arrow Function for terser implementation</div></pre></td></tr></table></figure>
<p>最佳实践：尽可能使用箭头函数代替原来的写法。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>在 ES6 中，标准库升级了很多，在这些变化中有许多新的对于字符串的函数，比如 .includes() 和 .repeat()。</p>
<h2 id="includes"><a href="#includes" class="headerlink" title=".includes()"></a>.includes()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">'food'</span>;</div><div class="line"><span class="keyword">var</span> substring = <span class="string">'foo'</span>;</div><div class="line"><span class="built_in">console</span>.log(string.indexOf(substring) &gt; <span class="number">-1</span>);     <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>之前我们使用 indexOf() 函数的返回值是否 -1 来判断字符串是否包含某些字符串，现在我们更简单地使用 .includes() 来返回一个布尔值来判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> string = <span class="string">'food'</span>;</div><div class="line"><span class="keyword">var</span> substring = <span class="string">'foo'</span>;</div><div class="line"><span class="built_in">console</span>.log(string.includes(substring));     <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">string, count</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> strings = [];</div><div class="line">  <span class="keyword">while</span>(strings.length &gt; count) &#123;</div><div class="line">    strings.push(string);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> strings.join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ES6 中，可以更简便地实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// String.repeat(numberOfRepetitions)</span></div><div class="line"><span class="string">'meow'</span>.repeat(<span class="number">3</span>)      <span class="comment">//"meowmeowmeow"</span></div></pre></td></tr></table></figure>
<h1 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h1><p>使用 模版字符串 我们就可以不用对某些特殊自符进行转义处理了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"This string contains \"double quotes\"  which are escaped."</span></div><div class="line">alert(text);</div><div class="line"><span class="comment">//This string contains "double quotes" which are escaped.</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> text = <span class="string">`This string contains "double quotes"  which are escaped.`</span>;</div></pre></td></tr></table></figure>
<p>模版字符串 还支持插入，可以把变量值和字符串连接起来.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'Tiger'</span>;</div><div class="line"><span class="keyword">var</span> age = <span class="number">13</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'My cat is named'</span> + name + <span class="string">'and is'</span> +age + <span class="string">'years old.'</span>);</div><div class="line"><span class="comment">//My cat is namedTigerand is13years old.</span></div></pre></td></tr></table></figure>
<p>更简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> name = <span class="string">'Tiger'</span>;</div><div class="line"><span class="keyword">const</span> age = <span class="number">13</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`My cat is named <span class="subst">$&#123;name&#125;</span> and is <span class="subst">$&#123;age&#125;</span> years old.`</span>);</div></pre></td></tr></table></figure>
<p>在 ES5 中，需要换行时，需要这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = (</div><div class="line">  <span class="string">'cat\n'</span> +</div><div class="line">  <span class="string">'dog\n'</span> +</div><div class="line">  <span class="string">'nickelodeon'</span></div><div class="line">);</div><div class="line"><span class="built_in">console</span>.log(text);</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line">cat</div><div class="line">dog</div><div class="line">nickelodeon</div></pre></td></tr></table></figure>
<p>或者这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = [</div><div class="line">  <span class="string">'cat'</span></div><div class="line">  <span class="string">'dog'</span></div><div class="line">  <span class="string">'nickelodeon'</span></div><div class="line">].join(<span class="string">'\n'</span>);</div></pre></td></tr></table></figure>
<p>模版字符串 可以支持换行并且不需要额外的处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> text = ( <span class="string">`cat</span></div><div class="line">dog</div><div class="line">nicklodeon`</div></pre></td></tr></table></figure>
<p>模版字符串 还支持表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="keyword">let</span> text = <span class="string">`The time and date is</span></div><div class="line"><span class="subst">$&#123;today.toLocaleString()&#125;</span>`;</div></pre></td></tr></table></figure>
<h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><p>结构可以让我们用一个更简便的语法从一个数组或者对象（即使是深层的）中分离出来值，并存储他们。</p>
<h2 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">var</span> a = arr[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> b = arr[<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> c = arr[<span class="number">2</span>];</div><div class="line"><span class="keyword">var</span> d = arr[<span class="number">3</span>];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let [a, b, c, d] = [1, 2, 3, 4];</div><div class="line">console.log(a);    // 1</div><div class="line">console.log(b);    //  2</div></pre></td></tr></table></figure>
<h2 id="结构对象"><a href="#结构对象" class="headerlink" title="结构对象"></a>结构对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> luke = &#123; <span class="attr">occupation</span>: <span class="string">'jedi'</span>, <span class="attr">father</span>: <span class="string">'anakin'</span> &#125;;</div><div class="line"><span class="keyword">var</span> occupation = luke.occupation;    <span class="comment">//  'jedi'</span></div><div class="line"><span class="keyword">var</span> father = luke.father;    <span class="comment">//  'anakin'</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> luke = &#123; <span class="attr">occupation</span>: <span class="string">'jedi'</span>, <span class="attr">father</span>: <span class="string">'anakin'</span> &#125;;</div><div class="line"><span class="keyword">let</span> &#123;occupation, father&#125; = luke;</div><div class="line"><span class="built_in">console</span>.log(occupation);    <span class="comment">//  'jedu'</span></div><div class="line"><span class="built_in">console</span>.log(father);    <span class="comment">//  'anakin'</span></div></pre></td></tr></table></figure>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>在 ES6 之前，我们使用 Browserify 这样的库来创建客户端的模块化，在 node.js 中使用 require。</p>
<p>在 ES6 中，我们可以直接使用所有类型的模块化（AMD 和 CommonJS）。</p>
<p>使用 CommonJS 的出口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="number">1</span>;</div><div class="line"><span class="built_in">module</span>.exports = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>&#125;;</div><div class="line"><span class="built_in">module</span>.export = [<span class="string">'foo'</span>, <span class="string">'bar'</span>];</div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;;</div></pre></td></tr></table></figure>
<h2 id="使用-ES6-的出口"><a href="#使用-ES6-的出口" class="headerlink" title="使用 ES6 的出口"></a>使用 ES6 的出口</h2><p>在 ES6 中我们可以暴漏多个值，使用 Exports：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export let name = &apos;David&apos;;</div><div class="line">export let age = 25;</div></pre></td></tr></table></figure>
<h2 id="或者暴露一个对象列表："><a href="#或者暴露一个对象列表：" class="headerlink" title="或者暴露一个对象列表："></a>或者暴露一个对象列表：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumTwo</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumThree</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b + c;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> &#123; sumTwo, sumThree &#125;;</div></pre></td></tr></table></figure>
<p>我们还可以暴露函数、对象和其他的值，通过简单地使用 export 这个关键字：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sumTwo</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sumThree</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b + c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我们还可以绑定一个默认的输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumTwo</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumThree</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b + c;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> api = &#123;</div><div class="line">  sumTwo,</div><div class="line">  sumThree</div><div class="line">&#125;;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> api;</div></pre></td></tr></table></figure>
<p>最佳实践：</p>
<p>总是在模块的最后面使用 export default 方法，这可以让暴露的东西更加清晰并且可以节省时间去找出暴漏出来值的名字。尤其如此，在 CommonJS 中通常的实践就是暴露一个简单的值或者对象。坚持这种模式，可以让我们的代码更加可读，并且在 ES6 和 CommonJS 模块之间更好地兼容。</p>
<h1 id="ES6-中的导入"><a href="#ES6-中的导入" class="headerlink" title="ES6 中的导入"></a>ES6 中的导入</h1><p>在 ES6 中同样提供了多样的导入方式，我们可以这么导入一个整个文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'underscore'</span>;</div></pre></td></tr></table></figure>
<p>需要着重注意的一点是简单的导入整个文件会在那个文件的顶部执行所有的代码</p>
<p>和 Python 中类似，我们可以命名导入的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; sumTwo, sumThree &#125; <span class="keyword">from</span> <span class="string">'math/addition'</span>;</div></pre></td></tr></table></figure>
<p>我们还可以重命名导入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  sumTwo <span class="keyword">as</span> addTwoNumbers,</div><div class="line">  sumThree <span class="keyword">as</span> sumThreeNumbers</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'math/addition'</span>;</div></pre></td></tr></table></figure>
<p>另外，我们可以导入所有的东西（整体加载）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * asutil <span class="keyword">from</span> <span class="string">'math/addition'</span>;</div></pre></td></tr></table></figure>
<p>最后，我们可以从一个模块中导入一个值的列表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> additionUtil <span class="keyword">from</span> <span class="string">'math/addition'</span>;</div><div class="line"><span class="keyword">const</span> &#123; sumTwo, sumThree &#125; = additionUtil;</div></pre></td></tr></table></figure>
<p>可以像这样导入默认绑定的输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'math/addition'</span>;</div><div class="line"><span class="comment">//  same as :import &#123;default as api &#125; from 'math/addition';</span></div></pre></td></tr></table></figure>
<p>虽然最好保持出口的简单，但如果需要的话我们有时可以混合默认的进口和混合进口。当我们这样出口的时候：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// foos.js</span></div><div class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> <span class="keyword">default</span>, foo1, foo2 &#125;;</div></pre></td></tr></table></figure>
<p>我们可以这样导入它们：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> foo, &#123; foo1, foo2 &#125; <span class="keyword">from</span> <span class="string">'foos'</span>;</div></pre></td></tr></table></figure>
<p>当我们用 commonjs 的语法导入一个模块的出口时（比如 React），我们可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">const</span> &#123; Component, PropTypes &#125; = React;</div></pre></td></tr></table></figure>
<p>还有更精简的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div></pre></td></tr></table></figure>
<p>注意：导出的值是动态引用的，而不是拷贝。因此，在一个模块中改变一个变量的绑定将影响输出模块中的值。应该避免改变这些导出值的公共接口。（原文这里我觉得有误）</p>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>在 ES5 中，在函数中我们需要各种操作去处理 默认参数、不定参数 和 重命名参数 等需求，在 ES6 中我们可以使用更简洁的语法完成这些需求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwoNumbers</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  x = x || <span class="number">0</span>;</div><div class="line">  y = y || <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line">addTwoNumbers(<span class="number">3</span>);    <span class="comment">// 3</span></div><div class="line">addTwoNumbers(<span class="number">3</span>,<span class="number">2</span>);  <span class="comment">// 5</span></div><div class="line">addTwoNumbers();    <span class="comment">//0</span></div></pre></td></tr></table></figure>
<p>ES6 中，函数的参数可以支持设置默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwoNumbers</span>(<span class="params"> x = <span class="number">0</span>, y = <span class="number">0</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line">addTwoNumbers(<span class="number">2</span>, <span class="number">4</span>);    <span class="comment">//6</span></div><div class="line">addTwoNumbers(<span class="number">2</span>);    <span class="comment">//2</span></div><div class="line">addTwoNumbers();    <span class="comment">//0</span></div></pre></td></tr></table></figure>
<h1 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h1><p>在 ES5 中，我们需要这么处理不定参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArguments</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&amp;lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 rest ，我们就可以处理不确定数目的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArguments</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> args) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h1><p>在 ES5 中是使用配置对象的模式来处理命名参数，jQuery 中的使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeCanvas</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> height = options.height || <span class="number">600</span>;</div><div class="line">  <span class="keyword">var</span> width = options.width || <span class="number">400</span>;</div><div class="line">  <span class="keyword">var</span> lineStroke = options.lineStroke || <span class="string">'black'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以利用解构的一个函数的形参实现相同的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeCanvas</span>(<span class="params"></span></span></div><div class="line">  &#123; height = <span class="number">600</span>, width = <span class="number">400</span>, lineStroke = <span class="string">'black'</span>&#125;) &#123;</div><div class="line">     <span class="comment">// Use variables height, width, lineStroke here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们想使整个值可选择，我们可以结构将一个空的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeCanvas</span> (<span class="params"></span></span></div><div class="line"> &#123; height = <span class="number">600</span>, width = <span class="number">400</span>, lineStroke = <span class="string">'black'</span> &#125; = &#123;&#125;) &#123;</div><div class="line">    <span class="comment">//  ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="展开操作"><a href="#展开操作" class="headerlink" title="展开操作"></a>展开操作</h1><p>在 ES5 中，我们可以 apply Math.max 方法来获得一个数组中的最大值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">-1</span>, <span class="number">100</span>, <span class="number">9001</span>, <span class="number">-32</span>]);    <span class="comment">//  9001</span></div></pre></td></tr></table></figure>
<p>在 ES6 中，我们可以通过展开操作把一个数组的值作为参数传递给一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.max(...[<span class="number">-1</span>, <span class="number">100</span>, <span class="number">9001</span>, <span class="number">-32</span>]);</div></pre></td></tr></table></figure>
<p>我们可以更简洁地使用这个语法来合并数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> cities = [ <span class="string">'San Francisco'</span>, <span class="string">'Los Angeles'</span>];</div><div class="line"><span class="keyword">let</span> places = [ <span class="string">'Miami'</span>, ...cities, <span class="string">'Chicago'</span>];   <span class="comment">//['Miami', 'San Francisco', 'Los Angeles', 'Chicago' ]</span></div></pre></td></tr></table></figure>
<h1 id="类-Classes"><a href="#类-Classes" class="headerlink" title="类 Classes"></a>类 Classes</h1><p>在 ES6 之前，我们通过构造函数来创造一个类，并且通过原型来扩展属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, gender</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.gender = gender;</div><div class="line">&#125;</div><div class="line">Person.prototype.incrementAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age +=<span class="number">1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后可以这样继承类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Personal</span>(<span class="params">name, age, gender, occupation,hobby</span>)</span></div><div class="line">&#123;</div><div class="line">  Person.call(<span class="keyword">this</span>, name, age, gender);</div><div class="line">  <span class="keyword">this</span>.occupation = occupation;</div><div class="line">  <span class="keyword">this</span>.hobby = hobby;</div><div class="line">&#125;</div><div class="line">Personal.prototype = <span class="built_in">Object</span>.create(Person.prototype);</div><div class="line">Person.prototype.constructor = Personal;</div><div class="line">Personal.prototype.incrementAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  Person.prototype.incrementAge.call(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">this</span>.age += <span class="number">20</span>;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;&lt;<span class="regexp">/pre&gt;</span></div></pre></td></tr></table></figure>
<p>在 ES6 中，提供了更多的语法糖，可以直接创造一个类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name, age, gender) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.gender = gender;</div><div class="line">  &#125;</div><div class="line">  incrementAge() &#123;</div><div class="line">    <span class="keyword">this</span>.age += <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 extends 关键字来继承一个类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Personal</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name, age, gender, occupation, hobby) &#123;</div><div class="line">    <span class="keyword">super</span>(name, age, gender);</div><div class="line">    <span class="keyword">this</span>.occupation = occupation;</div><div class="line">    <span class="keyword">this</span>.hobby = hobby;</div><div class="line">  &#125;</div><div class="line">  incrementAge() &#123;</div><div class="line">    <span class="keyword">super</span>.incrementAge();</div><div class="line">    <span class="keyword">this</span>.age +=<span class="number">20</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最佳实践：虽然使用 ES6 的语法创造类的时候，js引擎是如何实现类以及如何操作原型是令人费解的，但是未来对初学者来说这是一个好的开始，同时也可以让我们写更简洁的代码。</p>
<h1 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h1><p>Symbols 在 ES6 之前就已经存在，但是我们现在可以直接使用一个开发的接口了。Symbols 是不可改变并且是第一无二的，可以在任意哈希中作一个key。</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol()"></a>Symbol()</h2><p>调用 Symbol() 或者 Symbol(description) 可以创造一个第一无二的符号，但是在全局是看不到的。Symbol() 的一个使用情况是给一个类或者命名空间打上补丁，但是可以确定的是你不会去更新它。比如，你想给 React.Component 类添加一个 refreshComponent 方法，但是可以确定的是你不会在之后更新这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> refreshComponent = <span class="built_in">Symbol</span>();</div><div class="line">React.Component.prototype[refreshComponent] = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">//do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Symbol-for-key"><a href="#Symbol-for-key" class="headerlink" title="Symbol.for(key)"></a>Symbol.for(key)</h2><p>Symbol.for(key) 同样会创造一个独一无二并且不可改变的 Symbol，但是它可以全局看到，两个相同的调用 Symbol.for(key) 会返回同一个 Symbol 类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Symbol</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)    <span class="comment">// false</span></div><div class="line"><span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);  <span class="comment">//false</span></div><div class="line"><span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);  <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>对于 Symbols 的普遍用法（尤其是Symbol.for(key)）是为了协同性。它可以通过在一个第三方插件中已知的接口中对象中的参数中寻找用 Symbol 成员来实现，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reader</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> specialRead = <span class="built_in">Symbol</span>.for(<span class="string">'specialRead'</span>);</div><div class="line">  <span class="keyword">if</span> (obj[specialRead]) &#123;</div><div class="line">    <span class="keyword">const</span> reader = obj[specialRead]();</div><div class="line">    <span class="comment">// do something with reader</span></div><div class="line">  &#125; <span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'object cannot be read'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在另一个库中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> specialRead = <span class="built_in">Symbol</span>.for(<span class="string">'specialRead'</span>);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeReadableType</span> </span>&#123;</div><div class="line">  [specialRead]() &#123;</div><div class="line">    <span class="keyword">const</span> reader = createSomeReaderForm(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> reader;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h1><p>Maps 在 JavaScript 中是一个非常必须的数据结构，在 ES6 之前，我们通过对象来实现哈希表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">map[key1] = <span class="string">'value1'</span>;</div><div class="line">map[key2] = <span class="string">'value2'</span>;</div></pre></td></tr></table></figure>
<p>但是它并不能防止我们偶然地用一些特殊的属性名重写函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getOwnProperty(&#123; <span class="attr">hasOwnProperty</span>: <span class="string">'Hah, overwritten'</span>&#125;, <span class="string">'Pwned'</span>);</div></pre></td></tr></table></figure>
<p>实际上 Maps 允许我们对值进行 set、get 和 search 操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'name'</span>,<span class="string">'david'</span>);</div><div class="line">map.get(<span class="string">'name'</span>);    <span class="comment">//  david</span></div><div class="line">map.has(<span class="string">'name'</span>);   <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>Maps 更令人惊奇的部分就是它不仅限于使用字符串作为 key，还可以用其他任何类型的数据作为 key：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">  [<span class="string">'name'</span>, <span class="string">'david'</span>],</div><div class="line">  [<span class="literal">true</span>, <span class="string">'false'</span>],</div><div class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</div><div class="line">  [&#123;&#125;, <span class="string">'object'</span>],</div><div class="line">  [<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="string">'function'</span>]</div><div class="line">]);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> key);</div><div class="line">  <span class="comment">//  string, boolean, number, object, function</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：但我们使用 map.get() 方法去测试相等时，如果在 Maps 中使用 函数 或者 对象 等非原始类型值的时候测试将不起作用，所以我们应该使用 Strings, Booleans 和 Numbers 这样的原始类型的值。</p>
<p>我们还可以使用 .entries() 来遍历迭代：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="WeakMaps"><a href="#WeakMaps" class="headerlink" title="WeakMaps"></a>WeakMaps</h1><p>在 ES6 之前，为了存储私有变量，我们有各种各样的方法去实现，其中一种方法就是用命名约定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(age) &#123;</div><div class="line">    <span class="keyword">this</span>._age = age;</div><div class="line">  &#125;</div><div class="line">  _incrementAge() &#123;</div><div class="line">    <span class="keyword">this</span>._age += <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是命名约定在代码中仍然会令人混淆并且并不会真正的保持私有变量不被访问。现在，我们可以使用 WeakMaps 来存储变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> _age = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(age) &#123;</div><div class="line">    _age.set(<span class="keyword">this</span>, age);</div><div class="line">  &#125;</div><div class="line">  incrementAge() &#123;</div><div class="line">    <span class="keyword">let</span> age = _age.get(<span class="keyword">this</span>) + <span class="number">1</span>;</div><div class="line">    _age.set(<span class="keyword">this</span>, age);</div><div class="line">    <span class="keyword">if</span> (age &gt; <span class="number">50</span>) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"Midlife crisis"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 WeakMaps 存储变量很酷的一件事是它的 key 他不需要属性名称，可以使用 Reflect.ownKeys() 来查看这一点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="number">50</span>);</div><div class="line">person.incrementAge();     <span class="comment">//  'Midlife crisis'</span></div><div class="line"><span class="built_in">Reflect</span>.ownKeys(person);    <span class="comment">//  []</span></div></pre></td></tr></table></figure>
<p>一个更实际的实践就是可以 WeakMaps 储存 DOM 元素，而不会污染元素本身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'someElement'</span>);</div><div class="line"><span class="comment">// Store a weak reference to the element with a key</span></div><div class="line">map.set(el, <span class="string">'reference'</span>);</div><div class="line"><span class="comment">//  Access the value of element</span></div><div class="line"><span class="keyword">let</span> value = map.get(el);     <span class="comment">//  'reference'</span></div><div class="line"><span class="comment">//  Remove the reference</span></div><div class="line">el.parentNode.removeChild(el);</div><div class="line">el = <span class="literal">null</span>;</div><div class="line"></div><div class="line"><span class="comment">// map is empty, since the element is destroyed</span></div></pre></td></tr></table></figure>
<p>如上所示，当一个对象被垃圾回收机制销毁的时候， WeakMap 将会自动地一处关于这个对象地键值对。</p>
<p>注意：为了进一步说明这个例子的实用性，可以考虑 jQuery 是如何实现缓存一个对象相关于对引用地 DOM 元素对象。使用 jQuery ，当一个特定地元素一旦在 document 中移除的时候，jQuery 会自动地释放内存。总体来说，jQuery 在任何 dom 库中都是很有用的。</p>
<h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>Promises 可以让我们远离平行的代码（回调地狱）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</div><div class="line">  func2(value1, <span class="function"><span class="keyword">function</span> (<span class="params">value2</span>) </span>&#123;</div><div class="line">    func3(value2, <span class="function"><span class="keyword">function</span> (<span class="params">value3</span>) </span>&#123;</div><div class="line">      func4(value3, <span class="function"><span class="keyword">function</span> (<span class="params">value4</span>) </span>&#123;</div><div class="line">        func5(value4, funciton (value5) &#123;</div><div class="line">          <span class="comment">//  Do something with value 5</span></div><div class="line">        &#125;);</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>转变成垂直代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func1(value1)</div><div class="line">  .then(func2)</div><div class="line">  .then(func3)</div><div class="line">  .then(func4)</div><div class="line">  .then(func5, value5 =&gt; &#123;</div><div class="line">    <span class="comment">//  Do something with value 5</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 ES6 之前，我们使用 bluebird 或者 q，现在我们可以使用原生的 Promise 了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></div><div class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Failed to fulfill Promise'</span>)))</div><div class="line">  .catch(<span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(reason));</div></pre></td></tr></table></figure>
<p>我们有两个处理器，resolve（当Promise是 fulfilled 时的回调）和 reject（当Promise是 rejected 时的回调）：。</p>
<p>Promises的好处：对错误的处理使用一些列回调会使代码很混乱，使用 Promise ，我看可以清晰的让错误冒泡并且在合适的时候处理它，甚至，在 Promise 确定了 resolved/rejected 之后，他的值是不可改变的－－它从来不会变化。</p>
<p>这是使用 Promise 的一个实际的栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resove, reject</span>) =&gt;</span> &#123;</div><div class="line">  request.get(url,(error, response, body) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (body) &#123;</div><div class="line">      resove(<span class="built_in">JSON</span>.parse(body));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      resove(&#123;&#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>我们还可以使用 Promise.all() 来 并行 处理多个异步函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> urls = [</div><div class="line">  <span class="string">'/api/commits'</span>,</div><div class="line">  <span class="string">'/api/issues/opened'</span>,</div><div class="line">  <span class="string">'/api/issues/assigned'</span>,</div><div class="line">  <span class="string">'/api/issues/completed'</span>,</div><div class="line">  <span class="string">'/api/issues/comments'</span>,</div><div class="line">  <span class="string">'/api/pullrequests'</span></div><div class="line">];</div><div class="line"><span class="keyword">let</span> promises = urls.map(<span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    $.ajax(&#123; <span class="attr">url</span>: url&#125;)</div><div class="line">      .done(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</div><div class="line">        resolve(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">Promise</span>.all(promises)</div><div class="line">  .then(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// Do something with result of all our promise</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="Generators-生成器"><a href="#Generators-生成器" class="headerlink" title="Generators 生成器"></a>Generators 生成器</h1><p>就像 Promises 可以帮我们避免回调地狱，Generators 可以帮助我们让代码风格更整洁－－用同步的代码风格来写异步代码，它本质上是一个可以暂停计算并且可以随后返回表达式的值的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sillyGenerator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> generator = sillyGenerator();</div><div class="line"><span class="built_in">console</span>.log(generator.next());  <span class="comment">//  &#123; value: 1, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(generator.next());  <span class="comment">//  &#123; value: 2, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(generator.next());  <span class="comment">//  &#123; value: 3, done: false &#125;</span></div><div class="line"><span class="built_in">console</span>.log(generator.next());  <span class="comment">//  &#123; value: 4, done: false &#125;</span></div></pre></td></tr></table></figure>
<p>next 可以回去到下一个 yield 返回的值，当然上面的代码是非常不自然的，我们可以利用 Generators 来用同步的方式来写异步操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  getJSON(url, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">    generator.next(response);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> entry1 = <span class="keyword">yield</span> request(<span class="string">'http://some_api/item1'</span>);</div><div class="line">  <span class="keyword">var</span> data1 = <span class="built_in">JSON</span>.parse(entry1);</div><div class="line">  <span class="keyword">var</span> entry2 = <span class="keyword">yield</span> request(<span class="string">'http://some_api/item2'</span>);</div><div class="line">  <span class="keyword">var</span> data2 = <span class="built_in">JSON</span>.parse(entry2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 yield，我们可以保证 entry1 有 data1 中我们需要解析并储存的数据。</p>
<p>虽然我们可以利用 Generators 来用同步的方式来写异步操作，但是确认错误的传播变得不再清晰，我们可以在 Generators 中加上 Promise：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    getJSON(url, resolve);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们写一个函数逐步调用 next 并且利用 request 方法产生一个 Promise：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterateGenerator</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> generator = gen();</div><div class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ret = generator.next();</div><div class="line">    <span class="keyword">if</span>(!ret.done) &#123;</div><div class="line">      ret.value.then(iterate);</div><div class="line">    &#125;</div><div class="line">  &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Generators 中加上 Promise 之后我们可以更清晰的使用 Promise 中的 .catch 和 reject来捕捉错误，让我们使用新的 Generator，和之前的还是蛮相似的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">iterateGenerator(<span class="function"><span class="keyword">function</span>* <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> entry1 = <span class="keyword">yield</span> request(<span class="string">'http://some_api/item1'</span>);</div><div class="line">  <span class="keyword">var</span> data1 = JSPN.parse(entry);</div><div class="line">  <span class="keyword">var</span> entry2 = yidld request(<span class="string">'http://some_api/item2'</span>);</div><div class="line">  <span class="keyword">var</span> data2 = <span class="built_in">JSON</span>.parse(entry2);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async Await"></a>Async Await</h1><p>当 ES6 真正到来的时候，async await 可以用更少的处理实现 Promise 和 Generators 所实现的异步处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</div><div class="line">funciton getJSON(url) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    request(url, <span class="function"><span class="keyword">function</span>(<span class="params">error, response, body</span>) </span>&#123;</div><div class="line">      resolve(body);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> data = <span class="keyword">await</span> getJSON();</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;</div><div class="line">main();</div></pre></td></tr></table></figure>
<p>在 js 引擎中，它所实现的和 Generators 其实是一样的，我更推荐在 Generators + Promises 之上使用 async await，更多的资源和使用 ES7 和 用 babel 转化可以看这里。</p>
<h1 id="Getter-Setter-函数"><a href="#Getter-Setter-函数" class="headerlink" title="Getter/Setter 函数"></a>Getter/Setter 函数</h1><p>ES6 已经开始实现了 getter 和 setter 函数，比如虾面这个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">  construstor(name) &#123;</div><div class="line">    <span class="keyword">this</span>._name = name;</div><div class="line">  &#125;</div><div class="line">  get name() &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._name) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">'Mr. '</span> + <span class="keyword">this</span>._name.toUpperCase();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  set name(newName) &#123;</div><div class="line">    <span class="keyword">if</span> (newName == <span class="keyword">this</span>._name) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'I already have this name.'</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newName) &#123;</div><div class="line">      <span class="keyword">this</span>._name = newName;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> emp = <span class="keyword">new</span> Employee(<span class="string">"James Bond"</span>);</div><div class="line"><span class="keyword">if</span> (emp.name) &#123;</div><div class="line">  <span class="built_in">console</span>.log(emp.name);    <span class="comment">//  Mr.  JAMES  BOND</span></div><div class="line"> &#125;</div><div class="line">emp.name = <span class="string">"Bond 007"</span>;</div><div class="line"><span class="built_in">console</span>.log(emp.name);    <span class="comment">//  Mr.  Bond  007</span></div></pre></td></tr></table></figure>
<p>最新版本的浏览器也在对象中实现了 getter 和 setter 函数，我们可以使用它们来实现 计算属性，在设置和获取一个属性之前加上监听器和处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">firstName</span>: <span class="string">'James'</span>,</div><div class="line">  <span class="attr">lastName</span>: <span class="string">'Bond'</span>,</div><div class="line">  get fullName() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Getting FullName'</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName;</div><div class="line">  &#125;,</div><div class="line">  set fullName (name) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Setting FullName'</span>);</div><div class="line">    <span class="keyword">var</span> words = name.toString().split(<span class="string">' '</span>);</div><div class="line">    <span class="keyword">this</span>.firstName = words[<span class="number">0</span>] || <span class="string">''</span>;</div><div class="line">    <span class="keyword">this</span>.lastName = words[<span class="number">1</span>] || <span class="string">''</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">person.fullName;    <span class="comment">//  James Bond</span></div><div class="line">person.fullName = <span class="string">'Bond 007'</span>;</div><div class="line">person.fullName;    <span class="comment">//  Bond 007</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇手册包含了 ES2015(ES6) 的使用小技巧、最佳实践以及可以给你每天的工作参考的代码片段。&lt;/p&gt;
&lt;h1 id=&quot;var-和-let-const-的比较&quot;&gt;&lt;a href=&quot;#var-和-let-const-的比较&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="ES6" scheme="http://www.chenqiangyi.cn/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://www.chenqiangyi.cn/tags/ES6/"/>
    
      <category term="JavaScript" scheme="http://www.chenqiangyi.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6新特性(1)——Arguments和Parameters</title>
    <link href="http://www.chenqiangyi.cn/2016/08/02/ES6%E6%96%B0%E7%89%B9%E6%80%A7(1)%E2%80%94%E2%80%94Arguments%E5%92%8CParameters/"/>
    <id>http://www.chenqiangyi.cn/2016/08/02/ES6新特性(1)——Arguments和Parameters/</id>
    <published>2016-08-02T01:05:29.000Z</published>
    <updated>2017-06-14T13:07:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>ECMAScript 6 (也称 ECMAScript 2015) 是ECMAScript 标准的最新版本，显著地完善了JS中参数的处理方式。除了其它新特性外，我们还可以使用rest参数、默认值、解构赋值等。</p>
</blockquote>
<h1 id="对比-Arguments-和-Parameters"><a href="#对比-Arguments-和-Parameters" class="headerlink" title="对比 Arguments 和 Parameters"></a>对比 Arguments 和 Parameters</h1><p>通常情况下提到 Arguments 和 Parameters， 都认为是可以互换使用的。然而，基于本教程的目的，我们做了明确的区分。在大多数标准中，parameters (形式参数) 指声明函数名和函数体的时候使用的参数，而 arguments (实际参数) 指在函数实际调用时，传入的确定值。思考下面这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function foo(param1, param2) &#123;</div><div class="line">  // do something</div><div class="line">&#125;</div><div class="line">foo(10, 20);</div></pre></td></tr></table></figure>
<p>在这个函数中， param1 和 param2 是函数的形式参数（形参）, 而在函数foo调用时，传入的 (10 和 20) 则是实际参数（实参）。</p>
<h1 id="扩展操作符"><a href="#扩展操作符" class="headerlink" title="扩展操作符"></a>扩展操作符</h1><p>在 ES5 中，用 apply() 方法可以很方便地将一个数组传递给函数。例如，我们经常把它和 Math.max() 结合使用，来取得数组中的最大值。请看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myArray = [5, 10, 50];</div><div class="line">Math.max()myArray;        // Error: NaN</div><div class="line">Math.max.apply(Math, myArray);     //50</div></pre></td></tr></table></figure>
<p>Math.max() 方法并不支持传入数组，它只接受数字。所以当我们把数组作为参数传递给它时，就会抛出错误。但是，加上 apply() 方法后，数组会被转换成单独的数字，就能被 Math.max() 处理了。</p>
<p>庆幸的是，ES6 引入了扩展操作符，我们不需要再使用 apply() 方法了。通过扩展操作符，我们可以很方便地为表达式传入多个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myArray = [5, 10, 50];</div><div class="line">Math.max(...myArray);      //50</div></pre></td></tr></table></figure>
<p>这里，扩展操作符把 myArray 展开成独立的数值传给了函数。 ES5里面使用 apply() 来模仿操作符是可以达到目的的，只是语法上令人困惑，并且缺乏扩展操作符的灵活性。 扩展操作符不仅易于使用，还涵盖了很多其他特性。例如，它可以被多次使用，还可以在 function 调用时，和其它参数混合使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function myFunction() &#123;</div><div class="line">  for(var i in arguments)&#123;</div><div class="line">    console.log(arguments[i]);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var params = [10, 15];</div><div class="line">myFunction(5, ...params, 20, ...[25]);       // 5 10 15 20 25</div></pre></td></tr></table></figure>
<p>扩展操作符的另一个优点，就是它可以很简单地和构造函数一起使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new Date(...[2016, 5, 6]);       //  Mon Jun 06 2016</div><div class="line">00 : 00: 00 GMT-0700 (Pacific Daylight Time)</div></pre></td></tr></table></figure>
<p>当然，我们可以用ES5重写上面的代码，但我们则需要用一个复杂的模式来避免类型错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new Date.apply(null, [2016, 4, 24]);       //  TypeError:Date.apply is not a constructor</div><div class="line">new (Function.prototype.bind.apply(Date,[null].concat([2016, 5, 6])));   // Mon Jun 06 2016 00 : 00 : 00 GMT-0700 (Pacific Daylight Time)</div></pre></td></tr></table></figure>
<p>浏览器对扩展操作符在函数中调用的支持情况</p>
<p>桌面浏览器</p>
<table>
<thead>
<tr>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Internet Explorer</th>
<th style="text-align:center">Microsoft Edge</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">46</td>
<td style="text-align:center">27</td>
<td style="text-align:center">–</td>
<td style="text-align:center">supported</td>
<td style="text-align:center">–</td>
<td style="text-align:center">7.1</td>
</tr>
</tbody>
</table>
<p>移动端浏览器：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Chrome for Android</th>
<th style="text-align:center">Firefox Mobile</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">Oprea Mobile</th>
<th style="text-align:center">IE Mobile</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">46</td>
<td style="text-align:center">27</td>
<td style="text-align:center">8</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
</tr>
</tbody>
</table>
<h1 id="Rest参数"><a href="#Rest参数" class="headerlink" title="Rest参数"></a>Rest参数</h1><p>rest参数和扩展操作符拥有相同的语法，不同的是，rest参数是把所有的参数收集起来转换成数组，而扩展操作符是把数组扩展成单独的参数。</p>
<figure class="highlight plain"><figcaption><span>myFunction(...options) &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  return options;</div><div class="line">&#125;</div><div class="line">myFunction(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;);     //  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</div></pre></td></tr></table></figure>
<p>如果函数调用时，没有传入实际参数，则rest参数会输出一个空数组，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function myFunction(...options) &#123;</div><div class="line">  return options;</div><div class="line">&#125;</div><div class="line">myFunction();      //[]</div></pre></td></tr></table></figure>
<p>rest参数在创建一个可变函数（即一个参数个数可变的函数）时尤其有用。rest参数有着数组固有的优势，可以快捷地替换 arguments 对象（下文会解释这个名词）。下面这个函数是用ES5写的，我们来看下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function checkSubstrings(string) &#123;</div><div class="line">  for(var i = 1; i &amp;lt; arguments.length; i++) &#123;</div><div class="line">    if(string.indexOf(arguments[i]) === -1)&#123;</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line">checkSubstrings(&apos;this is a string&apos;, &apos;is&apos;, &apos;this&apos;);    //true</div></pre></td></tr></table></figure>
<p>该函数检查字符串（this is a string）是否包括这些子串（is, this）。这个函数存在的第一个问题是，我们必须看函数体内是否有多个参数。第二个问题是，循环必须从 1 开始，而不是从 0 开始, 因为 arguments[0] 指向的就是第一个参数（this is a string）。 如果以后我们想要在这个字符串的前面或者后面添加另一个参数，我们可能会忘记更新循环体。而使用rest参数，我们就可以很容易地避免这些问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function checkSubstrings(string, ...keys) &#123;</div><div class="line">  for (var key of keys) &#123;</div><div class="line">    if(string.indexOf(key) === -1) &#123;</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line">checkSubstrings(&apos;this is a string&apos;, &apos;is&apos;, &apos;this&apos;);    //true</div></pre></td></tr></table></figure>
<p>该函数的输出跟前一个函数的输出是一样的。这里再提一下，参数 string 被包含在这个函数的 argument 中，并且第一个被传递进来，剩下的参数都被放到一个数组，并且赋给了名为 keys 的变量。</p>
<p>使用rest参数替代 arguments 对象来提高代码的可读性和避免一些js的优化问题1。 然而，rest参数也不是没有缺点的。例如，它必须是最后一个参数，否则就会报错，如下面函数所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function logArguments(a, ...params, b) &#123;</div><div class="line">  console.log(a, params, b);</div><div class="line">&#125;</div><div class="line">logArguments(5, 10, 15);      //SyntaxError: parameter after rest parameter</div></pre></td></tr></table></figure>
<p>另一个缺点是，一个函数声明只能允许有一个rest参数：</p>
<figure class="highlight plain"><figcaption><span>logArguments(...param1, ...param2) &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#125;</div><div class="line">logArgument(5, 10, 15);      //SyntaxError: parameter after rest parameter</div></pre></td></tr></table></figure>
<p>浏览器对Rest参数的支持情况</p>
<p>桌面浏览器：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Internet Explorer</th>
<th style="text-align:center">Microsoft Edge</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">47</td>
<td style="text-align:center">15</td>
<td style="text-align:center">–</td>
<td style="text-align:center">supported</td>
<td style="text-align:center">34</td>
<td style="text-align:center">–</td>
</tr>
</tbody>
</table>
<p>移动端浏览器：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Chrome for Android</th>
<th style="text-align:center">Firefox Mobile</th>
<th style="text-align:center">Safari</th>
<th style="text-align:center">Oprea Mobile</th>
<th style="text-align:center">IE Mobile</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">46</td>
<td style="text-align:center">15</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
</tr>
</tbody>
</table>
<p>默认参数</p>
<p>ES5 默认参数</p>
<p>在ES5中，JS 并不支持默认参数, 但是，我们也有一种变通的方案，那就是在函数中使用 OR 操作符（ ||）。我们简单地模仿ES5中的默认参数，请看下面函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function foo(param1, param2) &#123;</div><div class="line">  param1 = param1 || 10;</div><div class="line">  param2 = param2 || 10;</div><div class="line">  console.log(param1, param2);</div><div class="line">&#125;</div><div class="line">foo(5, 5);</div><div class="line">foo(5);</div><div class="line">foo();</div><div class="line">VM2450:4 5 5</div><div class="line">VM2450:4 5 10</div><div class="line">VM2450:4 10 10</div></pre></td></tr></table></figure>
<p>该函数预期传入两个参数，但如果在调用该函数时，没有传入实参，则它会用默认值。在函数体内，如果没有传入实际参数，则会被自动设为 undefined, 所以，我们可以检测这些参数，并且声明他们的默认值。我们可以使用 OR 操作符（||）来检测是否有传入实际参数，并且设定他们的默认值。OR 操作符会检测它的第一个参数，如果有实际值2，则用第一个，如果没有，则用它的第二个参数。</p>
<p>这种方法在函数中普遍使用，但它有一个瑕疵，那就是传入 0 或者 null 也会触发默认值，因为 0 和 null 都被认为是false. 所以，如果我们需要给函数传入 0 和 null 时，我们需要另一种方式去检测这个参数是否缺失：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo(param1, param2) &#123;</div><div class="line">  if(param1 === undefined) &#123;</div><div class="line">    param1 = 10;</div><div class="line">  &#125;</div><div class="line">  if(param2 === undefined) &#123;</div><div class="line">    param2 = 10;</div><div class="line">  &#125;</div><div class="line">  console.log(param1, param2);</div><div class="line">&#125;</div><div class="line">foo(0, null);</div><div class="line">foo();</div><div class="line">VM788:8 0 null</div><div class="line">VM788:8 10 10</div></pre></td></tr></table></figure>
<p>在上面这个函数中，只有当所传的参数全等于 undefined 时，才会使用默认值。这种方式需要用到的代码稍微多点，但是安全度更高，我们可以给函数传入 0 和 null 。</p>
<p>ES6 默认参数</p>
<p>有了ES6,我们不需要再去检测哪些值为undefined并且给它们设定默认值了。现在我们可以直接在函数声明中放置默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo(a = 10, b = 10) &#123;</div><div class="line">  console.log(a, b);</div><div class="line">&#125;</div><div class="line">foo(5);</div><div class="line">foo(0, null);</div><div class="line">VM837:2 5 10</div><div class="line">VM837:2 0 null</div></pre></td></tr></table></figure>
<p>如你所见，省略一个参数，就会触发一个默认值，但是传入 0 或者 null 时，则不会。 我们甚至可以使用函数去找回默认参数的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function getParam() &#123;</div><div class="line">  alert(&quot;getParam was called&quot;);</div><div class="line">  return 3;</div><div class="line">&#125;</div><div class="line">function multiply(param1, param2 = getParam()) &#123;</div><div class="line">  return param1 * param2;</div><div class="line">&#125;</div><div class="line">multiply(2, 5);    //10</div><div class="line">multiply(2);     // 6 (also displays an alert dialog)</div></pre></td></tr></table></figure>
<p>注意 getParam 这个函数只有在第二个参数省略时才会被调用。所以当我们给 multiply 传入两个参数并调用它时，alert是不会出现的。</p>
<p>默认参数还有一个有趣的特性，那就是我们可以在函数声明中指定其它参数和变量的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function myFunction(a = 10, b = a) &#123;</div><div class="line">  console.log(&apos;a = &apos; + a + &apos; ; b = &apos; + b);</div><div class="line">&#125;</div><div class="line">myFunction();       //  a=10; b=10</div><div class="line">myFunction(22);   //  a=22; b=22</div><div class="line">myFunction(2, 4); //  a=2; b=4</div></pre></td></tr></table></figure>
<p>你甚至可以在函数声明中做运算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function myFunction (a, b = ++a, c = a*b) &#123;</div><div class="line">  console.log(c);</div><div class="line">&#125;</div><div class="line">myFunction(5);    //36</div></pre></td></tr></table></figure>
<p>请注意，JavaScript 和其它语言不同， 它是在函数被调用时，才去求参数的默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function add(value, array = []) &#123;</div><div class="line">  array.push(value);</div><div class="line">  return array;</div><div class="line">&#125;</div><div class="line">add(5);    //  [5]</div><div class="line">add(6);    //  [6], not [5, 6]</div></pre></td></tr></table></figure>
<p>浏览器对默认参数的支持情况</p>
<p>桌面浏览器：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Feature</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Internet Explorer</th>
<th style="text-align:center">Microsoft Edge</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Basic support</td>
<td style="text-align:center">49</td>
<td style="text-align:center">15</td>
<td style="text-align:center">–</td>
<td style="text-align:center">14</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">Parameters without defaults after default parameter</td>
<td style="text-align:center">49</td>
<td style="text-align:center">26</td>
<td style="text-align:center">–</td>
<td style="text-align:center">14</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
</tr>
</tbody>
</table>
<p>移动端浏览器：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Feature</th>
<th style="text-align:center">Chrome</th>
<th style="text-align:center">Firefox</th>
<th style="text-align:center">Internet Explorer</th>
<th style="text-align:center">Microsoft Edge</th>
<th style="text-align:center">Opera</th>
<th style="text-align:center">Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Basic support</td>
<td style="text-align:center">49</td>
<td style="text-align:center">15</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">Parameters without defaults after default parameter</td>
<td style="text-align:center">49</td>
<td style="text-align:center">25</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
</tr>
</tbody>
</table>
<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>解构赋值是ES6的新特性。我们可以从数组和对象中提取值，对变量进行赋值。这种语法清晰且易于理解，尤其是在给函数传参时特别有用。</p>
<p>在ES5里面，我们经常用一个配置对象来处理大量的可选参数， 特别是当对象属性的顺序可变时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function initiateTransfer(options) &#123;</div><div class="line">  var protoclo = options.protocol,</div><div class="line">  port = options.port,</div><div class="line">  retires = options.retries,</div><div class="line">  timeout = options.timeout,</div><div class="line">  log = options.log;</div><div class="line">&#125;</div><div class="line">options = &#123;</div><div class="line">  protocol: &apos;http&apos;,</div><div class="line">  port: 800,</div><div class="line">  delay: 150,</div><div class="line">  retries: 10,</div><div class="line">  timeout: 500,</div><div class="line">  log: true</div><div class="line">&#125;;</div><div class="line">initiateTransfer(options);</div></pre></td></tr></table></figure>
<p>这种方式实现起来很好，已经被许多JS开发者所采用。 只是我们必须看函数内部，才知道函数预期需要哪些参数。结合解构赋值，我们就可以在函数声明中清晰地表示这些参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function initiateTransfer(&#123;protocol, port, delay, retries, timeout, log&#125;) &#123;</div><div class="line">  //code to initiate transfer</div><div class="line">&#125;;</div><div class="line">var options = &#123;</div><div class="line">  protocol: &apos;http&apos;,</div><div class="line">  port: 800,</div><div class="line">  delay: 150,</div><div class="line">  retries: 10,</div><div class="line">  timeout: 500,</div><div class="line">  log: true</div><div class="line">&#125;</div><div class="line">initiateTransfer(options);</div></pre></td></tr></table></figure>
<p>在该函数中，我们没有传入一个配置对象，而是以对象解构赋值的方式，给它传参数。这样做不仅使这个函数更加简明，可读性也更高。</p>
<p>我们也可以把解构赋值传参和其它规则的参数一起使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function initiateTransfer(param1, &#123;protocol, port, delay, retires, timeout,log&#125;) &#123;</div><div class="line">  //code to initiate transfer</div><div class="line">&#125;</div><div class="line">initiateTransfer(&apos;some value&apos;, options);</div></pre></td></tr></table></figure>
<p>注意如果函数调用时，参数被省略掉，则会抛出错误，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function initiateTransfer(&#123;protocol, port, delay, retries, timeout, log&#125;) &#123;</div><div class="line">  //code to initiate transfer</div><div class="line">&#125;</div><div class="line">initiateTransfer();     //TypeError:Cannot match against &apos;undefined&apos; or &apos;null&apos;</div></pre></td></tr></table></figure>
<p>当我们需要让参数都是必填时，这种方法能够得到我们想要的结果，但如果我们希望参数是可选的时候呢？想要让参数缺失时不会报错，我们就需要给默认参数设定一个默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function initiateTransfer (&#123;protocol, port, delay, retries, timeout, log&#125; = &#123;&#125;) &#123;</div><div class="line">  //code to initiate transfer</div><div class="line">&#125;</div><div class="line">initiateTransfer();    //  no error</div></pre></td></tr></table></figure>
<p>上面这个函数中，需要解构赋值的参数有了一个默认值，这个默认值就是一个空对象。这时候，函数被调用时，即使没有传入参数，也不会报错了。</p>
<p>我们也可以给每个被解构的参数设定默认值，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function initiateTransfer(&#123;</div><div class="line">  protocol = &apos;http&apos;,</div><div class="line">  port = 800,</div><div class="line">  delay = 150,</div><div class="line">  retries = 10,</div><div class="line">  timeout = 500,</div><div class="line">  log = true</div><div class="line">&#125;) &#123;</div><div class="line">  //code to initiate transfer</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，每个属性都有一个默认值，我们不需要手动去检查哪个参数值是 undefined ，然后在函数中给它设定默认值了。</p>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>参数能通过引用或值传递给函数。修改按引用传递的参数，一般反映在全局中，而修改按值传递的参数，则只是反映在函数内部。</p>
<p>在像 Visual Basic 和 PowerShell 这样的语言中，我们可以选择是按引用还是按值来传递参数，但是在 JavaScript 中则不行。</p>
<h2 id="按值传递参数"><a href="#按值传递参数" class="headerlink" title="按值传递参数"></a>按值传递参数</h2><p>从技术上来讲，JavaScript 只允许按值传参。当我们给函数按值传递一个参数时，该函数的作用域内就已经复制了这个值。因此，这个值的改变，只会在函数内部反映出来。请思考下面这个列子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 5;</div><div class="line">function increment(a) &#123;</div><div class="line">  a = ++a;</div><div class="line">  console.log(a);</div><div class="line">&#125;</div><div class="line">increment(a);        //6</div><div class="line">console.log(a);     //5</div></pre></td></tr></table></figure>
<p>这里，修改函数里面的参数 a = ++a，是不会影响到原来a的值。 所以在函数外面打印 a 的值，输出仍然是 5。</p>
<h2 id="按引用传递参数"><a href="#按引用传递参数" class="headerlink" title="按引用传递参数"></a>按引用传递参数</h2><p>在JavaScript中，一切都是按值传递的。但当我们给函数传一个变量，而这个变量所指向的是一个对象（包括数组）时，这个 变量 就是对象的一个引用。通过这个变量来改变对象的属性值，是会从根本上改变这个对象的。</p>
<p>来看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo(param) &#123;</div><div class="line">  param.bar = &apos;new value&apos;;</div><div class="line">&#125;</div><div class="line">obj = &#123;</div><div class="line">  bar : &apos;value&apos;</div><div class="line">&#125;</div><div class="line">console.log(obj.bar);    //  value</div><div class="line">foo(obj);</div><div class="line">console.log(obj.bar);    //  new value</div></pre></td></tr></table></figure>
<p>如你所见，对象的属性值在函数内部被修改了，被修改的值在函数外面也是可见的。</p>
<p>当我们传递一个没有初始值的参数时，如数组或对象，会隐形地创建了一个变量，这个变量指向记忆中原对象所在的位置。这个变量随后被传递给了函数，在函数内部对这个变量进行修改将会影响到原对象。</p>
<p>参数类型检测、参数缺失或参数多余</p>
<p>在强类型语言中，我们必须在函数声明中明确参数的类型，但是 JavaScript 没有这种特性。在JavaScript中，我们传递给函数的参数个数不限，也可以是任何类型的数据。</p>
<p>假设现在有一个函数，这个函数只接受一个参数。但是当函数被调用时，它本身没有限制传入的参数只能是一个，我们可以随意地传入一个、两个、甚至是更多。我们也可以什么都不传，这样都不会报错。</p>
<h2 id="形参（arguments）和-实参（parameters）的个数不同有两种情况："><a href="#形参（arguments）和-实参（parameters）的个数不同有两种情况：" class="headerlink" title="形参（arguments）和 实参（parameters）的个数不同有两种情况："></a>形参（arguments）和 实参（parameters）的个数不同有两种情况：</h2><ul>
<li>实参少于形参</li>
</ul>
<p>缺失的参数都会等同于 undefined。</p>
<ul>
<li>实参多于形参</li>
</ul>
<p>多余的参数都将被忽略，但它们会以数组的形式保存于变量 arguments 中（下文会讨论到）。</p>
<h2 id="必填参数"><a href="#必填参数" class="headerlink" title="必填参数"></a>必填参数</h2><p>如果一个参数在函数调用时缺失了，它将被设为 undefined。基于这一点，我们可以在参数缺失时抛出一个错误：</p>
<figure class="highlight plain"><figcaption><span>foo(mandatory, optional) &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  if (mandatory === undefined) &#123;</div><div class="line">    throw new Error (&apos;Missing parameter: mandatory&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ES6 中，我们可以更好地利用这个特性，使用默认参数来设定必填参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function throwError() &#123;</div><div class="line">  throw new Error(&apos;Missing parameter&apos;);</div><div class="line">&#125;</div><div class="line">function foo(parama1 = throwError(), param2 =</div><div class="line">throwError()) &#123;</div><div class="line">  //do something</div><div class="line">&#125;</div><div class="line">foo(10,20);    //ok</div><div class="line">foo(10);    //Error: missing parameter</div></pre></td></tr></table></figure>
<h2 id="参数对象"><a href="#参数对象" class="headerlink" title="参数对象"></a>参数对象</h2><p>为了取代参数对象，rest参数在 ECMAScript 4 中就已经得到支持，但是 ECMAScript 4 没有落实。随着 ECMAScript 6 版本的发布，JS 正式支持rest参数。它也拟定计划，准备抛弃 对参数对象 arguments object 的支持。</p>
<p>参数对象是一个类数组对象，可在一切函数内使用。它允许通过数字而不是名称，来找回被传递给函数的参数值。这个对象使得我们可以给函数传递任何参数。思考以下代码段：</p>
<figure class="highlight plain"><figcaption><span>checkParams(param1) &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  console.log(param1);      //  2</div><div class="line">  console.log(arguments[0], arguments[1], arguments[2]);      //  2  3  4</div><div class="line">  console.log(param1 + arguments[0]);      //  2 + 2</div><div class="line">&#125;</div><div class="line">checkParams(2, 3, 4);</div></pre></td></tr></table></figure>
<p>该函数预期接收一个参数。但是当我们给它传入两个参数并且调用它时，第一个参数通过名为 param1 的形参或者参数对象 arguments[0] 被函数所接受，而第二个参数只能被放在argument[1] 里面。此外，请注意，参数对象可以与命名参数一起使用。</p>
<p>参数对象给每个被传递给函数的参数提供了一个入口，并且第一个入口的下标从 0 开始。如果我们要给上面这个函数传递更多的参数，我们可以写 arguments[2],arguments[3] 等等。</p>
<p>我们甚至可以跳过设定命名参数这一步，直接使用参数对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function checkParams() &#123;</div><div class="line">  console.log(arguments[1], arguments[0] ,arguments[2]);</div><div class="line">&#125;</div><div class="line">checkParams(2, 4, 6)      //  4  2  6</div></pre></td></tr></table></figure>
<p>事实上，命名参数只是为了方便使用，并不是必须的。类似地，rest参数也可用于反映被传递的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function checkParams(...params) &#123;</div><div class="line">  console.log(params[1], params[0], params[2]);    // 4 2 6</div><div class="line">  console.log(arguments[1], arguments[0], arguments[2]);    // 4 2 6</div><div class="line">&#125;</div><div class="line">checkParams(2, 4, 6);</div></pre></td></tr></table></figure>
<p>参数对象是一个类数组的对象，只是它没有数组本身具备的方法，如slice() 和 foreach()。 如果要在参数对象中使用数组的方法，首先要把它转换成一个真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function sort() &#123;</div><div class="line">  var a = Array.prototype.slice.call(arguments);</div><div class="line">  return a.sort();</div><div class="line">&#125;</div><div class="line">sort(40, 20, 50,30);      //  [20, 30, 40, 50]</div></pre></td></tr></table></figure>
<p>在该函数中，采用了 Array.prototype.slice.call() 来快速地把参数对象转换成一个数组。接着，在 sort() 方法中，为这个数组排序并且把它返回。</p>
<p>ES6 新增了更直接的方法，用 Array.from() 把任何类数组对象转换成数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function sort() &#123;</div><div class="line">  var a = Array.from(arguments);</div><div class="line">  return a.sort();</div><div class="line">&#125;</div><div class="line">sort(40, 20, 50,30);      //  [20, 30, 40, 50]</div></pre></td></tr></table></figure>
<h2 id="长度属性"><a href="#长度属性" class="headerlink" title="长度属性"></a>长度属性</h2><p>尽管参数对象从技术上来讲，不算是一个数组，但仍有一个长度属性，来检测传递给函数的参数个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function countArguments() &#123;</div><div class="line">  console.log(arguments.length);</div><div class="line">&#125;</div><div class="line">countArguments();      // 0</div><div class="line">countArguments(10, null, &quot;string&quot;);      //3</div></pre></td></tr></table></figure>
<p>通过 length 属性，我们可以更好地控制传递给函数的参数个数。举个例子，如果一个函数只要求两个参数，那么我们就可以使用 length 属性来检测所传入的参数个数，如果少于要求的个数，则抛出错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo(param1, param2) &#123;</div><div class="line">  if(arguments.length &amp;lt; 2) &#123;</div><div class="line">    throw new Error (&quot;This function expects at least two arguments&quot;);</div><div class="line">  &#125; else if (arguments.length === 2) &#123;</div><div class="line">    //do something</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>rest参数是数组，所以他们都有 length 属性。 所以上面的代码，在ES6里面可以用rest参数写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo(...params) &#123;</div><div class="line">  if (params.length &amp;lt; 2) &#123;</div><div class="line">    throw new Error(&quot;This function expects at least two arguments&quot;);</div><div class="line">  &#125; else if (params.length === 2) &#123;</div><div class="line">    //do something</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="被调用属性与调用属性"><a href="#被调用属性与调用属性" class="headerlink" title="被调用属性与调用属性"></a>被调用属性与调用属性</h1><p>被调用 属性指向当前正在执行的函数，而 调用 属性则指向那个调用了 当前正在执行的函数 的函数。 在ES5的严格模式下，这些属性是不被支持的，如果尝试使用它们，则会报错。</p>
<p>arguments.callee 这个属性在递归函数中很有用，尤其在匿名函数中。因为匿名函数没有名称，只能通过 arguments.callee 来指向它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var result = (function(n) &#123;</div><div class="line"> if (n &amp;lt;= 1) &#123;</div><div class="line">  return 1;</div><div class="line">&#125; else &#123;</div><div class="line"> return n * arguments.callee(n - 1);</div><div class="line">&#125;</div><div class="line">&#125;)(4);     //undefined</div></pre></td></tr></table></figure>
<h1 id="严格模式和非严格模式下的参数对象"><a href="#严格模式和非严格模式下的参数对象" class="headerlink" title="严格模式和非严格模式下的参数对象"></a>严格模式和非严格模式下的参数对象</h1><p>在ES5非严格模式下，参数对象 有个不一般的特性：它能使 自身的值 跟 与之相对应的命名参数的值 保持同步。</p>
<p>请看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo(param) &#123;</div><div class="line">  console.log(param === arguments[0]);      // true</div><div class="line">  arguments[0] = 500;</div><div class="line">  console.log(param === arguments[0]);      //true</div><div class="line">  return param</div><div class="line">&#125;</div><div class="line">foo(200);        //500</div></pre></td></tr></table></figure>
<p>在这个函数里面，arguments[0] 被重新赋值为 500。由于 arguments 的值总是和对应的命名参数保持同步，所以改变了arguments[0] 的值，也就相应的改变了 param 的值。实际上，他们就像是同一个变量，拥有两个不同的名字而已。而在 ES5严格模式下，参数对象的这种特性则被移除了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">function foo(param) &#123;</div><div class="line">  console.log(param === arguments[0]);      //  true</div><div class="line">  arguments[0] = 500;</div><div class="line">  console.log(param === arguments[0]);      //  false</div><div class="line">  return param;</div><div class="line">&#125;</div><div class="line">foo(200);       //  200</div></pre></td></tr></table></figure>
<p>加上 严格模式， 现在改变 arguments[0] 的值是不会影响到 param 的值了，打印出来的值也跟预期的一致。 在 ES6中 该函数的输出跟在 ES5 严格模式下是一样的。需要记住的是，当函数声明中使用了默认值时，参数对象是不会受到影响的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo(param1, param2 = 10, param3 = 20) &#123;</div><div class="line">  console.log(param1 === arguments[0]);    //  true</div><div class="line">  console.log(param2 === arguments[1]);    //  true</div><div class="line">  console.log(param3 === arguments[2]);    //  false</div><div class="line">  console.log(arguments[2]);      //  undefined</div><div class="line">  console.log(param3);        //  20</div><div class="line">&#125;</div><div class="line">foo(&apos;string1&apos;, &apos;string2&apos;);</div></pre></td></tr></table></figure>
<p>在这个函数中，尽管 param3 有默认值 20，但是 arguments[2] 仍然是 undefined, 因为函数调用时只传了两个值。换言之，设定默认值对参数对象是没有任何影响的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ES6 给 JS 带来了上百个大大小小的改进。 越来越多的开发者正使用ES6的新特性, 所以我们都需要去了解它们。在本教程中，我们学习了ES6是如何改善JS的参数处理的，但我们仍只是知晓了ES6的皮毛。更多新的、有趣的特性值得我们去探讨。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ECMAScript 6 (也称 ECMAScript 2015) 是ECMAScript 标准的最新版本，显著地完善了JS中参数的处理方式。除了其它新特性外，我们还可以使用rest参数、默认值、解构赋值等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.chenqiangyi.cn/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://www.chenqiangyi.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>javascript和jquery读取和修改HTTP headers</title>
    <link href="http://www.chenqiangyi.cn/2016/06/13/javascript%E5%92%8Cjquery%E8%AF%BB%E5%8F%96%E5%92%8C%E4%BF%AE%E6%94%B9HTTP%20headers/"/>
    <id>http://www.chenqiangyi.cn/2016/06/13/javascript和jquery读取和修改HTTP headers/</id>
    <published>2016-06-12T16:40:03.000Z</published>
    <updated>2017-06-14T13:50:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近项目中遇到了一些问题，需要从第三方获取数据，通过ajax获取的时候需要修改HTTP headers信息。其中主要代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$(document).ready(function()&#123;</div><div class="line">		$.ajax(&#123;</div><div class="line">		 url: &quot;https://api.stickerpipe.com/api/v2/shop&quot;,</div><div class="line">         type: &quot;GET&quot;,</div><div class="line">          headers: &#123;</div><div class="line">		        &apos;Platform&apos;:&apos;JS&apos;,</div><div class="line">		        &apos;ApiKey&apos;:&apos;173a6bc645f17ea974cc4a25b431a82c&apos;,</div><div class="line">		        &apos;UserId&apos;:&apos;12345&apos;</div><div class="line">		    &#125;,</div><div class="line">		data :&#123;limit:&apos;10&apos;,offset:&quot;0&quot;&#125;,</div><div class="line">         success: function(json)&#123;</div><div class="line">         	console.log(json.data);</div><div class="line">         &#125;,</div><div class="line">         error: function()&#123;</div><div class="line">             alert(&apos;fail&apos;);</div><div class="line">         &#125;</div><div class="line">     &#125;);</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在这中间的ajax获取数据时需要修改HTTP headers信息，下面就来介绍一下如何修改头信息</p>
<h1 id="jquery修改HTTP-headers"><a href="#jquery修改HTTP-headers" class="headerlink" title="jquery修改HTTP headers"></a>jquery修改HTTP headers</h1><p>jQuery Ajax可以通过headers或beforeSend修改request的HTTP headers，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">        url: &quot;./test.php&quot;,</div><div class="line">        type: &quot;POST&quot;,</div><div class="line">        headers: &#123;</div><div class="line">            &quot;Accept&quot; : &quot;text/plain; charset=utf-8&quot;,</div><div class="line">            &quot;Content-Type&quot;: &quot;text/plain; charset=utf-8&quot;</div><div class="line">        &#125;,</div><div class="line">        /*</div><div class="line">        beforeSend: function(jqXHR, settings) &#123;</div><div class="line">            jqXHR.setRequestHeader(&apos;Accept&apos;, &apos;text/plain; charset=utf-8&apos;);</div><div class="line">            jqXHR.setRequestHeader(&apos;Content-Type&apos;, &apos;text/plain; charset=utf-8&apos;);</div><div class="line">        &#125;,</div><div class="line">        */</div><div class="line">        data: &#123;&quot;user&quot; : &quot;min&quot;, &quot;pass&quot; : &quot;he&quot;&#125;,</div><div class="line">        error: function(jqXHR, textStatus, errorThrown) &#123;</div><div class="line">            //....</div><div class="line">        &#125;,</div><div class="line">        success: function(data, textStatus, jqXHR) &#123;</div><div class="line">            //....</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意：：W3规定XMLHttpRequest并不能修改全部的HTTP Headers，而仅是一小部分。</p>
<h1 id="jquery获取HTTP-headers"><a href="#jquery获取HTTP-headers" class="headerlink" title="jquery获取HTTP headers:"></a>jquery获取HTTP headers:</h1><p>html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;&lt;/body&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    $(document).ready(function()&#123;</div><div class="line">        $.ajax(&#123;</div><div class="line">            url: &quot;./test.php&quot;,</div><div class="line">            type: &quot;POST&quot;,</div><div class="line">            data: &#123;&quot;user&quot; : &quot;min&quot;, &quot;pass&quot; : &quot;he&quot;&#125;,</div><div class="line">            error: function(jqXHR, textStatus, errorThrown) &#123;</div><div class="line">                if (textStatus == &quot;error&quot;) &#123;</div><div class="line">                    alert(textStatus + &quot; : &quot; +errorThrown);</div><div class="line">                &#125; else &#123;</div><div class="line">                    alert(textStatus);</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            success: function(data, textStatus, jqXHR) &#123;</div><div class="line">                alert(jqXHR.getResponseHeader(&quot;Server&quot;));</div><div class="line">                alert(jqXHR.getResponseHeader(&quot;Content-Type&quot;));</div><div class="line">                alert(jqXHR.getResponseHeader(&quot;X-Powered-By&quot;));</div><div class="line">                alert(jqXHR.getResponseHeader(&quot;Content-Encoding&quot;));</div><div class="line">                alert(jqXHR.getAllResponseHeaders());</div><div class="line">                alert(jqXHR.getResponseHeader(&quot;Set-Cookie&quot;));       //返回null，不能获取Set-Cookie的值</div><div class="line">                alert(data + textStatus);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;/html&gt;</div></pre></td></tr></table></figure>
<p>test.php</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">   if (isset($_COOKIE[&quot;time&quot;])) &#123;</div><div class="line">       $time = $_COOKIE[&quot;time&quot;] + 1;</div><div class="line">   &#125; else &#123;</div><div class="line">       $time = 1;</div><div class="line">   &#125;</div><div class="line">   setcookie(&quot;time&quot;, $time);</div><div class="line"></div><div class="line">   $user = $_REQUEST[&quot;user&quot;];</div><div class="line">   $pass = $_REQUEST[&quot;pass&quot;];</div><div class="line">   print $user.$pass.&quot; &quot;.$time;</div></pre></td></tr></table></figure>
<p>jQuery通过XMLHttpRequest的getResponseHeader或getAllResponseHeaders()可以获取指定的HTTP header field的值，但规定不能获取Set-Cookie和Set-Cookie2的值。</p>
<p>参考：</p>
<p><a href="http://stackoverflow.com/questions/1145588/cannot-properly-set-the-accept-http-header-with-jquery" target="_blank" rel="external">http://stackoverflow.com/questions/1145588/cannot-properly-set-the-accept-http-header-with-jquery</a></p>
<p><a href="http://stackoverflow.com/questions/2444489/getresponseheader-is-not-a-function" target="_blank" rel="external">http://stackoverflow.com/questions/2444489/getresponseheader-is-not-a-function</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近项目中遇到了一些问题，需要从第三方获取数据，通过ajax获取的时候需要修改HTTP headers信息。其中主要代码如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr
    
    </summary>
    
      <category term="Ajax" scheme="http://www.chenqiangyi.cn/categories/Ajax/"/>
    
    
      <category term="Ajax" scheme="http://www.chenqiangyi.cn/tags/Ajax/"/>
    
      <category term="HTTP headers" scheme="http://www.chenqiangyi.cn/tags/HTTP-headers/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API</title>
    <link href="http://www.chenqiangyi.cn/2016/06/13/restful-api/"/>
    <id>http://www.chenqiangyi.cn/2016/06/13/restful-api/</id>
    <published>2016-06-12T16:25:01.000Z</published>
    <updated>2017-06-14T14:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>好久没有写博客了，最近刚好在弄公司的一个项目需要调用别人的API，其中遇到好多坑，今天将其记录下来，方便以后的学习。<br>主要参考阮一峰的文章<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a>和博客园的一篇文章<a href="http://www.cnblogs.com/princeoicq/articles/2217808.html" target="_blank" rel="external">http://www.cnblogs.com/princeoicq/articles/2217808.html</a>，接下来就来介绍RESTful API的设计与应用。</p>
</blockquote>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>API与用户的通信协议，总是使用HTTP协议</p>
<h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><p>应该尽量将API部署到专用域名下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://api.example.com</div></pre></td></tr></table></figure>
<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://example.org/api/</div></pre></td></tr></table></figure>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>将API的版本放入URL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://api.example.com/v1/</div></pre></td></tr></table></figure>
<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>
<h1 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h1><p>路径又称”终点”（endpoint），表示API的具体网址。</p>
<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>
<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">https://api.example.com/v1/zoos</div><div class="line">https://api.example.com/v1/animals</div><div class="line">https://api.example.com/v1/employees</div></pre></td></tr></table></figure>
<h1 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h1><p>对于资源的具体操作类型，由HTTP动词表示。</p>
<p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">GET（SELECT）：从服务器取出资源（一项或多项）。</div><div class="line">POST（CREATE）：在服务器新建一个资源。</div><div class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</div><div class="line">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</div><div class="line">DELETE（DELETE）：从服务器删除资源。&lt;/pre&gt;</div><div class="line">还有两个不常用的HTTP动词</div><div class="line"></div><div class="line">&lt;pre class=&quot;prettyprint lang-js&quot;&gt;HEAD：获取资源的元数据。</div><div class="line">OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</div></pre></td></tr></table></figure>
<p>下面是一些例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /zoos：列出所有动物园</div><div class="line">POST /zoos：新建一个动物园</div><div class="line">GET /zoos/ID：获取某个指定动物园的信息</div><div class="line">PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</div><div class="line">PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</div><div class="line">DELETE /zoos/ID：删除某个动物园</div><div class="line">GET /zoos/ID/animals：列出某个指定动物园的所有动物</div><div class="line">DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</div></pre></td></tr></table></figure>
<h1 id="过滤信息-Filtering"><a href="#过滤信息-Filtering" class="headerlink" title="过滤信息 Filtering"></a>过滤信息 Filtering</h1><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>
<p>下面是一些常见的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">?limit=10：指定返回记录的数量</div><div class="line">?offset=10：指定返回记录的开始位置。</div><div class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</div><div class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</div><div class="line">?animal_type_id=1：指定筛选条件</div></pre></td></tr></table></figure>
<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>
<h1 id="状态码（Status-Code）"><a href="#状态码（Status-Code）" class="headerlink" title="状态码（Status Code）"></a>状态码（Status Code）</h1><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">200  OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</div><div class="line">201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</div><div class="line">202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</div><div class="line">204 NO CONTENT - [DELETE]：用户删除数据成功。</div><div class="line">400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</div><div class="line">401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</div><div class="line">403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</div><div class="line">404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</div><div class="line">406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</div><div class="line">410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</div><div class="line">422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</div><div class="line">500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</div></pre></td></tr></table></figure>
<p>状态码的完全列表参见这里<br><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="external">http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html</a>。</p>
<h1 id="错误处理（Error-Handling）"><a href="#错误处理（Error-Handling）" class="headerlink" title="错误处理（Error Handling）"></a>错误处理（Error Handling）</h1><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    error: &quot;Invalid API key&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h1><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET /collection：返回资源对象的列表（数组）</div><div class="line">GET /collection/resource：返回单个资源对象</div><div class="line">POST /collection：返回新生成的资源对象</div><div class="line">PUT /collection/resource：返回完整的资源对象</div><div class="line">PATCH /collection/resource：返回完整的资源对象</div><div class="line">DELETE /collection/resource：返回一个空文档</div></pre></td></tr></table></figure>
<h1 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h1><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>
<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;link&quot;: &#123;</div><div class="line">  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,</div><div class="line">  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,</div><div class="line">  &quot;title&quot;: &quot;List of zoos&quot;,</div><div class="line">  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;</div><div class="line">&#125;&#125;</div></pre></td></tr></table></figure>
<p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>
<p>Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,</div><div class="line">  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href="http://api.github.com/user" target="_blank" rel="external">http://api.github.com/user</a>，然后就得到了下面结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;message&quot;: &quot;Requires authentication&quot;,</div><div class="line">  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li><p>API的身份认证应该使用OAuth 2.0框架。</p>
</li>
<li><p>服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p>
<p>  （完）</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;好久没有写博客了，最近刚好在弄公司的一个项目需要调用别人的API，其中遇到好多坑，今天将其记录下来，方便以后的学习。&lt;br&gt;主要参考阮一峰的文章&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/05/rest
    
    </summary>
    
      <category term="API" scheme="http://www.chenqiangyi.cn/categories/API/"/>
    
    
      <category term="API" scheme="http://www.chenqiangyi.cn/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>鼠标或键盘控制3D盒子旋转</title>
    <link href="http://www.chenqiangyi.cn/2016/05/12/%E9%BC%A0%E6%A0%87%E6%88%96%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B63D%E7%9B%92%E5%AD%90%E6%97%8B%E8%BD%AC/"/>
    <id>http://www.chenqiangyi.cn/2016/05/12/鼠标或键盘控制3D盒子旋转/</id>
    <published>2016-05-11T16:59:22.000Z</published>
    <updated>2017-06-14T07:44:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究3D盒子的旋转问题，今天来学习一下通过鼠标或者键盘控制3D盒子的旋转，效图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://www.chenqiangyi.com/wp-content/uploads/2016/05/3Dbox.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>两种旋转的方式都需要先把盒子的布局完成，前面的几步是相同的</p>
<p>通过键盘控制3D盒子旋转，demo链接：<a href="http://chenqiangyi.com/example/3Dbox1.html" target="_blank" rel="external">http://chenqiangyi.com/example/3Dbox1.html</a></p>
<p>通过鼠标控制3D盒子旋转，demo链接：<a href="http://chenqiangyi.com/example/3Dbox1.html" target="_blank" rel="external">http://chenqiangyi.com/example/3Dbox1.html</a></p>
<p>1.页面布局</p>
<p>需要一个大的盒子来包住，前后左右上下六个盒子，且他们的定位都是绝对定位，这样形成了六个盒子重叠到了一块，此时我们需要把盒子的每一个面变动一下，使其组合成一个盒子。此时我们需要想象一下盒子的3D空间，对于右边的那个面，他需要先沿Z轴正方向平移100px，然后再沿着y轴旋转正90度就得到了右边的面其中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#div1 .right&#123; transform:rotateY(90deg) translateZ(100px);&#125;</div></pre></td></tr></table></figure>
<p>然后就是左边的面，和右边的相似，只是旋转角度相反而已：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#div1 .left&#123; transform:rotateY(-90deg) translateZ(100px);&#125;</div></pre></td></tr></table></figure>
<p>前后面就是直接沿Z轴平移100px和-100px即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#div1 .front&#123; transform:translateZ(100px);&#125;</div><div class="line">#div1 .back&#123; transform:translateZ(-100px);&#125;</div></pre></td></tr></table></figure>
<p>上边的面就是沿Z轴平移100px然后再按照X轴旋转90度，相反下边的面沿y轴旋转-90度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#div1 .top&#123; transform:rotateX(90deg) translateZ(100px);&#125;</div><div class="line">#div1 .bottom&#123; transform:rotateX(-90deg) translateZ(100px);&#125;</div></pre></td></tr></table></figure>
<p>然后就是为了看到3D效果，需要在其父级添加3D模型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">transform-style: preserve-3d;</div></pre></td></tr></table></figure>
<p>这样基本的布局就完成了</p>
<p>2.js控制</p>
<p>首先介绍键盘的控制，我们知道键盘的按下去与松开都对应一个onkeydown事件和onkeyup事件，我们可以用事件对象获取其中的动作当按上键的时候我们可以得到他的ev.keycode=37,同理可以得到其他键的值，我们可以先定义bTop=bBotton=bLeft=bRight=false，当按下去的时候，判定哪个键对应的方向为true，然后当松开的 时候再令bTop=bBotton=bLeft=bRight=false这样在就可控制他的停止与运动了，然后我们开一个定时器，让他在某个方向上每隔30ms加10，这样就把X，y的值获取到了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.onkeydown=<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span>(ev.keyCode==<span class="number">37</span>)&#123;</div><div class="line">			bLeft=<span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(ev.keyCode==<span class="number">38</span>)&#123;</div><div class="line">			bTop=<span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(ev.keyCode==<span class="number">39</span>)&#123;</div><div class="line">			bRight=<span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(ev.keyCode==<span class="number">40</span>)&#123;</div><div class="line">			bBotton=<span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">document</span>.onkeyup=<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span>(ev.keyCode==<span class="number">37</span>)&#123;</div><div class="line">			bLeft=<span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(ev.keyCode==<span class="number">38</span>)&#123;</div><div class="line">			bTop=<span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(ev.keyCode==<span class="number">39</span>)&#123;</div><div class="line">			bRight=<span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(ev.keyCode==<span class="number">40</span>)&#123;</div><div class="line">			bBotton=<span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>然后就是改变他的X，y的变化，进行相应的运动变换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//左右 y</span></div><div class="line"><span class="keyword">var</span> y=<span class="number">0</span>;</div><div class="line"><span class="comment">//上下</span></div><div class="line"><span class="keyword">var</span> x=<span class="number">0</span>;</div><div class="line"></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(bLeft)&#123;</div><div class="line">		y-=<span class="number">10</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(bRight)&#123;</div><div class="line">		y+=<span class="number">10</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(bTop)&#123;</div><div class="line">		x-=<span class="number">10</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(bBotton)&#123;</div><div class="line">		x+=<span class="number">10</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>)</div><div class="line">	oDiv.style.transform=<span class="string">"perspective(800px) rotateX("</span>+-x+<span class="string">"deg) rotateY("</span>+y+<span class="string">"deg)"</span></div><div class="line">&#125;,<span class="number">30</span>)</div></pre></td></tr></table></figure>
<p>这样键盘的控制就结束了，接下来就是鼠标的控制了&lt;</p>
<p>3.鼠标的控制</p>
<p>主要运用鼠标的事件，当鼠标在网页上移动时会有相应的X和Y值得变化，这样我们就很容易得到鼠标的按下的位置和移动时的位置，我们可以根据在鼠标X轴移动的距离看做是他沿Y轴转动的角度，同时Y轴也是这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.onmousedown=<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> disX=ev.clientX-y;</div><div class="line">		<span class="keyword">var</span> disY=ev.clientY-x;</div><div class="line"></div><div class="line">		<span class="built_in">document</span>.onmousemove=<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</div><div class="line">			y=ev.clientX-disX;</div><div class="line">			x=ev.clientY-disY;</div><div class="line">			oDiv.style.transform=<span class="string">"perspective(800px) rotateX("</span>+-x+<span class="string">"deg) rotateY("</span>+y+<span class="string">"deg)"</span></div><div class="line"></div><div class="line">		&#125;</div><div class="line">		<span class="built_in">document</span>.onmouseup=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="built_in">document</span>.onmousemove=<span class="built_in">document</span>.onmouseup=<span class="literal">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>这样两个效果就基本完成了。</p>
<p>4.总结</p>
<p>这个效果主要运用到了键盘的控制事件，以及盒子的拖拽模型，还有就是布局的知识，在以后会加上在移动端的控制。</p>
<p>最后附上两个模型的源代码：</p>
<p>键盘控制3D盒子旋转：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta charset="UTF-8"&gt;</div><div class="line">&lt;title&gt;&lt;/title&gt;</div><div class="line">&lt;style type="text/css"&gt;</div><div class="line">*&#123;margin: 0;padding: 0;&#125;</div><div class="line">#div1&#123;position: relative;width: 200px;height: 200px;margin: 100px auto;line-height: 200px;text-align: center;font-size: 30px;</div><div class="line">	transform: perspective(800px) rotateX(0deg) rotateY(0deg);</div><div class="line">	transform-style: preserve-3d;</div><div class="line">	/*transition: 3s all ease;*/</div><div class="line">&#125;</div><div class="line">#div1 div&#123;position: absolute;left: 0;top: 0;width: 198px;height: 198px;border: 1px solid #000;background: yellow;&#125;</div><div class="line"></div><div class="line">#div1 .front&#123;transform: translateZ(100px);background: green;&#125;</div><div class="line">#div1 .back&#123;transform: translateZ(-100px);background: blue;&#125;</div><div class="line">#div1 .left&#123;transform: rotateY(-90deg) translateZ(100px);background: pink;&#125;</div><div class="line">#div1 .right&#123;transform: rotateY(90deg) translateZ(100px);background: red;&#125;</div><div class="line">#div1 .top&#123;transform: rotateX(90deg) translateZ(100px);background: yellow;&#125;</div><div class="line">#div1 .bottom&#123;transform: rotateX(-90deg) translateZ(100px);background:orange;&#125;</div><div class="line"></div><div class="line">/*#div1:hover&#123;transform: perspective(800px) rotateX(-15deg) rotateY(360deg)&#125;*/</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">window.onload=function()&#123;</div><div class="line">	var oDiv=document.querySelector("#div1")</div><div class="line">	var bTop=bBotton=bLeft=bRight=false;</div><div class="line">	//左右 y</div><div class="line">	var y=0;</div><div class="line">	//上下</div><div class="line">	var x=0;</div><div class="line"></div><div class="line">	setInterval(function()&#123;</div><div class="line">		if(bLeft)&#123;</div><div class="line">			y-=10;</div><div class="line">		&#125;</div><div class="line">		if(bRight)&#123;</div><div class="line">			y+=10;</div><div class="line">		&#125;</div><div class="line">		if(bTop)&#123;</div><div class="line">			x-=10;</div><div class="line">		&#125;</div><div class="line">		if(bBotton)&#123;</div><div class="line">			x+=10;</div><div class="line">		&#125;</div><div class="line">		console.log(1)</div><div class="line">		oDiv.style.transform="perspective(800px) rotateX("+-x+"deg) rotateY("+y+"deg)"</div><div class="line">	&#125;,30)</div><div class="line"></div><div class="line">	document.onkeydown=function(ev)&#123;</div><div class="line">		if(ev.keyCode==37)&#123;</div><div class="line">			bLeft=true;</div><div class="line">		&#125;</div><div class="line">		if(ev.keyCode==38)&#123;</div><div class="line">			bTop=true;</div><div class="line">		&#125;</div><div class="line">		if(ev.keyCode==39)&#123;</div><div class="line">			bRight=true;</div><div class="line">		&#125;</div><div class="line">		if(ev.keyCode==40)&#123;</div><div class="line">			bBotton=true;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	document.onkeyup=function(ev)&#123;</div><div class="line">		if(ev.keyCode==37)&#123;</div><div class="line">			bLeft=false;</div><div class="line">		&#125;</div><div class="line">		if(ev.keyCode==38)&#123;</div><div class="line">			bTop=false;</div><div class="line">		&#125;</div><div class="line">		if(ev.keyCode==39)&#123;</div><div class="line">			bRight=false;</div><div class="line">		&#125;</div><div class="line">		if(ev.keyCode==40)&#123;</div><div class="line">			bBotton=false;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div id="div1"&gt;</div><div class="line">	&lt;div class="front"&gt;前面&lt;/div&gt;</div><div class="line">	&lt;div class="back"&gt;后面&lt;/div&gt;</div><div class="line">	&lt;div class="left"&gt;左面&lt;/div&gt;</div><div class="line">	&lt;div class="right"&gt;右面&lt;/div&gt;</div><div class="line">	&lt;div class="top"&gt;上面&lt;/div&gt;</div><div class="line">	&lt;div class="bottom"&gt;下面&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>鼠标控制3D盒子旋转：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta charset="UTF-8"&gt;</div><div class="line">&lt;title&gt;&lt;/title&gt;</div><div class="line">&lt;style type="text/css"&gt;</div><div class="line">*&#123;margin: 0;padding: 0;&#125;</div><div class="line">#div1&#123;position: relative;width: 200px;height: 200px;margin: 100px auto;line-height: 200px;text-align: center;font-size: 30px;</div><div class="line">	transform: perspective(800px) rotateX(45deg) rotateY(0deg);</div><div class="line">	transform-style: preserve-3d;</div><div class="line">	/*transition: 3s all ease;*/</div><div class="line">&#125;</div><div class="line">#div1 div&#123;position: absolute;left: 0;top: 0;width: 198px;height: 198px;border: 1px solid #000;background: yellow;&#125;</div><div class="line"></div><div class="line">#div1 .front&#123;transform: translateZ(100px);background: green;&#125;</div><div class="line">#div1 .back&#123;transform: translateZ(-100px);background: blue;&#125;</div><div class="line">#div1 .left&#123;transform: rotateY(-90deg) translateZ(100px);background: pink;&#125;</div><div class="line">#div1 .right&#123;transform: rotateY(90deg) translateZ(100px);background: red;&#125;</div><div class="line">#div1 .top&#123;transform: rotateX(90deg) translateZ(100px);background: yellow;&#125;</div><div class="line">#div1 .bottom&#123;transform: rotateX(-90deg) translateZ(100px);background:orange;&#125;</div><div class="line"></div><div class="line">/*#div1:hover&#123;transform: perspective(800px) rotateX(-15deg) rotateY(360deg)&#125;*/</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">window.onload=function()&#123;</div><div class="line">	var oDiv=document.querySelector("#div1")</div><div class="line">	//左右 y</div><div class="line">	var y=0;</div><div class="line">	//上下</div><div class="line">	var x=0;</div><div class="line">	document.onmousedown=function(ev)&#123;</div><div class="line">		var disX=ev.clientX-y;</div><div class="line">		var disY=ev.clientY-x;</div><div class="line"></div><div class="line">		document.onmousemove=function(ev)&#123;</div><div class="line">			y=ev.clientX-disX;</div><div class="line">			x=ev.clientY-disY;</div><div class="line">			oDiv.style.transform="perspective(800px) rotateX("+-x+"deg) rotateY("+y+"deg)"</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		document.onmouseup=function()&#123;</div><div class="line">			document.onmousemove=document.onmouseup=null;</div><div class="line">		&#125;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div id="div1"&gt;</div><div class="line">	&lt;div class="front"&gt;前面&lt;/div&gt;</div><div class="line">	&lt;div class="back"&gt;后面&lt;/div&gt;</div><div class="line">	&lt;div class="left"&gt;左面&lt;/div&gt;</div><div class="line">	&lt;div class="right"&gt;右面&lt;/div&gt;</div><div class="line">	&lt;div class="top"&gt;上面&lt;/div&gt;</div><div class="line">	&lt;div class="bottom"&gt;下面&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究3D盒子的旋转问题，今天来学习一下通过鼠标或者键盘控制3D盒子的旋转，效图：&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                
    
    </summary>
    
      <category term="HTML5" scheme="http://www.chenqiangyi.cn/categories/HTML5/"/>
    
    
      <category term="CSS3" scheme="http://www.chenqiangyi.cn/tags/CSS3/"/>
    
      <category term="HTML5" scheme="http://www.chenqiangyi.cn/tags/HTML5/"/>
    
  </entry>
  
</feed>
