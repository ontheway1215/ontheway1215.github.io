{"meta":{"title":"ChenBlog-chenqiangyi.cn","subtitle":"IT技术分享","description":"IT技术分享 ChenBlog-chenqiangyi.cn","author":"ontheway1215","url":"http://www.chenqiangyi.cn"},"pages":[{"title":"","date":"2017-06-21T07:58:16.000Z","updated":"2017-06-21T07:58:16.000Z","comments":true,"path":"404.html","permalink":"http://www.chenqiangyi.cn/404.html","excerpt":"","text":"404"},{"title":"404","date":"2017-06-21T08:35:04.000Z","updated":"2017-06-21T09:00:51.000Z","comments":true,"path":"404/index.html","permalink":"http://www.chenqiangyi.cn/404/index.html","excerpt":"","text":"这是一个404"},{"title":"","date":"2017-06-08T07:14:30.000Z","updated":"2017-06-08T10:27:34.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.chenqiangyi.cn/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-06-08T07:12:52.000Z","updated":"2017-06-08T10:25:15.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.chenqiangyi.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript中的递归","slug":"JavaScript中的递归","date":"2017-06-14T02:52:26.000Z","updated":"2017-06-14T14:25:11.000Z","comments":true,"path":"2017/06/14/JavaScript中的递归/","link":"","permalink":"http://www.chenqiangyi.cn/2017/06/14/JavaScript中的递归/","excerpt":"","text":"译者按: 程序员应该知道递归，但是你真的知道是怎么回事么？ 原文: All About Recursion, PTC, TCO and STC in JavaScript 译者: Fundebug 为了保证可读性，本文采用意译而非直译。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。 我们来举个例子，我们可以用4的阶乘乘以4来定义5的阶乘，3的阶乘乘以4来定义4的阶乘，以此类推。 123456factorial(5) = factorial(4) * 5factorial(5) = factorial(3) * 4 * 5factorial(5) = factorial(2) * 3 * 4 * 5factorial(5) = factorial(1) * 2 * 3 * 4 * 5factorial(5) = factorial(0) * 1 * 2 * 3 * 4 * 5factorial(5) = 1 * 1 * 2 * 3 * 4 * 5 用Haskell的Pattern matching 可以很直观的定义factorial函数: 12factorial n = factorial (n-1) * nfactorial 0 = 1 在递归的例子中，从第一个调用factorial(5)开始，一直递归调用factorial函数自身直到参数的值为0。下面是一个形象的图例： 递归的调用栈为了理解调用栈，我们回到factorial函数的例子。 123456function factorial(n) &#123; if (n === 0) &#123; return 1 &#125; return n * factorial(n - 1)&#125; 如果我们传入参数3，将会递归调用factorial(2)、factorial(1)和factorial(0)，因此会额外再调用factorial三次。 每次函数调用都会压入调用栈，整个调用栈如下: 1234factorial(0) // 0的阶乘为1factorial(1) // 该调用依赖factorial(0)factorial(2) // 该调用依赖factorial(1)factorial(3) // 该掉用依赖factorial(2) 现在我们修改代码，插入console.trace()来查看每一次当前的调用栈的状态： 12345678function factorial(n) &#123; console.trace() if (n === 0) &#123; return 1 &#125; return n * factorial(n - 1)&#125;factorial(3) 接下来我们看看调用栈是怎样的。 第一个： 1234567891011Trace at factorial (repl:2:9) at repl:1:1 // 请忽略以下底层实现细节代码 at realRunInThisContextScript (vm.js:22:35) at sigintHandlersWrap (vm.js:98:12) at ContextifyScript.Script.runInThisContext (vm.js:24:12) at REPLServer.defaultEval (repl.js:313:29) at bound (domain.js:280:14) at REPLServer.runBound [as eval] (domain.js:293:12) at REPLServer.onLine (repl.js:513:10) at emitOne (events.js:101:20) 你会发现，该调用栈包含一个对factorial函数的调用，这里是factorial(3)。接下来就更加有趣了，我们来看第二次打印出来的调用栈： 现在我们有两个对factorial函数的调用。 第三次： 1234567891011Trace at factorial (repl:2:9) at factorial (repl:7:12) at factorial (repl:7:12) at repl:1:1 at realRunInThisContextScript (vm.js:22:35) at sigintHandlersWrap (vm.js:98:12) at ContextifyScript.Script.runInThisContext (vm.js:24:12) at REPLServer.defaultEval (repl.js:313:29) at bound (domain.js:280:14) at REPLServer.runBound [as eval] (domain.js:293:12) 第四次： 1234567891011Trace at factorial (repl:2:9) at factorial (repl:7:12) at factorial (repl:7:12) at factorial (repl:7:12) at repl:1:1 at realRunInThisContextScript (vm.js:22:35) at sigintHandlersWrap (vm.js:98:12) at ContextifyScript.Script.runInThisContext (vm.js:24:12) at REPLServer.defaultEval (repl.js:313:29) at bound (domain.js:280:14) 设想，如果传入的参数值特别大，那么这个调用栈将会非常之大，最终可能超出调用栈的缓存大小而崩溃导致程序执行失败。那么如何解决这个问题呢？使用尾递归。 尾递归尾递归是一种递归的写法，可以避免不断的将函数压栈最终导致堆栈溢出。通过设置一个累加参数，并且每一次都将当前的值累加上去，然后递归调用。 我们来看如何改写之前定义factorial函数为尾递归： 123456function factorial(n, total = 1) &#123; if (n === 0) &#123; return total &#125; return factorial(n - 1, n * total)&#125; factorial(3)的执行步骤如下： 1234factorial(3, 1)factorial(2, 3)factorial(1, 6)factorial(0, 6) 调用栈不再需要多次对factorial进行压栈处理，因为每一个递归调用都不在依赖于上一个递归调用的值。因此，空间的复杂度为o(1)而不是0(n)。 接下来，通过console.trace()函数将调用栈打印出来。 12345678function factorial(n, total = 1) &#123; console.trace() if (n === 0) &#123; return total &#125; return factorial(n - 1, n * total)&#125;factorial(3) 很惊讶的发现，依然有很多压栈! 123456789101112131415161718192021222324// ...// 下面是最后两次对factorial的调用Trace at factorial (repl:2:9) // 3次压栈 at factorial (repl:7:8) at factorial (repl:7:8) at repl:1:1 // 请忽略以下底层实现细节代码 at realRunInThisContextScript (vm.js:22:35) at sigintHandlersWrap (vm.js:98:12) at ContextifyScript.Script.runInThisContext (vm.js:24:12) at REPLServer.defaultEval (repl.js:313:29) at bound (domain.js:280:14) at REPLServer.runBound [as eval] (domain.js:293:12)Trace at factorial (repl:2:9) // 最后第一调用再次压栈 at factorial (repl:7:8) at factorial (repl:7:8) at factorial (repl:7:8) at repl:1:1 // 请忽略以下底层实现细节代码 at realRunInThisContextScript (vm.js:22:35) at sigintHandlersWrap (vm.js:98:12) at ContextifyScript.Script.runInThisContext (vm.js:24:12) at REPLServer.defaultEval (repl.js:313:29) at bound (domain.js:280:14) 这是为什么呢？在Nodejs下面，我们可以通过开启strict mode, 并且使用–harmony_tailcalls来开启尾递归(proper tail call)。 123456789&apos;use strict&apos;function factorial(n, total = 1) &#123; console.trace() if (n === 0) &#123; return total &#125; return factorial(n - 1, n * total)&#125;factorial(3) 使用如下命令： 1node --harmony_tailcalls factorial.js 调用栈信息如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344Trace at factorial (/Users/stefanzan/factorial.js:3:13) at Object.&lt;anonymous&gt; (/Users/stefanzan/factorial.js:9:1) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.runMain (module.js:604:10) at run (bootstrap_node.js:394:7) at startup (bootstrap_node.js:149:9)Trace at factorial (/Users/stefanzan/factorial.js:3:13) at Object.&lt;anonymous&gt; (/Users/stefanzan/factorial.js:9:1) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.runMain (module.js:604:10) at run (bootstrap_node.js:394:7) at startup (bootstrap_node.js:149:9)Trace at factorial (/Users/stefanzan/factorial.js:3:13) at Object.&lt;anonymous&gt; (/Users/stefanzan/factorial.js:9:1) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.runMain (module.js:604:10) at run (bootstrap_node.js:394:7) at startup (bootstrap_node.js:149:9)Trace at factorial (/Users/stefanzan/factorial.js:3:13) at Object.&lt;anonymous&gt; (/Users/stefanzan/factorial.js:9:1) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.runMain (module.js:604:10) at run (bootstrap_node.js:394:7) at startup (bootstrap_node.js:149:9) 你会发现，不会在每次调用的时候压栈，只有一个factorial。 注意：尾递归不一定会将你的代码执行速度提高；相反，可能会变慢。不过，尾递归可以让你使用更少的内存，使你的递归函数更加安全 (前提是你要开启harmony模式)。","categories":[],"tags":[{"name":"Javascript 递归","slug":"Javascript-递归","permalink":"http://www.chenqiangyi.cn/tags/Javascript-递归/"}]},{"title":"vue键盘事件小技巧","slug":"vue键盘事件小技巧","date":"2017-05-10T14:04:01.000Z","updated":"2017-06-14T14:05:39.000Z","comments":true,"path":"2017/05/10/vue键盘事件小技巧/","link":"","permalink":"http://www.chenqiangyi.cn/2017/05/10/vue键盘事件小技巧/","excerpt":"","text":"最近用Vue做一个运营工具，需求是当在编辑完成的时候可以知接按住Alt+S提交表单并保存,查询vue文档发现尤大已经把常用的按键封装到框架中了，然而所有的绑定都必须在表单元素中进行，显然不符合我那个开发工具的需求，最后不断查文档，并没有找到相关的文章。最后只能用原生的keydown事件了，监听整个windowd,代码如下： 12345678910111213mounted() &#123; var that = this; document.onkeydown=function(e) &#123; if(e &amp;amp;&amp;amp; e.keyCode==83 &amp;amp;&amp;amp; e.altKey )&#123; //同时按下Alt+S that.submitBtn(e); &#125; &#125;&#125;,methods: &#123; submitBtn(e) &#123; //相关函数 &#125;&#125; 然后就总结一下vue中的键盘事件： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el:&apos;#box&apos;, methods:&#123; show:function(ev)&#123; if(ev.keyCode == 13)&#123; alert(&apos;你按回车键了&apos;); &#125; &#125;, &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入&quot; @keyup=&quot;show($event)&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入&quot; @keyup.13=&quot;show($event)&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; .enter .tab .delete&nbsp;(捕获 “删除” 和 “退格” 键) .esc .space .up .down .left .right 可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应 .ctrl .alt .shift .meta 注意：在Mac系统键盘上，meta对应命令键 (⌘)。在Windows系统键盘meta对应windows徽标键(⊞)。在Sun操作系统键盘上，meta对应实心宝石键 (◆)。在其他特定键盘上，尤其在MIT和Lisp键盘及其后续，比如Knight键盘，space-cadet键盘，meta被标记为“META”。在Symbolics键盘上，meta被标记为“META” 或者 “Meta”。 例如: 12345&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=&quot;clear&quot;&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenqiangyi.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenqiangyi.cn/tags/JavaScript/"},{"name":"vue","slug":"vue","permalink":"http://www.chenqiangyi.cn/tags/vue/"},{"name":"键盘事件","slug":"键盘事件","permalink":"http://www.chenqiangyi.cn/tags/键盘事件/"}]},{"title":"ES6新特性总结","slug":"ES6新特性总结","date":"2017-04-25T04:28:31.000Z","updated":"2017-06-14T11:33:54.000Z","comments":true,"path":"2017/04/25/ES6新特性总结/","link":"","permalink":"http://www.chenqiangyi.cn/2017/04/25/ES6新特性总结/","excerpt":"","text":"ES6语法已经出来很久了，为了加强学习和记忆，总结一下ES6中出现的新特性，参考文章http://es6.ruanyifeng.com/。 箭头函数function() 函数的简写表示法，但它不绑定 this。 ES6 代码: 123456789var odds = evens.map(v =&amp;gt; v + 1); // no parentes and no bracketsvar nums = evens.map((v, i) =&amp;gt; v + i);var pairs = evens.map(v =&amp;gt; (&#123;even: v, odd: v + 1&#125;));// Statement bodiesnums.forEach(v =&amp;gt; &#123; if (v % 5 === 0) fives.push(v);&#125;); this是如何工作的ES6 代码: 1234567891011121314var object = &#123; name: &quot;Name&quot;, arrowGetName: () =&amp;gt; this.name, regularGetName: function() &#123; return this.name &#125;, arrowGetThis: () =&amp;gt; this, regularGetThis: function() &#123; return this &#125;&#125;console.log(object);console.log(object.name)console.log(object.arrowGetName());console.log(object.arrowGetThis());console.log(this);console.log(object.regularGetName());console.log(object.regularGetThis()); 结果： 12345678910111213141516171819202122232425262728293031323334353637383940console.log(object);Object &#123; name: &quot;Name&quot;, arrowGetName: function, regularGetName: function, arrowGetThis: function, regularGetThis: function&#125;console.log(object.name) ;Nameconsole.log(object.arrowGetName());undefinedconsole.log(object.arrowGetThis()); // [object Window]Window &#123; stop: function, open: function, alert: function, confirm: function, prompt: function, ...&#125;console.log(this); 同上console.log(object.regularGetName());Nameconsole.log(object.regularGetThis());Object &#123; name: &quot;Name&quot;, arrowGetName: function, regularGetName: function, arrowGetThis: function, regularGetThis: function&#125; 我们知道“真正”语言中的类(Classes)。在 ES6 中类(Classes)其实是原型继承的语法糖。 ES6代码 1234567891011121314151617181920212223class SkinnedMesh extends THREE.Mesh &#123; constructor(geometry, materials) &#123; super(geometry, materials); this.idMatrix = SkinnedMesh.defaultMatrix(); this.bones = []; this.boneMatrices = []; //... &#125; update(camera) &#123; //... super.update(); &#125; get boneCount() &#123; return this.bones.length; &#125; set matrixType(matrixType) &#123; this.idMatrix = SkinnedMesh[matrixType](); &#125; static defaultMatrix() &#123; return new THREE.Matrix4(); &#125;&#125; 增强的对象字面量ES6代码 123456789101112131415161718192021222324var theProtoObj = &#123; toString: function() &#123; return &quot;The ProtoOBject To string&quot; &#125;&#125;var handler = () =&amp;gt; &quot;handler&quot;var obj = &#123; // __proto__ __proto__: theProtoObj, // Shorthand for ‘handler: handler’ handler, // Methods toString() &#123; // Super calls return &quot;d &quot; + super.toString(); &#125;, // Computed (dynamic) property names [ &quot;prop_&quot; + (() =&amp;gt; 42)() ]: 42&#125;;console.log(obj.handler)console.log(obj.handler())console.log(obj.toString())console.log(obj.prop_42) 结果： 123456789obj.handler // () =&amp;gt; &quot;handler&quot;obj.handler() // handlerobj.toString() // d The ProtoOBject To stringobj.prop_42 //(() =&amp;gt; 42)() 是一个立即执行函数 (() =&amp;gt; 42)() 相当于(function() &#123; return 42;&#125;)()42 字符串插值123456var name = &quot;Bob&quot;, time = &quot;today&quot;;var multiLine = `This Line Spans Multiple Lines`；console.log(`Hello $&#123;name&#125;,how are you $&#123;time&#125;?`)console.log(multiLine) 结果： 12a // 1b // 3 对象也能很好的解构12345nodes = () =&gt; &#123; return &#123;op: &quot;a&quot;, lhs: &quot;b&quot;, rhs: &quot;c&quot;&#125;&#125;var &#123; op: a, lhs: b , rhs: c &#125; = nodes()console.log(a)console.log(b)console.log(c) ##结果： 123a // ab // bc // c 使用速记表示法12345678nodes = () =&gt; &#123; return &#123;lhs: &quot;a&quot;, op: &quot;b&quot;, rhs: &quot;c&quot;&#125;&#125;// binds `op`, `lhs` and `rhs` in scopevar &#123;op, lhs, rhs&#125; = nodes()console.log(op)console.log(lhs)console.log(rhs) 结果： 123op // blhs // arhs // c 可在参数位置使用12345678910function g(&#123;name: x&#125;) &#123; return x&#125;function m(&#123;name&#125;) &#123; return name&#125;console.log(g(&#123;name: 5&#125;))console.log(m(&#123;name: 5&#125;)) 结果： 12g(&#123;name: 5&#125;) // 5m(&#123;name: 5&#125;) // 5 故障弱化解构123456var [a] = []var [b = 1] = []var c = [];console.log(a)console.log(b);console.log(c); 结果： 123a // undefinedb // 1c // [] 参数默认值（Default）123456function f(x, y=12) &#123; return x + y;&#125;console.log(f(3))console.log(f(3,2)) 结果： 12f(3) // 15f(3,2) // 5 扩展（Spread）在函数中 12345function f(x, y, z) &#123; return x + y + z;&#125;// 传递数组的每个元素作为参数console.log(f(...[1,2,3])) ##结果： 1f(...[1,2,3]) // 6 在数组中1234var parts = [&quot;shoulders&quot;, &quot;knees&quot;];var lyrics = [&quot;head&quot;, ...parts, &quot;and&quot;, &quot;toes&quot;];console.log(lyrics) 结果： 1234var parts = [&quot;shoulders&quot;, &quot;knees&quot;];var lyrics = [&quot;head&quot;, ...parts, &quot;and&quot;, &quot;toes&quot;];console.log(lyrics) 结果： 1lyrics // [&quot;head&quot;,&quot;shoulders&quot;,&quot;knees&quot;,&quot;and&quot;,&quot;toes&quot;] 扩展 + 对象字面量我们可以使用这个创造很酷的对象。 123456789101112let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;console.log(x); // 1console.log(y); // 2console.log(z); // &#123; a: 3, b: 4 &#125;// Spread propertieslet n = &#123; x, y, ...z &#125;;console.log(n); // &#123; x: 1, y: 2, a: 3, b: 4 &#125;console.log(obj)可惜的是它还不支持：npm install --save-dev babel-plugin-transform-object-rest-spread Rest我们可以使用 rest 操作符来允许无限参数。 12345function demo(part1, ...part2) &#123; return &#123;part1, part2&#125;&#125;console.log(demo(1,2,3,4,5,6)) 结果： 1demo(1,2,3,4,5,6) // &#123;&quot;part1&quot;:1,&quot;part2&quot;:[2,3,4,5,6]&#125; Letlet是新的var。 因为它有块级作用域。 12345678910&#123; var globalVar = &quot;from demo1&quot;&#125;&#123; let globalLet = &quot;from demo2&quot;;&#125;console.log(globalVar)console.log(globalLet) 结果： 12globalVar // from demo1globalLet // ReferenceError: globalLet is not defined 但是，它不会向window分配任何内容： 12345let me = &quot;go&quot;; // 全局作用域var i = &quot;able&quot;; // 全局作用域console.log(window.me);console.log(window.i); 12window.me // undefinedwindow.i // able 不能使用let重新声明一个变量： 123let me = &quot;foo&quot;;let me = &quot;bar&quot;;console.log(me); 结果：1SyntaxError: Identifier &apos;me&apos; has already been declared 123var me = &quot;foo&quot;;var me = &quot;bar&quot;;console.log(me) 结果： 1me // bar Constconst 是只读变量。 12const a = &quot;b&quot;a = &quot;a&quot; 结果： 1TypeError: Assignment to constant variable. const 对象仍然可以被改变的。 123const a = &#123; a: &quot;a&quot; &#125;a.a = &quot;b&quot;console.log(a) 结果： 1a // &#123;&quot;a&quot;:&quot;b&quot;&#125; For..of迭代器的新类型，可以替代for..in。它返回的是值而不是keys 12345let list = [4, 5, 6];console.log(list)for (let i in list) &#123; console.log(i);&#125; 结果： 1234list // [4,5,6]i // 0i // 1i // 2 12345let list = [4, 5, 6];console.log(list)for (let i of list) &#123; console.log(i);&#125; 结果： 1234list // [4,5,6]i // 4i // 5i // 6 迭代器（Iterators）迭代器是一个比数组更动态的类型。 1234567891011121314151617181920let infinite = &#123; [Symbol.iterator]() &#123; let c = 0; return &#123; next() &#123; c++; return &#123; done: false, value: c &#125; &#125; &#125; &#125;&#125;console.log(&quot;start&quot;);for (var n of infinite) &#123; // truncate the sequence at 1000 if (n &amp;gt; 10) break; console.log(n);&#125; 结果： 1234567891011&quot;start&quot; // startn // 1n // 2n // 3n // 4n // 5n // 6n // 7n // 8n // 9n // 10 使用Typescript，我们可以看到它接口的样子： 1234567891011Typescript 代码:interface IteratorResult &#123; done: boolean; value: any;&#125;interface Iterator &#123; next(): IteratorResult;&#125;interface Iterable &#123; [Symbol.iterator](): Iterator&#125; 生成器（Generators）生成器创建迭代器，并且比迭代器更具动态性。他们不必以相同的方式跟踪状态 并不支持 done 的概念。 12345678910111213141516var infinity = &#123; [Symbol.iterator]: function*() &#123; var c = 1; for (;;) &#123; yield c++; &#125; &#125;&#125;console.log(&quot;start&quot;)for (var n of infinity) &#123; // truncate the sequence at 1000 if (n &amp;gt; 10) break; console.log(n);&#125; 结果： 1234567891011&quot;start&quot; // startn // 1n // 2n // 3n // 4n // 5n // 6n // 7n // 8n // 9n // 10 使用Typescript 再次显示接口： Typescript 代码:1234interface Generator extends Iterator &#123; next(value?: any): IteratorResult; throw(exception: any);&#125; function* Iterators and generator一个产量的例子 12345678910111213141516171819function* anotherGenerator(i) &#123; yield i + 1; yield i + 2; yield i + 3;&#125;function* generator(i) &#123; yield i; yield* anotherGenerator(i); yield i + 10;&#125;var gen = generator(10);console.log(gen.next().value);console.log(gen.next().value);console.log(gen.next().value);console.log(gen.next().value);console.log(gen.next().value); 结果： 12345gen.next().value // 10gen.next().value // 11gen.next().value // 12gen.next().value // 13gen.next().value // 20 UnicodeES6 为Unicode 提供了更好的支持。 12345var regex = new RegExp(&apos;\\u&#123;61&#125;&apos;, &apos;u&apos;);console.log(regex.unicode)console.log(&quot;\\uD842\\uDFD7&quot;)console.log(&quot;\\uD842\\uDFD7&quot;.codePointAt()) 结果： 123regex.unicode // true&quot;&quot; //&quot;&quot;.codePointAt() // 134103 模块和模块加载器原生支持模块。 123456789101112131415161718192021222324import defaultMember from &quot;module-name&quot;;import * as name from &quot;module-name&quot;;import &#123; member &#125; from &quot;module-name&quot;;import &#123; member as alias &#125; from &quot;module-name&quot;;import &#123; member1 , member2 &#125; from &quot;module-name&quot;;import &#123; member1 , member2 as alias2 , [...] &#125; from &quot;module-name&quot;;import defaultMember, &#123; member [ , [...] ] &#125; from &quot;module-name&quot;;import defaultMember, * as name from &quot;module-name&quot;;import &quot;module-name&quot;;export &#123; name1, name2, …, nameN &#125;;export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;export let name1, name2, …, nameN; // also varexport let name1 = …, name2 = …, …, nameN; // also var, constexport expression;export default expression;export default function (…) &#123; … &#125; // also class, function*export default function name1(…) &#123; … &#125; // also class, function*export &#123; name1 as default, … &#125;;export * from …;export &#123; name1, name2, …, nameN &#125; from …;export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;Import Export SetSet 为数学对应，其中所有项目都是唯一的。对于知道SQL的人来说，这相当于distinct。 12345678var set = new Set();set.add(&quot;Potato&quot;).add(&quot;Tomato&quot;).add(&quot;Tomato&quot;);console.log(set.size)console.log(set.has(&quot;Tomato&quot;))for(var item of set) &#123; console.log(item)&#125; 结果 1234set.size // 2set.has(&quot;Tomato&quot;) // trueitem // Potatoitem // Tomato WeakSetWeakSet对象允许您在集合中存储弱持有的对象。没有引用的对象将被垃圾回收。 12345678910var item = &#123; a:&quot;Potato&quot;&#125;var set = new WeakSet();set.add(&#123; a:&quot;Potato&quot;&#125;).add(item).add(&#123; a:&quot;Tomato&quot;&#125;).add(&#123; a:&quot;Tomato&quot;&#125;);console.log(set.size)console.log(set.has(&#123;a:&quot;Tomato&quot;&#125;))console.log(set.has(item))for(let item of set) &#123; console.log(item)&#125; 结果： 1234set.size // undefinedset.has(&#123;a:&quot;Tomato&quot;&#125;) // falseset.has(item) // trueTypeError: set[Symbol.iterator] is not a function MapMap也称词典 12345678910111213var map = new Map();map.set(&quot;Potato&quot;, 12);map.set(&quot;Tomato&quot;, 34);console.log(map.get(&quot;Potato&quot;))for(let item of map) &#123; console.log(item)&#125;for(let item in map) &#123; console.log(item)&#125; 结果： 123map.get(&quot;Potato&quot;) // 12item // [&quot;Potato&quot;,12]item // [&quot;Tomato&quot;,34] 可以使用除字符串之外的其他类型。 123456var map = new Map();var key = &#123;a: &quot;a&quot;&#125;map.set(key, 12);console.log(map.get(key))console.log(map.get(&#123;a: &quot;a&quot;&#125;)) 结果 12map.get(key) // 12map.get(&#123;a: &quot;a&quot;&#125;) // undefined WeakMap使用键的对象，并且只保留对键的弱引用。 123456789101112131415161718192021222324var wm = new WeakMap();var o1 = &#123;&#125;var o2 = &#123;&#125;var o3 = &#123;&#125;wm.set(o1, 1);wm.set(o2, 2);wm.set(o3, &#123;a: &quot;a&quot;&#125;);wm.set(&#123;&#125;, 4);console.log(wm.get(o2));console.log(wm.has(&#123;&#125;))delete o2;console.log(wm.get(o3));for(let item in wm) &#123; console.log(item)&#125;for(let item of wm) &#123; console.log(item)&#125; 结果 1234wm.get(o2) // 2wm.has(&#123;&#125;) // falsewm.get(o3) // &#123;&quot;a&quot;:&quot;a&quot;&#125;TypeError: wm[Symbol.iterator] is not a function 代理（Proxy）代理可以用来改变对象的行为。 它们允许我们定义 trap 。 123456789101112131415161718var obj = function ProfanityGenerator() &#123; return &#123; words: &quot;Horrible words&quot; &#125;&#125;()var handler = function CensoringHandler() &#123; return &#123; get: function (target, key) &#123; return target[key].replace(&quot;Horrible&quot;, &quot;Nice&quot;); &#125;, &#125;&#125;()var proxy = new Proxy(obj, handler);console.log(proxy.words); 结果 1proxy.words // Nice words 提供以下 trap ： 1234567891011121314151617var handler =&#123; get:..., set:..., has:..., deleteProperty:..., apply:..., construct:..., getOwnPropertyDescriptor:..., defineProperty:..., getPrototypeOf:..., setPrototypeOf:..., enumerate:..., ownKeys:..., preventExtensions:..., isExtensible:...&#125; Symbols 是一个新类型。 可用于创建匿名属性。 1234567891011121314151617181920var typeSymbol = Symbol(&quot;type&quot;);class Pet &#123; constructor(type) &#123; this[typeSymbol] = type; &#125; getType() &#123; return this[typeSymbol]; &#125;&#125;var a = new Pet(&quot;dog&quot;);console.log(a.getType());console.log(Object.getOwnPropertyNames(a))console.log(Symbol(&quot;a&quot;) === Symbol(&quot;a&quot;)) 结果： 123a.getType() // dogObject.getOwnPropertyNames(a) // []Symbol(&quot;a&quot;) === Symbol(&quot;a&quot;) // false 可继承内置函数我们现在可以继承原生类 12345678class CustomArray extends Array &#123;&#125;var a = new CustomArray();a[0] = 2console.log(a[0]) 结果： 1a[0] // 2 不能使用数组的代理(Proxy)来覆盖getter函数。 新类库各种新的方法和常量 123456789101112131415161718192021console.log(Number.EPSILON)console.log(Number.isInteger(Infinity))console.log(Number.isNaN(&quot;NaN&quot;))console.log(Math.acosh(3))console.log(Math.hypot(3, 4))console.log(Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2))console.log(&quot;abcde&quot;.includes(&quot;cd&quot;) )console.log(&quot;abc&quot;.repeat(3) )console.log(Array.of(1, 2, 3) )console.log([0, 0, 0].fill(7, 1) )console.log([1, 2, 3].find(x =&amp;gt; x == 3) )console.log([1, 2, 3].findIndex(x =&amp;gt; x == 2))console.log([1, 2, 3, 4, 5].copyWithin(3, 0))console.log([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() )console.log([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() )console.log([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() )console.log(Object.assign(&#123;&#125;, &#123; origin: new Point(0,0) &#125;)) 结果： 123456789101112131415161718Number.EPSILON // 2.220446049250313e-16Number.isInteger(Infinity) // falseNumber.isNaN(&quot;NaN&quot;) // falseMath.acosh(3) // 1.7627471740390859Math.hypot(3, 4) // 5Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2&quot;abcde&quot;.includes(&quot;cd&quot;) // true&quot;abc&quot;.repeat(3) // abcabcabcArray.of(1, 2, 3) // [1,2,3][0, 0, 0].fill(7, 1) // [0,7,7][1, 2, 3].find(x =&amp;gt; x == 3) // 3[1, 2, 3].findIndex(x =&amp;gt; x == 2) // 1[1, 2, 3, 4, 5].copyWithin(3, 0) // [1,2,3,1,2][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // &#123;&#125;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // &#123;&#125;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // TypeError: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;].values is not a functionObject.assign(&#123;&#125;, &#123; origin: new Point(0,0) &#125;) // ReferenceError: Point is not defined文档: Number, Math, Array.from, Array.of, Array.prototype.copyWithin, Object.assign 二进制和八进制二进制和八进制数字的字面量。 1234console.log(0b11111)console.log(0o2342)console.log(0xff); // also in es5 结果： ES6 代码:1230b11111 // 310o2342 // 12500xff // 255 Promises异步编程。 1234567891011121314var p1 = new Promise((resolve, reject) =&amp;gt; &#123; setTimeout(() =&amp;gt; resolve(&quot;1&quot;), 101)&#125;)var p2 = new Promise((resolve, reject) =&amp;gt; &#123; setTimeout(() =&amp;gt; resolve(&quot;2&quot;), 100)&#125;)Promise.race([p1, p2]).then((res) =&amp;gt; &#123; console.log(res)&#125;)Promise.all([p1, p2]).then((res) =&amp;gt; &#123; console.log(res)&#125;) 结果： 12res // 2res // [&quot;1&quot;,&quot;2&quot;] 快速的Promise123456var p1 = Promise.resolve(&quot;1&quot;)var p2 = Promise.reject(&quot;2&quot;)Promise.race([p1, p2]).then((res) =&amp;gt; &#123; console.log(res)&#125;) 结果： 1res // 1 快速失败如果一个 promise 失败，all和race也将 reject(拒绝)。 123456789101112131415161718var p1 = new Promise((resolve, reject) =&amp;gt; &#123; setTimeout(() =&amp;gt; resolve(&quot;1&quot;), 1001)&#125;)var p2 = new Promise((resolve, reject) =&amp;gt; &#123; setTimeout(() =&amp;gt; reject(&quot;2&quot;), 1)&#125;)Promise.race([p1, p2]).then((res) =&amp;gt; &#123; console.log(&quot;success&quot; + res)&#125;, res =&amp;gt; &#123; console.log(&quot;error &quot; + res)&#125;)Promise.all([p1, p2]).then((res) =&amp;gt; &#123; console.log(&quot;success&quot; + res)&#125;, res =&amp;gt; &#123; console.log(&quot;error &quot; + res)&#125;) 结果： 12&quot;error &quot; + res // error 2&quot;error &quot; + res // error 2 反射（Reflect）新类型的元编程与新的API现有的还有一些新的方法。 12345678910var z = &#123;w: &quot;Super Hello&quot;&#125;var y = &#123;x: &quot;hello&quot;, __proto__: z&#125;;console.log(Reflect.getOwnPropertyDescriptor(y, &quot;x&quot;));console.log(Reflect.has(y, &quot;w&quot;));console.log(Reflect.ownKeys(y, &quot;w&quot;));console.log(Reflect.has(y, &quot;x&quot;));console.log(Reflect.deleteProperty(y,&quot;x&quot;))console.log(Reflect.has(y, &quot;x&quot;)); 结果： 123456Reflect.getOwnPropertyDescriptor(y, &quot;x&quot;) // &#123;&quot;value&quot;:&quot;hello&quot;,&quot;writable&quot;:true,&quot;enumerable&quot;:true,&quot;configurable&quot;:true&#125;Reflect.has(y, &quot;w&quot;) // trueReflect.ownKeys(y, &quot;w&quot;) // [&quot;x&quot;]Reflect.has(y, &quot;x&quot;) // trueReflect.deleteProperty(y,&quot;x&quot;) // trueReflect.has(y, &quot;x&quot;) // false 尾调用(Tail Call)优化尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 ES6可以确保尾调用不会造成堆栈溢出。 （不是所有的实现工作）。 12345678910function factorial(n, acc = 1) &#123; if (n &amp;lt;= 1) return acc; return factorial(n - 1, n * acc);&#125;console.log(factorial(10))console.log(factorial(100))console.log(factorial(1000))console.log(factorial(10000))console.log(factorial(100000))console.log(factorial(1000000)) 结果： 123456factorial(10) // 3628800factorial(100) // 9.332621544394418e+157factorial(1000) // Infinityfactorial(10000) // Infinityfactorial(100000) // RangeError: Maximum call stack size exceededfactorial(1000000) // RangeError: Maximum call stack size exceeded","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenqiangyi.cn/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.chenqiangyi.cn/tags/ES6/"}]},{"title":"hexo 常用命令","slug":"hexo-常用命令","date":"2017-03-15T16:19:46.000Z","updated":"2017-06-15T17:24:04.000Z","comments":true,"path":"2017/03/16/hexo-常用命令/","link":"","permalink":"http://www.chenqiangyi.cn/2017/03/16/hexo-常用命令/","excerpt":"","text":"hexo123npm install hexo -g #安装npm update hexo -g #升级hexo init #初始化 简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate #生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy #部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义IP hexo clean #清除缓存 网页正常情况下可以忽略词条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动123两个命令的作用是相同的hexo generate --deployhexo deploy --generate hexo deploy -g hexo server -g 草稿hexo publish [layout] &lt;title&gt; 模板hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000, ‘ctrl + c’关闭server） hexo deploy #将.deploy目录部署到Github hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --chen 变量 描述 layout 布局 title 标题 date 文件建立日期 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模板（Scaffold）hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要1以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作hexo new page &lt;title&gt; hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上hexo n #写文章 hexo g #生成 hexo d #部署 可与 hexo g 合并为 hexo d -g 一般部署步骤： hexo clean hexo d -g 报错找不到git部署1ERROR Deployer not found: git 解决方法 npm install hexo-deployer-git --save 部署类型设置githexo 3.0 部署类型不再是github, _config.yml 中修改 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master xcodebuild1xcode-select: error: tool &apos;xcodebuild&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instance npm install bcrypt RSS 不显示安装RSS插件npm install hexo-generator-feed --save 开启RSS功能编辑hexo/_config.yml，添加如下代码： 1rss: /atom.xml #rss地址 默认即可 开启评论多说已被关闭，推荐使用网易云 编辑theme目录下的_config.yml,添加如下代码 1angyi_ygt: 506ecdd478bc49caab66fa9b5144 #这个为网易云申请的key 相关文章： hexo官网","categories":[{"name":"hexo 常用命令","slug":"hexo-常用命令","permalink":"http://www.chenqiangyi.cn/categories/hexo-常用命令/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.chenqiangyi.cn/tags/hexo/"}]},{"title":"call与apply详解","slug":"call与apply详解","date":"2017-02-14T07:45:29.000Z","updated":"2017-06-14T11:40:40.000Z","comments":true,"path":"2017/02/14/call与apply详解/","link":"","permalink":"http://www.chenqiangyi.cn/2017/02/14/call与apply详解/","excerpt":"","text":"JS apply和js call方法总是让初学者困惑，下文就apply和call的区别，什么情况下用apply,什么情况下用call、apply的巧妙用法来阐述js apply和js call方法的详细使用方法。 call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。因为 JavaScript 的函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。二者的作用完全一样，只是接受参数的方式不太一样。例如，有一个函数 func1 定义如下：1var func1 = function(arg1, arg2) &#123;&#125;; 就可以通过 1func1.call(this, arg1, arg2); 或者 1func1.apply(this, [arg1, arg2]); 来调用。其中 this 是你想指定的上下文，他可以任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时，用 call，而不确定的时候，用apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments这个数组来便利所有的参数。 # 在javascript OOP中，我们经常会这样定义： 123456789function cat() &#123; &#125;cat.prototype = &#123; food: \"fish\", say: function()&#123; alert(\"I love \"+this.food); &#125;&#125;var blackCat = new cat;blackCat.say(); 但是如果我们有一个对象1whiteDog = &#123;food:\"bone\"&#125; 我们不想对它重新定义say方法，那么我们可以通过call或apply用blackCat的say方法：blackCat.say.call(whiteDog);所以,可以看出call和apply是为了动态改变this而出现的，当一个object没有某个方法,但是其他的有，我们可以借助call或apply用其它对象的方法来操作。用的比较多的，通过document.getElementsByTagName选择的dom 节点是一种类似array的array。它不能应用Array下的push,pop等方法。我们可以通过： 1var domNodes = Array.prototype.slice.call(document.getElementsByTagName(\"*\")); 这样domNodes就可以应用Array下的所有方法了。 12obj.call(thisObj, arg1, arg2, ...);obj.apply(thisObj, [arg1, arg2, ...]); 两者作用一致，都是把obj(即this)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj『继承』了obj的属性和方法。唯一区别是apply接受的是数组参数，call接受的是连续参数。 1234567function add(j, k)&#123; return j+k;&#125;function sub(j, k)&#123; return j-k;&#125; 我们在控制台运行： 1234567add(5,3); //8add.call(sub, 5, 3); //8add.apply(sub, [5, 3]); //8sub(5, 3); //2sub.call(add, 5, 3); //2sub.apply(add, [5, 3]); //2 通过call和apply，我们可以实现对象继承。示例： 12345678var Parent = function()&#123; this.name = \"yjc\"; this.age = 22;&#125;var child = &#123;&#125;;console.log(child);//Object &#123;&#125; ,空对象Parent.call(child);console.log(child); //Object &#123;name: \"yjc\", age: 22&#125; 以上实现了对象的继承。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenqiangyi.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenqiangyi.cn/tags/JavaScript/"},{"name":"call","slug":"call","permalink":"http://www.chenqiangyi.cn/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://www.chenqiangyi.cn/tags/apply/"}]},{"title":"垂直水平居中总结","slug":"垂直水平居中总结","date":"2017-01-08T10:48:00.000Z","updated":"2017-06-14T06:39:03.000Z","comments":true,"path":"2017/01/08/垂直水平居中总结/","link":"","permalink":"http://www.chenqiangyi.cn/2017/01/08/垂直水平居中总结/","excerpt":"","text":"既然写到flex布局了，那就总结一下垂直水平居中遇到的问题吧 宽高不定，上下左右垂直居中。transform绝对定位top left 各50%，然后 transform 负数撑回来 代码如下： HTML代码 1&lt;div class=&quot;toast&quot;&gt;提交成功&lt;/div&gt; CSS代码 1234567891011.toast &#123; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 13px 16px; font-size: 14px; color: #ccc; background-color: rgba(37, 38, 45, 0.9); border-radius: 2px;&#125; 效果图： But !这时候产品突然需要增加一个需求，Toast 组件一行最多只能有12个中文字符，超过的时候折行 看起来这个要求也不高 ~ 我们修改一下代码 CSS 1234567891011121314.toast &#123; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 13px 16px; font-size: 14px; color: #ccc; background-color: rgba(37, 38, 45, 0.9); border-radius: 2px; // 新增代码如下 width: auto; max-width: 12em;&#125; 效果如下图 可以看到，最终实现效果在第 9 个字的时候便折行了。这是为什么呢？我们把 1transform: translate(-50%, -50%) 去掉看一下 可以看到容器宽度在到达屏幕边界的时候就被截断折行了。现在我们设定 left: 90% 看一下 可以明显的看到容器被截断的更加严重。 至此我们分析得知，设置为 position: fixed 的元素不仅位置是相对于屏幕边界定位，如果不指定元素宽高的话，宽高同样也会相对于屏幕边界被截断。 那么如何解决这个问题呢 ~ 代码如下 ~ HTML： 123&lt;div class=&quot;toast-container&quot;&gt; &lt;div class=&quot;toast&quot;&gt;测试十二个字提交成功状态&lt;/div&gt;&lt;/div&gt; CSS 1234567891011121314151617181920.toast-container &#123; position: fixed; width: 100%; height: 100%; left: 100%; top: 100%;&#125;.toast &#123; position: absolute; top: -50%; left: -50%; transform: translate(-50%, -50%); width: auto; max-width: 12em; padding: 13px 16px; font-size: 14px; color: #ccc; background-color: rgba(37, 38, 45, 0.9); border-radius: 2px;&#125; 在 .toast 外加一个和屏幕宽高相同 .container 容器，将 .container 容器 fixed 定位到窗口外层，再将 .toast 通过 absolute 定位翻转过来即可。 效果如下: 用white-space:nowrap代码： HTML 1&lt;div class=&quot;toast&quot;&gt;提交成功提交成功提交成功&lt;/div&gt; CSS 1234567891011121314.toast &#123; position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); padding: 13px 16px; font-size: 14px; color: #ccc; background-color: rgba(37, 38, 45, 0.9); border-radius: 2px; width: auto; max-width: 12em; white-space:nowrap ;&#125; 效果","categories":[{"name":"垂直水平居中","slug":"垂直水平居中","permalink":"http://www.chenqiangyi.cn/categories/垂直水平居中/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.chenqiangyi.cn/tags/css/"},{"name":"flex","slug":"flex","permalink":"http://www.chenqiangyi.cn/tags/flex/"},{"name":"垂直水平居中","slug":"垂直水平居中","permalink":"http://www.chenqiangyi.cn/tags/垂直水平居中/"}]},{"title":"flex布局详解","slug":"flex布局详解","date":"2017-01-08T08:09:18.000Z","updated":"2017-06-14T11:31:41.000Z","comments":true,"path":"2017/01/08/flex布局详解/","link":"","permalink":"http://www.chenqiangyi.cn/2017/01/08/flex布局详解/","excerpt":"","text":"好久没写东西了，既然定了每周一篇文章的计划，就要确保认真完成，这就当做是新年的第一篇文章吧！ 最近在做微信小程序，微信小程序中的wxss中的布局用的flex布局，今天来总结一下flex布局。 Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上 -webkit 前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为Flex布局以后，子元素的float clear 和 vertical-align属性将失效。 基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 (默认)：不换行。 换行，第一行在上方。 换行，第一行在下方。 flex-flowflex-flow属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &amp;lt;flex-direction&amp;gt; || &amp;lt;flex-wrap&amp;gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items 属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self order属性属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &amp;lt;integer&amp;gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &amp;lt;number&amp;gt;; /* default 0 */&#125;","categories":[{"name":"css","slug":"css","permalink":"http://www.chenqiangyi.cn/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.chenqiangyi.cn/tags/css/"},{"name":"flex","slug":"flex","permalink":"http://www.chenqiangyi.cn/tags/flex/"}]},{"title":"回首2016，展望2017","slug":"回首2016，展望2017","date":"2016-12-31T17:58:18.000Z","updated":"2017-06-14T05:05:55.000Z","comments":true,"path":"2017/01/01/回首2016，展望2017/","link":"","permalink":"http://www.chenqiangyi.cn/2017/01/01/回首2016，展望2017/","excerpt":"","text":"本来是打算在年末写年度总结，结果就一直拖，一下拖到现在。一直说没时间其实就是懒。在去年年末的时候在知乎上看到好多人写的年度总结以及新的一年的展望，自己当时没有写，现在2016年结束了，总感觉少了点什么，大概就是当时年初没有定目标造成的空落感，所以今年加班也一定要把年度总结写完。本文分两部分，一部分回首2016年的种种，另一部分展望2017年，并制定年度计划。 一、回首过去 2016年初来的上海，在这里实习，学习，以及毕业找工作，期间结束了大学生活，走上了社会。在6月份的时候加入到了现在的公司，来到公司后先是熟悉公司所用的框架以及工作流程，后期慢慢开始进行对官网的升级以及修改。再往后就做了一个礼物直播的管理系统，再后来就是完成了支付宝表情搜搜的小程序，以及现在表情搜搜官网的设计与修改，还有未完成的表情搜搜微信小程序。在工作中学到了一些新技术，然而在做支付宝小程序的时候由于自己技术的不足造成了项目的进展缓慢，在这期间也学到了许多。后期就是微信小程序，现在还没开始动手，在最近几天将着手微信小程序。对于工作，由于官网框架的缘故，使得一些新的技术无法使用。在今后的新项目中要多使用新技术，使得学以致用。 在这一年中学到了不少新的技术，同时也有好多新技术只是初步了解，并没有彻底的过一遍并用在工作中。在这一年中新技术不断，不管是框架还是打包工具还是新的语法功能，都有了翻天覆地的变化。新出现的Vue2，angular2只是简单的敲了一下demo，体会到它语法的简洁以及功能的强大。对于热的一塌糊涂的react还没有来的及看，技术债来年一定会慢慢补上的。还有比较强大的node.js，现在是无处不在，所有的工程项目都要依赖node来搭建，还有webpack用以构建完整的工程项目，这一些都是自己的弱项，当时只是不求甚解的看了一下，到真正使用的时候发现还是不会用。还有一个新的变化就是es6，以及es7的到来，现在还并没有使用新的语法，所以下个阶段还要完成新语法的平稳过度。还有就是新的微信小程序，是一个新的机会，现在只是大概的了解其中的原理，真正项目还没有开始。过几天就着手微信小程序的开发。 对于过去一年技术的总结刚开始还能每周一篇技术文章，到了后面就没有怎么写了，写博客当初的初衷是记录成长的点滴，所以初心不能忘，新的一年每一周或者每月四篇技术文章的总结，也算是对自己技术提升的一个总结。2016年自己在github工作了122天，相对于那些大神，差的太远了，即便是不能天天工作，也要多完成一些项目，争取多写代码，多提交代码。在知乎，掘金和segmentfault上面的技术回答也寥寥无几，所以在新的一年要突破自己，多回答问题，多逛技术论坛。 二、展望未来 完成webpack构建工具的使用以及微信小程序的开发 完成对Vue2框架的整体学习，从打包构建工具到模块化以及到模板整体尝试，必须要完成一整个Vue2项目 完成react项目的实施以及react native移动端的项目尝试，并包含react全家桶的学习 学习typescript以及angular2的学习 完成node.js的学习，从桌面端到服务端，再到数据库的尝试 完成es6或es7的学习 每周一篇技术性博客的书写或者每个月四篇技术性文章的总结。 就是不断逛技术博客，以及研究发现别人的优秀项目，多提交项目记录，多敲代码，希望能在年末的时候github有半年的工作记录; 年龄也不小啦，该找个女朋友了 三、总结 对于前端来说2016年变化太多了，每一天都有新技术的更新，在前端从业人数的日益增多，前端的就业压力会越来越大，所以要不断提高自己的技术，才能使自己立于不败之地。对于新技术的各种撕逼自己要稳住自己，不能人云亦云，要加强自身基础知识的提高，不能眼高手低。2017年的年度计划挑战很大，不过把整年的年度计划划分为每一个季度、每一个月、每一周、每一天的计划，只要完成每天的小计划，大计划就会完成。相信自己，要改掉拖延症的毛病，每天努力一点点，就会有新的突破，不忘初心，方得始终。 致2017年年末总结，到时候看看完成了什么还有什么没完成。","categories":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://www.chenqiangyi.cn/categories/生活感悟/"}],"tags":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://www.chenqiangyi.cn/tags/生活感悟/"},{"name":"新年总结","slug":"新年总结","permalink":"http://www.chenqiangyi.cn/tags/新年总结/"}]},{"title":"mac 命令行 安装 需要管理员 权限“Please try running this command again as root/Administrator”的解决办法","slug":"mac权限修改","date":"2016-12-19T02:47:17.000Z","updated":"2017-06-14T13:52:47.000Z","comments":true,"path":"2016/12/19/mac权限修改/","link":"","permalink":"http://www.chenqiangyi.cn/2016/12/19/mac权限修改/","excerpt":"","text":"我们在进行mac 命令行安装软件的时候，有的时候会遇见这样的问题：Please try running this command again as root/Administrator. 如图： 1 解决办法是在终端输入： 1sudo chown -R $USER /usr/local 然后输入安装的密码，在执行相关安装命令就行了","categories":[{"name":"mac命令","slug":"mac命令","permalink":"http://www.chenqiangyi.cn/categories/mac命令/"}],"tags":[{"name":"mac命令","slug":"mac命令","permalink":"http://www.chenqiangyi.cn/tags/mac命令/"}]},{"title":"排序算法","slug":"排序算法","date":"2016-11-15T15:43:03.000Z","updated":"2017-06-19T02:53:08.000Z","comments":true,"path":"2016/11/15/排序算法/","link":"","permalink":"http://www.chenqiangyi.cn/2016/11/15/排序算法/","excerpt":"","text":"1var array = [1, 5, 6, 2 , 11, 3, 4, 8, 9, 15, 100, 20, 31, 256] 冒泡排序123456789101112131415161718192021222324// 最佳情况：T(n) = O(n)// 最差情况：T(n) = O(n2)// 平均情况：T(n) = O(n2)function bubbleSort(data, type) &#123; var arr = data ? data : [] var i = data.length -1 while (i &gt; 0) &#123; var post = 0 for (var j = 0; j &lt; i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; post = j var t = arr[j] arr[j] = arr[j+1] arr[j+1] = t &#125; &#125; i = post &#125; arr = type === &apos;max&apos; ? arr.reverse() : arr return arr&#125;//console.log(bubbleSort(array, &apos;min&apos;))//console.log(bubbleSort(array, &apos;max&apos;)) 选择排序123456789101112131415161718192021222324// 最佳情况：T(n) = O(n2)// 最差情况：T(n) = O(n2)// 平均情况：T(n) = O(n2)function chooseSort(data, type) &#123; var arr = data ? data : [] var l = arr.length var minIndex, t for (var i = 0; i &lt; l - 1; i++) &#123; minIndex = i for (var j = i + 1; j &lt; l - 1; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j &#125; &#125; t = arr[i] arr[i] = arr[minIndex] arr[minIndex] = t &#125; arr = type === &apos;max&apos; ? arr.reverse() : arr return arr&#125;// console.log(chooseSort(array, &apos;min&apos;))// console.log(chooseSort(array, &apos;max&apos;)) 插入排序1234567891011121314151617function insertSort(data, type) &#123; var arr = data ? data : [] for (var i = 1; i &lt; arr.length; i ++) &#123; var key = arr[i] var j = i - 1 while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) &#123; arr[j + 1] = arr[j] j-- &#125; arr[j + 1] = key &#125; arr = type === &apos;max&apos; ? arr.reverse() : arr return arr&#125;// console.log(insertSort(array, &apos;min&apos;))// console.log(insertSort(array, &apos;max&apos;)) 快速排序12345678910111213141516171819202122var array = [1, 5, 6, 2 , 11, 3, 4, 8, 9, 15, 100, 20, 31, 256, 1024]function quickSort (arr, type) &#123; if (arr.length &lt;= 1) &#123; return arr //如果数组只有一个数就返回 &#125; var index = Math.floor(arr.length / 2) //找到中间数的索引值，如果是浮点数就向下取整 var pivot = arr.splice(index, 1)[0] //找到中间数的值 var left = [] var right = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (type === &apos;min&apos;) &#123; arr[i] &lt; pivot ? left.push(arr[i]) : right.push(arr[i]) //基准点左边的数传到数组的左边 &#125; else &#123; arr[i] &gt; pivot ? left.push(arr[i]) : right.push(arr[i]) //基准点右边的数传到数组的右边 &#125; &#125; return quickSort(left, type).concat([pivot], quickSort(right, type)) //递归不断重复排序&#125;console.log(quickSort(array, &apos;min&apos;))console.log(quickSort(array, &apos;max&apos;))","categories":[{"name":"排序算法","slug":"排序算法","permalink":"http://www.chenqiangyi.cn/categories/排序算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://www.chenqiangyi.cn/tags/排序算法/"}]},{"title":"MongoDB常用语句","slug":"MongoDB常用语句","date":"2016-10-20T15:53:42.000Z","updated":"2017-06-17T17:35:39.000Z","comments":true,"path":"2016/10/20/MongoDB常用语句/","link":"","permalink":"http://www.chenqiangyi.cn/2016/10/20/MongoDB常用语句/","excerpt":"","text":"记录一下MongoDB常用语句，顺带与SQL做个简单的对比。 查询(find)查询所有结果123select * from articledb.article.find() 指定返回哪些键123select title, author from articledb.article.find(&#123;&#125;, &#123;&quot;title&quot;: 1, &quot;author&quot;: 1&#125;) where 条件123select * from article where title = &quot;mongodb&quot;db.article.find(&#123;&quot;title&quot;: &quot;mongodb&quot;&#125;) and 条件123select * from article where title = &quot;mongodb&quot; and author = &quot;god&quot;db.article.find(&#123;&quot;title&quot;: &quot;mongodb&quot;, &quot;author&quot;: &quot;god&quot;&#125;) or 条件123select * from article where title = &quot;mongodb&quot; or author = &quot;god&quot;db.article.find(&#123;&quot;&amp;or&quot;: [&#123;&quot;title&quot;: &quot;mongodb&quot;&#125;, &#123;&quot;author&quot;: &quot;god&quot;&#125;]&#125;) 比较条件123select * from article where read &gt;= 100;db.article.find(&#123;&quot;read&quot;: &#123;&quot;$gt&quot;: 100&#125;&#125;) $gt(&gt;)、$gte(&gt;=)、$lt(&lt;)、$lte(&lt;=) 123select * from article where read &gt;= 100 and read &lt;=200db.article.find(&#123;&quot;read&quot;: &#123;&quot;$gte&quot;: 100, &quot;$lte&quot;: 200&#125;&#125;) in 条件 * from article where author in (\"a\", \"b\", \"c\")12db.article.find(&#123;&quot;author&quot;: &#123;&quot;$in&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#125;&#125;) like 123select * from article where title like &quot;%mongodb%&quot;db.article.find(&#123;&quot;title&quot;: /mongodb/&#125;) count 123select count(*) from articledb.article.count() 不等于 123select * from article where author != &quot;a&quot;db.article.find(&#123;&quot;author&quot;: &#123;&quot;$ne&quot;: &quot;a&quot;&#125;&#125;) 排序升序： 123select * from article where type = &quot;mongodb&quot; order by read descdb.article.find(&#123;&quot;type&quot;: &quot;mongodb&quot;&#125;).sort(&#123;&quot;read&quot;: -1&#125;) 降序： 123select * from article where type = &quot;mongodb&quot; order by read ascdb.article.find(&#123;&quot;type&quot;: &quot;mongodb&quot;&#125;).sort(&#123;&quot;read&quot;: 1&#125;) findOne(): 除了只返回一个查询结果外，使用方法与find()一样 创建(insert) 123insert into article(title, author, content) values(&quot;mongodb&quot;, &quot;tg&quot;, &quot;haha&quot;)db.article.insert(&#123;&quot;title&quot;: &quot;mongodb&quot;, &quot;author&quot;: &quot;tg&quot;, &quot;content&quot;: &quot;haha&quot;&#125;) 更新(update)update() 语法： 1db.clooection.update(query, update[, options]) query: 必选，查询条件，类似find中的查询条件 update: 必选，update的对象和一些更新的操作符(如$,$inc…)等 options: 可选，一些更新配置的对象。 upsert: 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi: 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern: 可选，抛出异常的级别。 简单更新: 123update article set title = &quot;mongodb&quot; where read &gt; 100db.article.update(&#123;&quot;read&quot;: &#123;&quot;$gt&quot;: 100&#125;&#125;, &#123;&quot;$set&quot;: &#123;&quot;title&quot;: &quot;mongodb&quot;&#125;&#125;) save()1db.article.save(&#123;_id: 123, title: &quot;mongodb&quot;&#125;) 执行上面的语句，如果集合中已经存在一个_id为123的文档，则更新对应字段;否则插入。 注：如果更新对象不存在_id，系统会自动生成并作为新的文档插入。 更新操作符MongoDB提供一些强大的更新操作符。 更新特定字段（$set）: 123update game set count = 10000 where _id = 123db.game.update(&#123;&quot;_id&quot;: 123&#125;, &#123;&quot;$set&quot;: &#123;&quot;count&quot;: 10000&#125;&#125;) 删除特定字段($unset): 1db.game.update(&#123;&quot;_id&quot;: 123&#125;, &#123;&quot;$unset&quot;: &#123;&quot;author&quot;: 1&#125;&#125;) 注：$unset指定字段的值只需是任意合法值即可。 （未完）","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.chenqiangyi.cn/categories/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.chenqiangyi.cn/tags/MongoDB/"}]},{"title":"ES6新特性(2)——深刻而易懂的ES6解构教程","slug":"ES6新特性(2)——深刻而易懂的ES6解构教程","date":"2016-08-09T10:49:50.000Z","updated":"2017-06-14T13:13:29.000Z","comments":true,"path":"2016/08/09/ES6新特性(2)——深刻而易懂的ES6解构教程/","link":"","permalink":"http://www.chenqiangyi.cn/2016/08/09/ES6新特性(2)——深刻而易懂的ES6解构教程/","excerpt":"","text":"解构是ES6的新特性，用于从JavaScript对象和数组中提取数据，语法上比ES5所提供的更加简洁、紧凑、清晰。它不仅能减少你的代码量，还能从根本上改变你的编码方式。用的越多，你就会发现越多塑造数据和函数的方式，这些实现方式在过去几乎是不可能的。本文将深入探讨解构赋值，为你介绍该新特性中你所需要知悉的一切。 什么是解构？解构与构造数据截然相反。 例如，它不是构造一个新的对象或数组，而是逐个拆分现有的对象或数组，来提取你所需要的数据 ES6使用了一种新模式来匹配你想要提取的数值, 解构赋值就是采用了这种模式。 该模式会映射出你正在解构的数据结构，只有那些与该模式相匹配的数据，才会被提取出来。 被解构的数据项位于赋值运算符 = 的右侧，可以是任何数组和对象的组合，允许随意嵌套。用于给这些数据赋值的变量个数不限。 数组解构数组解构 使用一个数组作为一个数据项，你可以根据 数组模式 （用于从数组中匹配你所需要的数值）从这个数组里面提取数值给一个或者多个变量赋值。 数组模式 是根据数值的位置来鉴别哪些值是你想要提取的。它必须能精确地映射数组的结构，来要让数组模式中的每个变量都被赋上 被解构数组中 位置与之相对应的值。 举几个例子来帮助我们理解吧： 数组模式示例把数组中所有的数值赋给一个个单独的变量&lt; 12345678910//设置数组const avengers = [&apos;Tony Stark&apos;, &apos;Steve Rogers&apos;, &apos;Natasha Romanoff&apos;];//b把数组结构赋值给变量。数组模式位于赋值运算符&apos;=&apos; 的左侧，被解构的数组在其右侧。const [ironMan, cap, blackWidow] = avengers;// ironMan = &apos;Tony Stark&apos;// cap = &apos;Steve Rogers&apos;//blackWidow = &apos;Natasha Romanoff&apos;//输出 ironMan:ironMan;&quot;Tony Stark&quot; 提取除第一个外的所有数值 123456const avengers = [&apos;Tony Stark&apos;, &apos;Steve rogers&apos;, &apos;Natasha Romanoff&apos;];const [, cap, blackWidow] = avengers; // ironMan = Error: undefined // cap = &apos;Steve Rogers&apos; // blackWidow = &apos;Natasha Romanoff // 输出 cap: &lt;span style=&quot;font-size:13.2px;line-height:1.5;&quot;&gt;cap;&lt;/span&gt; 提取除第二个外的所有数值 1234567const avengers = [&apos;Tony Stark&apos;, &apos;Steve rogers&apos;, &apos;Natasha Romanoff&apos;];const [ironMan, , blackWidow] = avengers; // ironMan = &apos;Tony Stark&apos; // cap = Error: undefined // blackWidow = &apos;Natasha Romanoff // 输出 blackWidow: blackWidow; 提取除最后一个外的所有数值 1234567const avengers = [&apos;Tony Stark&apos;, &apos;Steve rogers&apos;, &apos;Natasha Romanoff&apos;];// ironMan vs capconst [ironMan, cap] = avengers; // ironMan = &apos;Tony Stark&apos; // cap = &apos;Steve Rogers&apos; // blackWidow = Error: undefined // 输出 b 嵌套数组这种匹配模式也支持嵌套数组，只要保证赋值运算符 = 左侧的数组模式与右侧的数组结构相匹配即可。再次说明一下，= 左边的变量都会被赋上 = 右侧数组中位置与之相对应的值。 无论你怎么深层次地嵌套，仍可以对它们进行解构。 解构嵌套的数组12345678910111213const avengers = [ &apos;Natasha Romanoff&apos;, [&apos;Tony Stark&apos;, &apos;James Rhodes&apos;], [&apos;Steve Rogers&apos;, &apos;Sam Wilson&apos;] ];const [blackWidow, [ironMan, warMachine], [cap, falcon]] = avengers;// blackWidow = &apos;Natasha Romanoff&apos;// ironMan = &apos;Tony Stark&apos;// varMachine = &apos;James Rhodes&apos;// cap = &apos;Steve Rogers&apos;// falcon = &apos;sam Wilson&apos;// Out warMachine:warMachine; 从深层嵌套的数组中提取一个值 12345678910111213const avengers = [ &apos;Natasha Romanoff&apos;, [&apos;Tony Stark&apos;, &apos;James Rhodes&apos;], [&apos;Steve Rogers&apos;, &apos;Sam Wilson&apos;] ];const [ , //跳过 &apos;Natasha Romanoff&apos; [ironMan, warMachine], [cap, falcon]] = avengers;// blackWidow = &apos;Natasha Romanoff&apos;// ironMan = &apos;Tony Stark&apos;// varMachine = &apos;James Rhodes&apos;// cap = &apos;Steve Rogers&apos;// falcon = &apos;sam Wilson&apos;// Out warMachine:warMachine;","categories":[{"name":"ES6","slug":"ES6","permalink":"http://www.chenqiangyi.cn/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.chenqiangyi.cn/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenqiangyi.cn/tags/JavaScript/"}]},{"title":"ES6-手册","slug":"ES6-手册","date":"2016-08-04T01:05:52.000Z","updated":"2017-06-14T11:23:00.000Z","comments":true,"path":"2016/08/04/ES6-手册/","link":"","permalink":"http://www.chenqiangyi.cn/2016/08/04/ES6-手册/","excerpt":"","text":"这篇手册包含了 ES2015(ES6) 的使用小技巧、最佳实践以及可以给你每天的工作参考的代码片段。 var 和 let/const 的比较除了 var ，我们现在还可以使用两个新的标示符来定义一个变量 —— let 和 const。和 var 不一样的是，let 和 const 不存在变量提升。 使用 var 的栗子： 123456789var snack = 'Meow Mix';function getFood(food) &#123; if(food) &#123; var snack = 'Friskies'; return snack; &#125; return snack;&#125;getFood(false); // undefined 当我们用 let 代替 var 的时候，观察会发生什么： 123456789let snack = 'Meow Mix' ;function getFood(food) &#123; if(food) &#123; let snack = 'Friskies'; return snack; &#125; return snack;&#125; getFood(false); // 'Meow Mix' 当我们重构使用 var 的老代码的时候应该注意上面的变化。盲目地使用 let 替换 var 可能会出现出乎意料的情况。 注意： let 和 const 是块级作用域，因此在变量未被定义之前使用它会产生一个 ReferenceError。 12console.log(x); // Uncaught ReferenceError: x is not definedlet x = 'hi'; 最佳实践： 在遗留代码中放弃使用 var 声明意味着需要很小心地重构；在新的项目代码中，使用 let 声明一个可以改变的变量，用 const 声明一个不能被重新赋值的变量。 用块级作用域代替函数立即执行表达式 的通常用途是创造一个内部的作用域，在 ES6 中，我们能够创造一个块级作用域而不仅限于函数作用域： 1234(function()&#123; var food = 'Meow Mix';&#125;)();console.log(food); //ReferenceError: food is not defined 使用 ES6 的块级作用域：1234&#123; let food = 'Meow Mix';&#125;console.log(food); // ReferenceError: food is not defined 箭头函数我们经常需要给回调函数维护一个词法作用域的上下文 this。 看看这个栗子： 12345678910function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(function (character) &#123; return this.name + character;&#125;);&#125;;// Cannot read property 'name' of undefined 一个常用的解决办法是把 this 存在一个变量中： 123456789function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; var that = this; // Store the context of this return arr.map(function (character) &#123; return this.name + character;&#125;);&#125;; 我们也可以传递一个合适的 this 上下文： 12345678910111213function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(function (character) &#123; return this.name + character;&#125;,this);&#125;;(arr) &#123; return arr.map(function (character) &#123; return this.name + character;&#125;,this);&#125; 我们还可以绑定上下文： 12345678function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = function (arr) &#123; return arr.map(function (character) &#123; return this.name + character;&#125;.bind(this));&#125;; 使用 箭头函数，this 将不会受到影响，并且我们可以重写上面的函数： 123456function Person(name) &#123; this.name = name;&#125;Person.prototype.prefixName = funciton (arr) &#123; return arr.map(character =&gt; this.name + character)&#125;; 最佳实践：当你需要维护一个 this 上下文的时候使用 箭头函数。 在我们写一个函数的时候，箭头函数更加简洁并且可以很简单地返回一个值： 1var Squares = arr.map(function (x) &#123; return x * X&#125;); //ReferenceError: arr is not defined arr = [1, 2, 3, 4, 5];12const squares = arr.map(x =&gt; x * x);//Arrow Function for terser implementation 最佳实践：尽可能使用箭头函数代替原来的写法。 字符串在 ES6 中，标准库升级了很多，在这些变化中有许多新的对于字符串的函数，比如 .includes() 和 .repeat()。 .includes()123var string = 'food';var substring = 'foo';console.log(string.indexOf(substring) &gt; -1); //true 之前我们使用 indexOf() 函数的返回值是否 -1 来判断字符串是否包含某些字符串，现在我们更简单地使用 .includes() 来返回一个布尔值来判断： 123var string = 'food';var substring = 'foo';console.log(string.includes(substring)); // true repeat()1234567function repeat(string, count) &#123; var strings = []; while(strings.length &gt; count) &#123; strings.push(string); &#125; return strings.join('');&#125; 在 ES6 中，可以更简便地实现： 12// String.repeat(numberOfRepetitions)'meow'.repeat(3) //\"meowmeowmeow\" 模版字符串使用 模版字符串 我们就可以不用对某些特殊自符进行转义处理了： 123var text = \"This string contains \\\"double quotes\\\" which are escaped.\"alert(text);//This string contains \"double quotes\" which are escaped. 1let text = `This string contains \"double quotes\" which are escaped.`; 模版字符串 还支持插入，可以把变量值和字符串连接起来. 1234var name = 'Tiger';var age = 13;console.log('My cat is named' + name + 'and is' +age + 'years old.');//My cat is namedTigerand is13years old. 更简单： 123const name = 'Tiger';const age = 13;console.log(`My cat is named $&#123;name&#125; and is $&#123;age&#125; years old.`); 在 ES5 中，需要换行时，需要这样： 1234567891011var text = ( 'cat\\n' + 'dog\\n' + 'nickelodeon');console.log(text);//catdognickelodeon 或者这样： 12345var text = [ 'cat' 'dog' 'nickelodeon'].join('\\n'); 模版字符串 可以支持换行并且不需要额外的处理： 123let text = ( `catdognicklodeon` 模版字符串 还支持表达式： 123let today = new Date();let text = `The time and date is$&#123;today.toLocaleString()&#125;`; 解构结构可以让我们用一个更简便的语法从一个数组或者对象（即使是深层的）中分离出来值，并存储他们。 结构数组12345var arr = [1, 2, 3, 4];var a = arr[0];var b = arr[1];var c = arr[2];var d = arr[3]; 123let [a, b, c, d] = [1, 2, 3, 4];console.log(a); // 1console.log(b); // 2 结构对象123var luke = &#123; occupation: 'jedi', father: 'anakin' &#125;;var occupation = luke.occupation; // 'jedi'var father = luke.father; // 'anakin' 1234let luke = &#123; occupation: 'jedi', father: 'anakin' &#125;;let &#123;occupation, father&#125; = luke;console.log(occupation); // 'jedu'console.log(father); // 'anakin' 模块在 ES6 之前，我们使用 Browserify 这样的库来创建客户端的模块化，在 node.js 中使用 require。 在 ES6 中，我们可以直接使用所有类型的模块化（AMD 和 CommonJS）。 使用 CommonJS 的出口 1234module.exports = 1;module.exports = &#123; foo: 'bar'&#125;;module.export = ['foo', 'bar'];module.exports = function bar()&#123;&#125;; 使用 ES6 的出口在 ES6 中我们可以暴漏多个值，使用 Exports： 12export let name = &apos;David&apos;;export let age = 25; 或者暴露一个对象列表：1234567function sumTwo(a, b) &#123; return a + b;&#125;function sumThree(a, b, c) &#123; return a + b + c;&#125;export &#123; sumTwo, sumThree &#125;; 我们还可以暴露函数、对象和其他的值，通过简单地使用 export 这个关键字： 123456export function sumTwo(a, b) &#123; return a + b;&#125;export function sumThree(a, b, c) &#123; return a + b + c;&#125; 最后，我们还可以绑定一个默认的输出： 1234567891011function sumTwo(a, b) &#123; return a + b;&#125;function sumThree(a, b, c) &#123; return a + b + c;&#125;let api = &#123; sumTwo, sumThree&#125;;export default api; 最佳实践： 总是在模块的最后面使用 export default 方法，这可以让暴露的东西更加清晰并且可以节省时间去找出暴漏出来值的名字。尤其如此，在 CommonJS 中通常的实践就是暴露一个简单的值或者对象。坚持这种模式，可以让我们的代码更加可读，并且在 ES6 和 CommonJS 模块之间更好地兼容。 ES6 中的导入在 ES6 中同样提供了多样的导入方式，我们可以这么导入一个整个文件： 1import 'underscore'; 需要着重注意的一点是简单的导入整个文件会在那个文件的顶部执行所有的代码 和 Python 中类似，我们可以命名导入的值： 1import &#123; sumTwo, sumThree &#125; from 'math/addition'; 我们还可以重命名导入： 1234import &#123; sumTwo as addTwoNumbers, sumThree as sumThreeNumbers&#125; from 'math/addition'; 另外，我们可以导入所有的东西（整体加载）： 1import * asutil from 'math/addition'; 最后，我们可以从一个模块中导入一个值的列表： 12import * as additionUtil from 'math/addition';const &#123; sumTwo, sumThree &#125; = additionUtil; 可以像这样导入默认绑定的输出： 12import api from 'math/addition';// same as :import &#123;default as api &#125; from 'math/addition'; 虽然最好保持出口的简单，但如果需要的话我们有时可以混合默认的进口和混合进口。当我们这样出口的时候： 12// foos.jsexport &#123; foo as default, foo1, foo2 &#125;; 我们可以这样导入它们： 1import foo, &#123; foo1, foo2 &#125; from 'foos'; 当我们用 commonjs 的语法导入一个模块的出口时（比如 React），我们可以这样做： 12import React from 'react';const &#123; Component, PropTypes &#125; = React; 还有更精简的写法： 1import React, &#123; Component, PropTypes &#125; from 'react'; 注意：导出的值是动态引用的，而不是拷贝。因此，在一个模块中改变一个变量的绑定将影响输出模块中的值。应该避免改变这些导出值的公共接口。（原文这里我觉得有误） 参数在 ES5 中，在函数中我们需要各种操作去处理 默认参数、不定参数 和 重命名参数 等需求，在 ES6 中我们可以使用更简洁的语法完成这些需求： 12345678function addTwoNumbers(x, y) &#123; x = x || 0; y = y || 0; return x + y;&#125;addTwoNumbers(3); // 3addTwoNumbers(3,2); // 5addTwoNumbers(); //0 ES6 中，函数的参数可以支持设置默认值： 123456function addTwoNumbers( x = 0, y = 0) &#123; return x + y;&#125;addTwoNumbers(2, 4); //6addTwoNumbers(2); //2addTwoNumbers(); //0 rest 参数在 ES5 中，我们需要这么处理不定参数： 12345function logArguments() &#123; for (var i = 0; i&amp;lt; arguments.length; i++) &#123; console.log(arguments[i]); &#125;&#125; 使用 rest ，我们就可以处理不确定数目的参数： 12345function logArguments(...args) &#123; for (let arg of args) &#123; console.log(arguments[i]); &#125;&#125; 命名参数在 ES5 中是使用配置对象的模式来处理命名参数，jQuery 中的使用： 12345function initializeCanvas(options) &#123; var height = options.height || 600; var width = options.width || 400; var lineStroke = options.lineStroke || 'black';&#125; 我们可以利用解构的一个函数的形参实现相同的功能： 1234function initializeCanvas( &#123; height = 600, width = 400, lineStroke = 'black'&#125;) &#123; // Use variables height, width, lineStroke here&#125; 如果我们想使整个值可选择，我们可以结构将一个空的对象： 1234function initializeCanvas ( &#123; height = 600, width = 400, lineStroke = 'black' &#125; = &#123;&#125;) &#123; // ...&#125; 展开操作在 ES5 中，我们可以 apply Math.max 方法来获得一个数组中的最大值： 1Math.max.apply(null, [-1, 100, 9001, -32]); // 9001 在 ES6 中，我们可以通过展开操作把一个数组的值作为参数传递给一个函数： 1Math.max(...[-1, 100, 9001, -32]); 我们可以更简洁地使用这个语法来合并数组： 12let cities = [ 'San Francisco', 'Los Angeles'];let places = [ 'Miami', ...cities, 'Chicago']; //['Miami', 'San Francisco', 'Los Angeles', 'Chicago' ] 类 Classes在 ES6 之前，我们通过构造函数来创造一个类，并且通过原型来扩展属性： 12345678function Person (name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;Person.prototype.incrementAge = function () &#123; return this.age +=1;&#125;; 然后可以这样继承类： 12345678910111213function Personal(name, age, gender, occupation,hobby)&#123; Person.call(this, name, age, gender); this.occupation = occupation; this.hobby = hobby;&#125;Personal.prototype = Object.create(Person.prototype);Person.prototype.constructor = Personal;Personal.prototype.incrementAge = function () &#123; Person.prototype.incrementAge.call(this); this.age += 20; console.log(this.age);&#125;&lt;/pre&gt; 在 ES6 中，提供了更多的语法糖，可以直接创造一个类： 12345678910class Person &#123; constructor(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; incrementAge() &#123; this.age += 1; &#125;&#125; 使用 extends 关键字来继承一个类： 123456789101112class Personal extends Person &#123; constructor(name, age, gender, occupation, hobby) &#123; super(name, age, gender); this.occupation = occupation; this.hobby = hobby; &#125; incrementAge() &#123; super.incrementAge(); this.age +=20; console.log(this.age); &#125;&#125; 最佳实践：虽然使用 ES6 的语法创造类的时候，js引擎是如何实现类以及如何操作原型是令人费解的，但是未来对初学者来说这是一个好的开始，同时也可以让我们写更简洁的代码。 SymbolsSymbols 在 ES6 之前就已经存在，但是我们现在可以直接使用一个开发的接口了。Symbols 是不可改变并且是第一无二的，可以在任意哈希中作一个key。 Symbol()调用 Symbol() 或者 Symbol(description) 可以创造一个第一无二的符号，但是在全局是看不到的。Symbol() 的一个使用情况是给一个类或者命名空间打上补丁，但是可以确定的是你不会去更新它。比如，你想给 React.Component 类添加一个 refreshComponent 方法，但是可以确定的是你不会在之后更新这个方法： 1234const refreshComponent = Symbol();React.Component.prototype[refreshComponent] = () =&gt; &#123; //do something&#125; Symbol.for(key)Symbol.for(key) 同样会创造一个独一无二并且不可改变的 Symbol，但是它可以全局看到，两个相同的调用 Symbol.for(key) 会返回同一个 Symbol 类： 123Symbol('foo') === Symbol('foo') // falseSymbol.for('foo') === Symbol('foo'); //falseSymbol.for('foo') === Symbol.for('foo'); //true 对于 Symbols 的普遍用法（尤其是Symbol.for(key)）是为了协同性。它可以通过在一个第三方插件中已知的接口中对象中的参数中寻找用 Symbol 成员来实现，比如： 123456789function reader(obj) &#123; const specialRead = Symbol.for('specialRead'); if (obj[specialRead]) &#123; const reader = obj[specialRead](); // do something with reader &#125; else&#123; throw new TypeError('object cannot be read'); &#125;&#125; 在另一个库中： 1234567const specialRead = Symbol.for('specialRead');class SomeReadableType &#123; [specialRead]() &#123; const reader = createSomeReaderForm(this); return reader; &#125;&#125; MapsMaps 在 JavaScript 中是一个非常必须的数据结构，在 ES6 之前，我们通过对象来实现哈希表： 123var map = new Object();map[key1] = 'value1';map[key2] = 'value2'; 但是它并不能防止我们偶然地用一些特殊的属性名重写函数: 1getOwnProperty(&#123; hasOwnProperty: 'Hah, overwritten'&#125;, 'Pwned'); 实际上 Maps 允许我们对值进行 set、get 和 search 操作： 1234let map = new Map();map.set('name','david');map.get('name'); // davidmap.has('name'); //true Maps 更令人惊奇的部分就是它不仅限于使用字符串作为 key，还可以用其他任何类型的数据作为 key： 1234567891011let map = new Map([ ['name', 'david'], [true, 'false'], [1, 'one'], [&#123;&#125;, 'object'], [function () &#123;&#125;, 'function']]);for (let key of map.keys()) &#123; console.log(typeof key); // string, boolean, number, object, function&#125; 注意：但我们使用 map.get() 方法去测试相等时，如果在 Maps 中使用 函数 或者 对象 等非原始类型值的时候测试将不起作用，所以我们应该使用 Strings, Booleans 和 Numbers 这样的原始类型的值。 我们还可以使用 .entries() 来遍历迭代： 123for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125; WeakMaps在 ES6 之前，为了存储私有变量，我们有各种各样的方法去实现，其中一种方法就是用命名约定： 12345678class Person &#123; constructor(age) &#123; this._age = age; &#125; _incrementAge() &#123; this._age += 1; &#125;&#125; 但是命名约定在代码中仍然会令人混淆并且并不会真正的保持私有变量不被访问。现在，我们可以使用 WeakMaps 来存储变量： 12345678910111213let _age = new WeakMap();class Person &#123; constructor(age) &#123; _age.set(this, age); &#125; incrementAge() &#123; let age = _age.get(this) + 1; _age.set(this, age); if (age &gt; 50) &#123; console.log(\"Midlife crisis\"); &#125; &#125;&#125; 在 WeakMaps 存储变量很酷的一件事是它的 key 他不需要属性名称，可以使用 Reflect.ownKeys() 来查看这一点： 123const person = new Person(50);person.incrementAge(); // 'Midlife crisis'Reflect.ownKeys(person); // [] 一个更实际的实践就是可以 WeakMaps 储存 DOM 元素，而不会污染元素本身： 1234567891011let map = new WeakMap();let el = document.getElementById('someElement');// Store a weak reference to the element with a keymap.set(el, 'reference');// Access the value of elementlet value = map.get(el); // 'reference'// Remove the referenceel.parentNode.removeChild(el);el = null;// map is empty, since the element is destroyed 如上所示，当一个对象被垃圾回收机制销毁的时候， WeakMap 将会自动地一处关于这个对象地键值对。 注意：为了进一步说明这个例子的实用性，可以考虑 jQuery 是如何实现缓存一个对象相关于对引用地 DOM 元素对象。使用 jQuery ，当一个特定地元素一旦在 document 中移除的时候，jQuery 会自动地释放内存。总体来说，jQuery 在任何 dom 库中都是很有用的。 PromisesPromises 可以让我们远离平行的代码（回调地狱）： 1234567891011func1(function (value1) &#123; func2(value1, function (value2) &#123; func3(value2, function (value3) &#123; func4(value3, function (value4) &#123; func5(value4, funciton (value5) &#123; // Do something with value 5 &#125;); &#125;); &#125;); &#125;);&#125;); 转变成垂直代码： 1234567func1(value1) .then(func2) .then(func3) .then(func4) .then(func5, value5 =&gt; &#123; // Do something with value 5&#125;); 在 ES6 之前，我们使用 bluebird 或者 q，现在我们可以使用原生的 Promise 了。 123new Promise ((resolve, reject) =&gt; reject(new Error('Failed to fulfill Promise'))) .catch(reason =&gt; console.log(reason)); 我们有两个处理器，resolve（当Promise是 fulfilled 时的回调）和 reject（当Promise是 rejected 时的回调）：。 Promises的好处：对错误的处理使用一些列回调会使代码很混乱，使用 Promise ，我看可以清晰的让错误冒泡并且在合适的时候处理它，甚至，在 Promise 确定了 resolved/rejected 之后，他的值是不可改变的－－它从来不会变化。 这是使用 Promise 的一个实际的栗子： 12345678910var request = require('request');return new Promise((resove, reject) =&gt; &#123; request.get(url,(error, response, body) =&gt; &#123; if (body) &#123; resove(JSON.parse(body)); &#125; else &#123; resove(&#123;&#125;); &#125; &#125;)&#125;) 我们还可以使用 Promise.all() 来 并行 处理多个异步函数： 1234567891011121314151617181920let urls = [ '/api/commits', '/api/issues/opened', '/api/issues/assigned', '/api/issues/completed', '/api/issues/comments', '/api/pullrequests'];let promises = urls.map((url) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: url&#125;) .done((data) =&gt; &#123; resolve(data); &#125;); &#125;);&#125;);Promise.all(promises) .then((results) =&gt; &#123; // Do something with result of all our promise&#125;); Generators 生成器就像 Promises 可以帮我们避免回调地狱，Generators 可以帮助我们让代码风格更整洁－－用同步的代码风格来写异步代码，它本质上是一个可以暂停计算并且可以随后返回表达式的值的函数。 1234567891011function* sillyGenerator() &#123; yield 1; yield 2; yield 3; yield 4;&#125;var generator = sillyGenerator();console.log(generator.next()); // &#123; value: 1, done: false &#125;console.log(generator.next()); // &#123; value: 2, done: false &#125;console.log(generator.next()); // &#123; value: 3, done: false &#125;console.log(generator.next()); // &#123; value: 4, done: false &#125; next 可以回去到下一个 yield 返回的值，当然上面的代码是非常不自然的，我们可以利用 Generators 来用同步的方式来写异步操作： 12345function request(url) &#123; getJSON(url, function(response) &#123; generator.next(response); &#125;);&#125; 123456function* getData() &#123; var entry1 = yield request('http://some_api/item1'); var data1 = JSON.parse(entry1); var entry2 = yield request('http://some_api/item2'); var data2 = JSON.parse(entry2);&#125; 通过 yield，我们可以保证 entry1 有 data1 中我们需要解析并储存的数据。 虽然我们可以利用 Generators 来用同步的方式来写异步操作，但是确认错误的传播变得不再清晰，我们可以在 Generators 中加上 Promise： 12345function request(url) &#123; return new Promise((resolve, reject) =&gt; &#123; getJSON(url, resolve); &#125;);&#125; 然后我们写一个函数逐步调用 next 并且利用 request 方法产生一个 Promise： 123456789function iterateGenerator(gen) &#123; var generator = gen(); (function iterate(val) &#123; var ret = generator.next(); if(!ret.done) &#123; ret.value.then(iterate); &#125; &#125;)();&#125; 在 Generators 中加上 Promise 之后我们可以更清晰的使用 Promise 中的 .catch 和 reject来捕捉错误，让我们使用新的 Generator，和之前的还是蛮相似的： 123456iterateGenerator(function* getData() &#123; var entry1 = yield request('http://some_api/item1'); var data1 = JSPN.parse(entry); var entry2 = yidld request('http://some_api/item2'); var data2 = JSON.parse(entry2);&#125;); Async Await当 ES6 真正到来的时候，async await 可以用更少的处理实现 Promise 和 Generators 所实现的异步处理： 12345678910111213var request = require('request');funciton getJSON(url) &#123; return new Promise(function(resolve, reject) &#123; request(url, function(error, response, body) &#123; resolve(body); &#125;); &#125;);&#125;async function main() &#123; var data = await getJSON(); console.log(data);&#125;main(); 在 js 引擎中，它所实现的和 Generators 其实是一样的，我更推荐在 Generators + Promises 之上使用 async await，更多的资源和使用 ES7 和 用 babel 转化可以看这里。 Getter/Setter 函数ES6 已经开始实现了 getter 和 setter 函数，比如虾面这个栗子： 123456789101112131415161718192021222324252627class Employee &#123; construstor(name) &#123; this._name = name; &#125; get name() &#123; if (this._name) &#123; return 'Mr. ' + this._name.toUpperCase(); &#125; else &#123; return undefined; &#125; &#125; set name(newName) &#123; if (newName == this._name) &#123; console.log('I already have this name.'); &#125; else if (newName) &#123; this._name = newName; &#125; else &#123; return false; &#125; &#125;&#125;var emp = new Employee(\"James Bond\");if (emp.name) &#123; console.log(emp.name); // Mr. JAMES BOND &#125;emp.name = \"Bond 007\";console.log(emp.name); // Mr. Bond 007 最新版本的浏览器也在对象中实现了 getter 和 setter 函数，我们可以使用它们来实现 计算属性，在设置和获取一个属性之前加上监听器和处理。 1234567891011121314151617var person = &#123; firstName: 'James', lastName: 'Bond', get fullName() &#123; console.log('Getting FullName'); return this.firstName + ' ' + this.lastName; &#125;, set fullName (name) &#123; console.log('Setting FullName'); var words = name.toString().split(' '); this.firstName = words[0] || ''; this.lastName = words[1] || ''; &#125;&#125;person.fullName; // James Bondperson.fullName = 'Bond 007';person.fullName; // Bond 007","categories":[{"name":"ES6","slug":"ES6","permalink":"http://www.chenqiangyi.cn/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.chenqiangyi.cn/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenqiangyi.cn/tags/JavaScript/"}]},{"title":"ES6新特性(1)——Arguments和Parameters","slug":"ES6新特性(1)——Arguments和Parameters","date":"2016-08-02T01:05:29.000Z","updated":"2017-06-14T13:07:19.000Z","comments":true,"path":"2016/08/02/ES6新特性(1)——Arguments和Parameters/","link":"","permalink":"http://www.chenqiangyi.cn/2016/08/02/ES6新特性(1)——Arguments和Parameters/","excerpt":"","text":"ECMAScript 6 (也称 ECMAScript 2015) 是ECMAScript 标准的最新版本，显著地完善了JS中参数的处理方式。除了其它新特性外，我们还可以使用rest参数、默认值、解构赋值等。 对比 Arguments 和 Parameters通常情况下提到 Arguments 和 Parameters， 都认为是可以互换使用的。然而，基于本教程的目的，我们做了明确的区分。在大多数标准中，parameters (形式参数) 指声明函数名和函数体的时候使用的参数，而 arguments (实际参数) 指在函数实际调用时，传入的确定值。思考下面这个函数： 1234function foo(param1, param2) &#123; // do something&#125;foo(10, 20); 在这个函数中， param1 和 param2 是函数的形式参数（形参）, 而在函数foo调用时，传入的 (10 和 20) 则是实际参数（实参）。 扩展操作符在 ES5 中，用 apply() 方法可以很方便地将一个数组传递给函数。例如，我们经常把它和 Math.max() 结合使用，来取得数组中的最大值。请看下面代码： 123var myArray = [5, 10, 50];Math.max()myArray; // Error: NaNMath.max.apply(Math, myArray); //50 Math.max() 方法并不支持传入数组，它只接受数字。所以当我们把数组作为参数传递给它时，就会抛出错误。但是，加上 apply() 方法后，数组会被转换成单独的数字，就能被 Math.max() 处理了。 庆幸的是，ES6 引入了扩展操作符，我们不需要再使用 apply() 方法了。通过扩展操作符，我们可以很方便地为表达式传入多个参数： 12var myArray = [5, 10, 50];Math.max(...myArray); //50 这里，扩展操作符把 myArray 展开成独立的数值传给了函数。 ES5里面使用 apply() 来模仿操作符是可以达到目的的，只是语法上令人困惑，并且缺乏扩展操作符的灵活性。 扩展操作符不仅易于使用，还涵盖了很多其他特性。例如，它可以被多次使用，还可以在 function 调用时，和其它参数混合使用: 1234567function myFunction() &#123; for(var i in arguments)&#123; console.log(arguments[i]); &#125;&#125;var params = [10, 15];myFunction(5, ...params, 20, ...[25]); // 5 10 15 20 25 扩展操作符的另一个优点，就是它可以很简单地和构造函数一起使用： 12new Date(...[2016, 5, 6]); // Mon Jun 06 201600 : 00: 00 GMT-0700 (Pacific Daylight Time) 当然，我们可以用ES5重写上面的代码，但我们则需要用一个复杂的模式来避免类型错误： 12new Date.apply(null, [2016, 4, 24]); // TypeError:Date.apply is not a constructornew (Function.prototype.bind.apply(Date,[null].concat([2016, 5, 6]))); // Mon Jun 06 2016 00 : 00 : 00 GMT-0700 (Pacific Daylight Time) 浏览器对扩展操作符在函数中调用的支持情况 桌面浏览器 Chrome Firefox Internet Explorer Microsoft Edge Opera Safari 46 27 – supported – 7.1 移动端浏览器： Chrome for Android Firefox Mobile Safari Oprea Mobile IE Mobile 46 27 8 – – Rest参数rest参数和扩展操作符拥有相同的语法，不同的是，rest参数是把所有的参数收集起来转换成数组，而扩展操作符是把数组扩展成单独的参数。 myFunction(...options) &#123;123 return options;&#125;myFunction(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 如果函数调用时，没有传入实际参数，则rest参数会输出一个空数组，如下： 1234function myFunction(...options) &#123; return options;&#125;myFunction(); //[] rest参数在创建一个可变函数（即一个参数个数可变的函数）时尤其有用。rest参数有着数组固有的优势，可以快捷地替换 arguments 对象（下文会解释这个名词）。下面这个函数是用ES5写的，我们来看下： 123456789function checkSubstrings(string) &#123; for(var i = 1; i &amp;lt; arguments.length; i++) &#123; if(string.indexOf(arguments[i]) === -1)&#123; return false; &#125; &#125; return false;&#125;checkSubstrings(&apos;this is a string&apos;, &apos;is&apos;, &apos;this&apos;); //true 该函数检查字符串（this is a string）是否包括这些子串（is, this）。这个函数存在的第一个问题是，我们必须看函数体内是否有多个参数。第二个问题是，循环必须从 1 开始，而不是从 0 开始, 因为 arguments[0] 指向的就是第一个参数（this is a string）。 如果以后我们想要在这个字符串的前面或者后面添加另一个参数，我们可能会忘记更新循环体。而使用rest参数，我们就可以很容易地避免这些问题： 123456789function checkSubstrings(string, ...keys) &#123; for (var key of keys) &#123; if(string.indexOf(key) === -1) &#123; return false; &#125; &#125; return true;&#125;checkSubstrings(&apos;this is a string&apos;, &apos;is&apos;, &apos;this&apos;); //true 该函数的输出跟前一个函数的输出是一样的。这里再提一下，参数 string 被包含在这个函数的 argument 中，并且第一个被传递进来，剩下的参数都被放到一个数组，并且赋给了名为 keys 的变量。 使用rest参数替代 arguments 对象来提高代码的可读性和避免一些js的优化问题1。 然而，rest参数也不是没有缺点的。例如，它必须是最后一个参数，否则就会报错，如下面函数所示： 1234function logArguments(a, ...params, b) &#123; console.log(a, params, b);&#125;logArguments(5, 10, 15); //SyntaxError: parameter after rest parameter 另一个缺点是，一个函数声明只能允许有一个rest参数： logArguments(...param1, ...param2) &#123;12&#125;logArgument(5, 10, 15); //SyntaxError: parameter after rest parameter 浏览器对Rest参数的支持情况 桌面浏览器： Chrome Firefox Internet Explorer Microsoft Edge Opera Safari 47 15 – supported 34 – 移动端浏览器： Chrome for Android Firefox Mobile Safari Oprea Mobile IE Mobile 46 15 – – – 默认参数 ES5 默认参数 在ES5中，JS 并不支持默认参数, 但是，我们也有一种变通的方案，那就是在函数中使用 OR 操作符（ ||）。我们简单地模仿ES5中的默认参数，请看下面函数： 1234567891011function foo(param1, param2) &#123; param1 = param1 || 10; param2 = param2 || 10; console.log(param1, param2);&#125;foo(5, 5);foo(5);foo();VM2450:4 5 5VM2450:4 5 10VM2450:4 10 10 该函数预期传入两个参数，但如果在调用该函数时，没有传入实参，则它会用默认值。在函数体内，如果没有传入实际参数，则会被自动设为 undefined, 所以，我们可以检测这些参数，并且声明他们的默认值。我们可以使用 OR 操作符（||）来检测是否有传入实际参数，并且设定他们的默认值。OR 操作符会检测它的第一个参数，如果有实际值2，则用第一个，如果没有，则用它的第二个参数。 这种方法在函数中普遍使用，但它有一个瑕疵，那就是传入 0 或者 null 也会触发默认值，因为 0 和 null 都被认为是false. 所以，如果我们需要给函数传入 0 和 null 时，我们需要另一种方式去检测这个参数是否缺失： 12345678910111213function foo(param1, param2) &#123; if(param1 === undefined) &#123; param1 = 10; &#125; if(param2 === undefined) &#123; param2 = 10; &#125; console.log(param1, param2);&#125;foo(0, null);foo();VM788:8 0 nullVM788:8 10 10 在上面这个函数中，只有当所传的参数全等于 undefined 时，才会使用默认值。这种方式需要用到的代码稍微多点，但是安全度更高，我们可以给函数传入 0 和 null 。 ES6 默认参数 有了ES6,我们不需要再去检测哪些值为undefined并且给它们设定默认值了。现在我们可以直接在函数声明中放置默认值： 1234567function foo(a = 10, b = 10) &#123; console.log(a, b);&#125;foo(5);foo(0, null);VM837:2 5 10VM837:2 0 null 如你所见，省略一个参数，就会触发一个默认值，但是传入 0 或者 null 时，则不会。 我们甚至可以使用函数去找回默认参数的值： 123456789function getParam() &#123; alert(&quot;getParam was called&quot;); return 3;&#125;function multiply(param1, param2 = getParam()) &#123; return param1 * param2;&#125;multiply(2, 5); //10multiply(2); // 6 (also displays an alert dialog) 注意 getParam 这个函数只有在第二个参数省略时才会被调用。所以当我们给 multiply 传入两个参数并调用它时，alert是不会出现的。 默认参数还有一个有趣的特性，那就是我们可以在函数声明中指定其它参数和变量的值： 123456function myFunction(a = 10, b = a) &#123; console.log(&apos;a = &apos; + a + &apos; ; b = &apos; + b);&#125;myFunction(); // a=10; b=10myFunction(22); // a=22; b=22myFunction(2, 4); // a=2; b=4 你甚至可以在函数声明中做运算： 1234function myFunction (a, b = ++a, c = a*b) &#123; console.log(c);&#125;myFunction(5); //36 请注意，JavaScript 和其它语言不同， 它是在函数被调用时，才去求参数的默认值。 123456function add(value, array = []) &#123; array.push(value); return array;&#125;add(5); // [5]add(6); // [6], not [5, 6] 浏览器对默认参数的支持情况 桌面浏览器： Feature Chrome Firefox Internet Explorer Microsoft Edge Opera Safari Basic support 49 15 – 14 – – Parameters without defaults after default parameter 49 26 – 14 – – 移动端浏览器： Feature Chrome Firefox Internet Explorer Microsoft Edge Opera Safari Basic support 49 15 – – – – Parameters without defaults after default parameter 49 25 – – – – 解构赋值解构赋值是ES6的新特性。我们可以从数组和对象中提取值，对变量进行赋值。这种语法清晰且易于理解，尤其是在给函数传参时特别有用。 在ES5里面，我们经常用一个配置对象来处理大量的可选参数， 特别是当对象属性的顺序可变时： 12345678910111213141516function initiateTransfer(options) &#123; var protoclo = options.protocol, port = options.port, retires = options.retries, timeout = options.timeout, log = options.log;&#125;options = &#123; protocol: &apos;http&apos;, port: 800, delay: 150, retries: 10, timeout: 500, log: true&#125;;initiateTransfer(options); 这种方式实现起来很好，已经被许多JS开发者所采用。 只是我们必须看函数内部，才知道函数预期需要哪些参数。结合解构赋值，我们就可以在函数声明中清晰地表示这些参数： 123456789101112function initiateTransfer(&#123;protocol, port, delay, retries, timeout, log&#125;) &#123; //code to initiate transfer&#125;;var options = &#123; protocol: &apos;http&apos;, port: 800, delay: 150, retries: 10, timeout: 500, log: true&#125;initiateTransfer(options); 在该函数中，我们没有传入一个配置对象，而是以对象解构赋值的方式，给它传参数。这样做不仅使这个函数更加简明，可读性也更高。 我们也可以把解构赋值传参和其它规则的参数一起使用： 1234function initiateTransfer(param1, &#123;protocol, port, delay, retires, timeout,log&#125;) &#123; //code to initiate transfer&#125;initiateTransfer(&apos;some value&apos;, options); 注意如果函数调用时，参数被省略掉，则会抛出错误，如下： 1234function initiateTransfer(&#123;protocol, port, delay, retries, timeout, log&#125;) &#123; //code to initiate transfer&#125;initiateTransfer(); //TypeError:Cannot match against &apos;undefined&apos; or &apos;null&apos; 当我们需要让参数都是必填时，这种方法能够得到我们想要的结果，但如果我们希望参数是可选的时候呢？想要让参数缺失时不会报错，我们就需要给默认参数设定一个默认值： 1234function initiateTransfer (&#123;protocol, port, delay, retries, timeout, log&#125; = &#123;&#125;) &#123; //code to initiate transfer&#125;initiateTransfer(); // no error 上面这个函数中，需要解构赋值的参数有了一个默认值，这个默认值就是一个空对象。这时候，函数被调用时，即使没有传入参数，也不会报错了。 我们也可以给每个被解构的参数设定默认值，如下： 12345678910function initiateTransfer(&#123; protocol = &apos;http&apos;, port = 800, delay = 150, retries = 10, timeout = 500, log = true&#125;) &#123; //code to initiate transfer&#125; 在这个例子中，每个属性都有一个默认值，我们不需要手动去检查哪个参数值是 undefined ，然后在函数中给它设定默认值了。 参数传递参数能通过引用或值传递给函数。修改按引用传递的参数，一般反映在全局中，而修改按值传递的参数，则只是反映在函数内部。 在像 Visual Basic 和 PowerShell 这样的语言中，我们可以选择是按引用还是按值来传递参数，但是在 JavaScript 中则不行。 按值传递参数从技术上来讲，JavaScript 只允许按值传参。当我们给函数按值传递一个参数时，该函数的作用域内就已经复制了这个值。因此，这个值的改变，只会在函数内部反映出来。请思考下面这个列子： 1234567var a = 5;function increment(a) &#123; a = ++a; console.log(a);&#125;increment(a); //6console.log(a); //5 这里，修改函数里面的参数 a = ++a，是不会影响到原来a的值。 所以在函数外面打印 a 的值，输出仍然是 5。 按引用传递参数在JavaScript中，一切都是按值传递的。但当我们给函数传一个变量，而这个变量所指向的是一个对象（包括数组）时，这个 变量 就是对象的一个引用。通过这个变量来改变对象的属性值，是会从根本上改变这个对象的。 来看下面这个例子： 123456789function foo(param) &#123; param.bar = &apos;new value&apos;;&#125;obj = &#123; bar : &apos;value&apos;&#125;console.log(obj.bar); // valuefoo(obj);console.log(obj.bar); // new value 如你所见，对象的属性值在函数内部被修改了，被修改的值在函数外面也是可见的。 当我们传递一个没有初始值的参数时，如数组或对象，会隐形地创建了一个变量，这个变量指向记忆中原对象所在的位置。这个变量随后被传递给了函数，在函数内部对这个变量进行修改将会影响到原对象。 参数类型检测、参数缺失或参数多余 在强类型语言中，我们必须在函数声明中明确参数的类型，但是 JavaScript 没有这种特性。在JavaScript中，我们传递给函数的参数个数不限，也可以是任何类型的数据。 假设现在有一个函数，这个函数只接受一个参数。但是当函数被调用时，它本身没有限制传入的参数只能是一个，我们可以随意地传入一个、两个、甚至是更多。我们也可以什么都不传，这样都不会报错。 形参（arguments）和 实参（parameters）的个数不同有两种情况： 实参少于形参 缺失的参数都会等同于 undefined。 实参多于形参 多余的参数都将被忽略，但它们会以数组的形式保存于变量 arguments 中（下文会讨论到）。 必填参数如果一个参数在函数调用时缺失了，它将被设为 undefined。基于这一点，我们可以在参数缺失时抛出一个错误： foo(mandatory, optional) &#123;1234 if (mandatory === undefined) &#123; throw new Error (&apos;Missing parameter: mandatory&apos;); &#125;&#125; 在 ES6 中，我们可以更好地利用这个特性，使用默认参数来设定必填参数： 123456789function throwError() &#123; throw new Error(&apos;Missing parameter&apos;);&#125;function foo(parama1 = throwError(), param2 =throwError()) &#123; //do something&#125;foo(10,20); //okfoo(10); //Error: missing parameter 参数对象为了取代参数对象，rest参数在 ECMAScript 4 中就已经得到支持，但是 ECMAScript 4 没有落实。随着 ECMAScript 6 版本的发布，JS 正式支持rest参数。它也拟定计划，准备抛弃 对参数对象 arguments object 的支持。 参数对象是一个类数组对象，可在一切函数内使用。它允许通过数字而不是名称，来找回被传递给函数的参数值。这个对象使得我们可以给函数传递任何参数。思考以下代码段： checkParams(param1) &#123;12345 console.log(param1); // 2 console.log(arguments[0], arguments[1], arguments[2]); // 2 3 4 console.log(param1 + arguments[0]); // 2 + 2&#125;checkParams(2, 3, 4); 该函数预期接收一个参数。但是当我们给它传入两个参数并且调用它时，第一个参数通过名为 param1 的形参或者参数对象 arguments[0] 被函数所接受，而第二个参数只能被放在argument[1] 里面。此外，请注意，参数对象可以与命名参数一起使用。 参数对象给每个被传递给函数的参数提供了一个入口，并且第一个入口的下标从 0 开始。如果我们要给上面这个函数传递更多的参数，我们可以写 arguments[2],arguments[3] 等等。 我们甚至可以跳过设定命名参数这一步，直接使用参数对象： 1234function checkParams() &#123; console.log(arguments[1], arguments[0] ,arguments[2]);&#125;checkParams(2, 4, 6) // 4 2 6 事实上，命名参数只是为了方便使用，并不是必须的。类似地，rest参数也可用于反映被传递的参数： 12345function checkParams(...params) &#123; console.log(params[1], params[0], params[2]); // 4 2 6 console.log(arguments[1], arguments[0], arguments[2]); // 4 2 6&#125;checkParams(2, 4, 6); 参数对象是一个类数组的对象，只是它没有数组本身具备的方法，如slice() 和 foreach()。 如果要在参数对象中使用数组的方法，首先要把它转换成一个真正的数组。 12345function sort() &#123; var a = Array.prototype.slice.call(arguments); return a.sort();&#125;sort(40, 20, 50,30); // [20, 30, 40, 50] 在该函数中，采用了 Array.prototype.slice.call() 来快速地把参数对象转换成一个数组。接着，在 sort() 方法中，为这个数组排序并且把它返回。 ES6 新增了更直接的方法，用 Array.from() 把任何类数组对象转换成数组： 12345function sort() &#123; var a = Array.from(arguments); return a.sort();&#125;sort(40, 20, 50,30); // [20, 30, 40, 50] 长度属性尽管参数对象从技术上来讲，不算是一个数组，但仍有一个长度属性，来检测传递给函数的参数个数： 12345function countArguments() &#123; console.log(arguments.length);&#125;countArguments(); // 0countArguments(10, null, &quot;string&quot;); //3 通过 length 属性，我们可以更好地控制传递给函数的参数个数。举个例子，如果一个函数只要求两个参数，那么我们就可以使用 length 属性来检测所传入的参数个数，如果少于要求的个数，则抛出错误： 1234567function foo(param1, param2) &#123; if(arguments.length &amp;lt; 2) &#123; throw new Error (&quot;This function expects at least two arguments&quot;); &#125; else if (arguments.length === 2) &#123; //do something &#125;&#125; rest参数是数组，所以他们都有 length 属性。 所以上面的代码，在ES6里面可以用rest参数写成下面这样： 1234567function foo(...params) &#123; if (params.length &amp;lt; 2) &#123; throw new Error(&quot;This function expects at least two arguments&quot;); &#125; else if (params.length === 2) &#123; //do something &#125;&#125; 被调用属性与调用属性被调用 属性指向当前正在执行的函数，而 调用 属性则指向那个调用了 当前正在执行的函数 的函数。 在ES5的严格模式下，这些属性是不被支持的，如果尝试使用它们，则会报错。 arguments.callee 这个属性在递归函数中很有用，尤其在匿名函数中。因为匿名函数没有名称，只能通过 arguments.callee 来指向它。 1234567var result = (function(n) &#123; if (n &amp;lt;= 1) &#123; return 1;&#125; else &#123; return n * arguments.callee(n - 1);&#125;&#125;)(4); //undefined 严格模式和非严格模式下的参数对象在ES5非严格模式下，参数对象 有个不一般的特性：它能使 自身的值 跟 与之相对应的命名参数的值 保持同步。 请看下面这个例子： 1234567function foo(param) &#123; console.log(param === arguments[0]); // true arguments[0] = 500; console.log(param === arguments[0]); //true return param&#125;foo(200); //500 在这个函数里面，arguments[0] 被重新赋值为 500。由于 arguments 的值总是和对应的命名参数保持同步，所以改变了arguments[0] 的值，也就相应的改变了 param 的值。实际上，他们就像是同一个变量，拥有两个不同的名字而已。而在 ES5严格模式下，参数对象的这种特性则被移除了。 12345678&quot;use strict&quot;;function foo(param) &#123; console.log(param === arguments[0]); // true arguments[0] = 500; console.log(param === arguments[0]); // false return param;&#125;foo(200); // 200 加上 严格模式， 现在改变 arguments[0] 的值是不会影响到 param 的值了，打印出来的值也跟预期的一致。 在 ES6中 该函数的输出跟在 ES5 严格模式下是一样的。需要记住的是，当函数声明中使用了默认值时，参数对象是不会受到影响的： 12345678function foo(param1, param2 = 10, param3 = 20) &#123; console.log(param1 === arguments[0]); // true console.log(param2 === arguments[1]); // true console.log(param3 === arguments[2]); // false console.log(arguments[2]); // undefined console.log(param3); // 20&#125;foo(&apos;string1&apos;, &apos;string2&apos;); 在这个函数中，尽管 param3 有默认值 20，但是 arguments[2] 仍然是 undefined, 因为函数调用时只传了两个值。换言之，设定默认值对参数对象是没有任何影响的。 总结ES6 给 JS 带来了上百个大大小小的改进。 越来越多的开发者正使用ES6的新特性, 所以我们都需要去了解它们。在本教程中，我们学习了ES6是如何改善JS的参数处理的，但我们仍只是知晓了ES6的皮毛。更多新的、有趣的特性值得我们去探讨。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenqiangyi.cn/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.chenqiangyi.cn/tags/ES6/"}]},{"title":"javascript和jquery读取和修改HTTP headers","slug":"javascript和jquery读取和修改HTTP headers","date":"2016-06-12T16:40:03.000Z","updated":"2017-06-14T13:50:33.000Z","comments":true,"path":"2016/06/13/javascript和jquery读取和修改HTTP headers/","link":"","permalink":"http://www.chenqiangyi.cn/2016/06/13/javascript和jquery读取和修改HTTP headers/","excerpt":"","text":"最近项目中遇到了一些问题，需要从第三方获取数据，通过ajax获取的时候需要修改HTTP headers信息。其中主要代码如下： 12345678910111213141516171819$(document).ready(function()&#123; $.ajax(&#123; url: &quot;https://api.stickerpipe.com/api/v2/shop&quot;, type: &quot;GET&quot;, headers: &#123; &apos;Platform&apos;:&apos;JS&apos;, &apos;ApiKey&apos;:&apos;173a6bc645f17ea974cc4a25b431a82c&apos;, &apos;UserId&apos;:&apos;12345&apos; &#125;, data :&#123;limit:&apos;10&apos;,offset:&quot;0&quot;&#125;, success: function(json)&#123; console.log(json.data); &#125;, error: function()&#123; alert(&apos;fail&apos;); &#125; &#125;);&#125;) 在这中间的ajax获取数据时需要修改HTTP headers信息，下面就来介绍一下如何修改头信息 jquery修改HTTP headersjQuery Ajax可以通过headers或beforeSend修改request的HTTP headers，例如： 123456789101112131415161718192021$.ajax(&#123; url: &quot;./test.php&quot;, type: &quot;POST&quot;, headers: &#123; &quot;Accept&quot; : &quot;text/plain; charset=utf-8&quot;, &quot;Content-Type&quot;: &quot;text/plain; charset=utf-8&quot; &#125;, /* beforeSend: function(jqXHR, settings) &#123; jqXHR.setRequestHeader(&apos;Accept&apos;, &apos;text/plain; charset=utf-8&apos;); jqXHR.setRequestHeader(&apos;Content-Type&apos;, &apos;text/plain; charset=utf-8&apos;); &#125;, */ data: &#123;&quot;user&quot; : &quot;min&quot;, &quot;pass&quot; : &quot;he&quot;&#125;, error: function(jqXHR, textStatus, errorThrown) &#123; //.... &#125;, success: function(data, textStatus, jqXHR) &#123; //.... &#125; &#125; 注意：：W3规定XMLHttpRequest并不能修改全部的HTTP Headers，而仅是一小部分。 jquery获取HTTP headers:html 12345678910111213141516171819202122232425262728293031html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; $.ajax(&#123; url: &quot;./test.php&quot;, type: &quot;POST&quot;, data: &#123;&quot;user&quot; : &quot;min&quot;, &quot;pass&quot; : &quot;he&quot;&#125;, error: function(jqXHR, textStatus, errorThrown) &#123; if (textStatus == &quot;error&quot;) &#123; alert(textStatus + &quot; : &quot; +errorThrown); &#125; else &#123; alert(textStatus); &#125; &#125;, success: function(data, textStatus, jqXHR) &#123; alert(jqXHR.getResponseHeader(&quot;Server&quot;)); alert(jqXHR.getResponseHeader(&quot;Content-Type&quot;)); alert(jqXHR.getResponseHeader(&quot;X-Powered-By&quot;)); alert(jqXHR.getResponseHeader(&quot;Content-Encoding&quot;)); alert(jqXHR.getAllResponseHeaders()); alert(jqXHR.getResponseHeader(&quot;Set-Cookie&quot;)); //返回null，不能获取Set-Cookie的值 alert(data + textStatus); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/html&gt; test.php 1234567891011&lt;?php if (isset($_COOKIE[&quot;time&quot;])) &#123; $time = $_COOKIE[&quot;time&quot;] + 1; &#125; else &#123; $time = 1; &#125; setcookie(&quot;time&quot;, $time); $user = $_REQUEST[&quot;user&quot;]; $pass = $_REQUEST[&quot;pass&quot;]; print $user.$pass.&quot; &quot;.$time; jQuery通过XMLHttpRequest的getResponseHeader或getAllResponseHeaders()可以获取指定的HTTP header field的值，但规定不能获取Set-Cookie和Set-Cookie2的值。 参考： http://stackoverflow.com/questions/1145588/cannot-properly-set-the-accept-http-header-with-jquery http://stackoverflow.com/questions/2444489/getresponseheader-is-not-a-function","categories":[{"name":"Ajax","slug":"Ajax","permalink":"http://www.chenqiangyi.cn/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://www.chenqiangyi.cn/tags/Ajax/"},{"name":"HTTP headers","slug":"HTTP-headers","permalink":"http://www.chenqiangyi.cn/tags/HTTP-headers/"}]},{"title":"RESTful API","slug":"restful-api","date":"2016-06-12T16:25:01.000Z","updated":"2017-06-14T14:00:03.000Z","comments":true,"path":"2016/06/13/restful-api/","link":"","permalink":"http://www.chenqiangyi.cn/2016/06/13/restful-api/","excerpt":"","text":"好久没有写博客了，最近刚好在弄公司的一个项目需要调用别人的API，其中遇到好多坑，今天将其记录下来，方便以后的学习。主要参考阮一峰的文章http://www.ruanyifeng.com/blog/2014/05/restful_api.html和博客园的一篇文章http://www.cnblogs.com/princeoicq/articles/2217808.html，接下来就来介绍RESTful API的设计与应用。 协议API与用户的通信协议，总是使用HTTP协议 域名应该尽量将API部署到专用域名下 1https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 1https://example.org/api/ 版本将API的版本放入URL 1https://api.example.com/v1/ 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 路径路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 123https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees HTTP动词对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。 123456789GET（SELECT）：从服务器取出资源（一项或多项）。POST（CREATE）：在服务器新建一个资源。PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。DELETE（DELETE）：从服务器删除资源。&lt;/pre&gt;还有两个不常用的HTTP动词&lt;pre class=&quot;prettyprint lang-js&quot;&gt;HEAD：获取资源的元数据。OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。 下面是一些例子。 12345678GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 过滤信息 Filtering如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 下面是一些常见的参数。 12345?limit=10：指定返回记录的数量?offset=10：指定返回记录的开始位置。?page=2&amp;per_page=100：指定第几页，以及每页的记录数。?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 状态码（Status Code）服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 123456789101112200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 状态码的完全列表参见这里http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html。 错误处理（Error Handling）如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 123&#123; error: &quot;Invalid API key&quot;&#125; 返回结果针对不同操作，服务器向用户返回的结果应该符合以下规范。 123456GET /collection：返回资源对象的列表（数组）GET /collection/resource：返回单个资源对象POST /collection：返回新生成的资源对象PUT /collection/resource：返回完整的资源对象PATCH /collection/resource：返回完整的资源对象DELETE /collection/resource：返回一个空文档 Hypermedia APIRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 123456&#123;&quot;link&quot;: &#123; &quot;rel&quot;: &quot;collection https://www.example.com/zoos&quot;, &quot;href&quot;: &quot;https://api.example.com/zoos&quot;, &quot;title&quot;: &quot;List of zoos&quot;, &quot;type&quot;: &quot;application/vnd.yourformat+json&quot;&#125;&#125; 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。 Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。 12345&#123; &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;, &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;, // ...&#125; 从上面可以看到，如果想获取当前用户的信息，应该去访问http://api.github.com/user，然后就得到了下面结果。 1234&#123; &quot;message&quot;: &quot;Requires authentication&quot;, &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;&#125; 上面代码表示，服务器给出了提示信息，以及文档的网址。 其他 API的身份认证应该使用OAuth 2.0框架。 服务器返回的数据格式，应该尽量使用JSON，避免使用XML。 （完）","categories":[{"name":"API","slug":"API","permalink":"http://www.chenqiangyi.cn/categories/API/"}],"tags":[{"name":"API","slug":"API","permalink":"http://www.chenqiangyi.cn/tags/API/"}]},{"title":"鼠标或键盘控制3D盒子旋转","slug":"鼠标或键盘控制3D盒子旋转","date":"2016-05-11T16:59:22.000Z","updated":"2017-06-14T07:44:51.000Z","comments":true,"path":"2016/05/12/鼠标或键盘控制3D盒子旋转/","link":"","permalink":"http://www.chenqiangyi.cn/2016/05/12/鼠标或键盘控制3D盒子旋转/","excerpt":"","text":"最近在研究3D盒子的旋转问题，今天来学习一下通过鼠标或者键盘控制3D盒子的旋转，效图： 两种旋转的方式都需要先把盒子的布局完成，前面的几步是相同的 通过键盘控制3D盒子旋转，demo链接：http://chenqiangyi.com/example/3Dbox1.html 通过鼠标控制3D盒子旋转，demo链接：http://chenqiangyi.com/example/3Dbox1.html 1.页面布局 需要一个大的盒子来包住，前后左右上下六个盒子，且他们的定位都是绝对定位，这样形成了六个盒子重叠到了一块，此时我们需要把盒子的每一个面变动一下，使其组合成一个盒子。此时我们需要想象一下盒子的3D空间，对于右边的那个面，他需要先沿Z轴正方向平移100px，然后再沿着y轴旋转正90度就得到了右边的面其中的代码： 1#div1 .right&#123; transform:rotateY(90deg) translateZ(100px);&#125; 然后就是左边的面，和右边的相似，只是旋转角度相反而已： 1#div1 .left&#123; transform:rotateY(-90deg) translateZ(100px);&#125; 前后面就是直接沿Z轴平移100px和-100px即可 12#div1 .front&#123; transform:translateZ(100px);&#125;#div1 .back&#123; transform:translateZ(-100px);&#125; 上边的面就是沿Z轴平移100px然后再按照X轴旋转90度，相反下边的面沿y轴旋转-90度 12#div1 .top&#123; transform:rotateX(90deg) translateZ(100px);&#125;#div1 .bottom&#123; transform:rotateX(-90deg) translateZ(100px);&#125; 然后就是为了看到3D效果，需要在其父级添加3D模型 1transform-style: preserve-3d; 这样基本的布局就完成了 2.js控制 首先介绍键盘的控制，我们知道键盘的按下去与松开都对应一个onkeydown事件和onkeyup事件，我们可以用事件对象获取其中的动作当按上键的时候我们可以得到他的ev.keycode=37,同理可以得到其他键的值，我们可以先定义bTop=bBotton=bLeft=bRight=false，当按下去的时候，判定哪个键对应的方向为true，然后当松开的 时候再令bTop=bBotton=bLeft=bRight=false这样在就可控制他的停止与运动了，然后我们开一个定时器，让他在某个方向上每隔30ms加10，这样就把X，y的值获取到了。 12345678910111213141516171819202122232425262728document.onkeydown=function(ev)&#123; if(ev.keyCode==37)&#123; bLeft=true; &#125; if(ev.keyCode==38)&#123; bTop=true; &#125; if(ev.keyCode==39)&#123; bRight=true; &#125; if(ev.keyCode==40)&#123; bBotton=true; &#125; &#125; document.onkeyup=function(ev)&#123; if(ev.keyCode==37)&#123; bLeft=false; &#125; if(ev.keyCode==38)&#123; bTop=false; &#125; if(ev.keyCode==39)&#123; bRight=false; &#125; if(ev.keyCode==40)&#123; bBotton=false; &#125; &#125; 然后就是改变他的X，y的变化，进行相应的运动变换 123456789101112131415161718192021 //左右 yvar y=0;//上下var x=0;setInterval(function()&#123; if(bLeft)&#123; y-=10; &#125; if(bRight)&#123; y+=10; &#125; if(bTop)&#123; x-=10; &#125; if(bBotton)&#123; x+=10; &#125; console.log(1) oDiv.style.transform=\"perspective(800px) rotateX(\"+-x+\"deg) rotateY(\"+y+\"deg)\"&#125;,30) 这样键盘的控制就结束了，接下来就是鼠标的控制了&lt; 3.鼠标的控制 主要运用鼠标的事件，当鼠标在网页上移动时会有相应的X和Y值得变化，这样我们就很容易得到鼠标的按下的位置和移动时的位置，我们可以根据在鼠标X轴移动的距离看做是他沿Y轴转动的角度，同时Y轴也是这样。 123456789101112131415document.onmousedown=function(ev)&#123; var disX=ev.clientX-y; var disY=ev.clientY-x; document.onmousemove=function(ev)&#123; y=ev.clientX-disX; x=ev.clientY-disY; oDiv.style.transform=\"perspective(800px) rotateX(\"+-x+\"deg) rotateY(\"+y+\"deg)\" &#125; document.onmouseup=function()&#123; document.onmousemove=document.onmouseup=null; &#125; return false; &#125; 这样两个效果就基本完成了。 4.总结 这个效果主要运用到了键盘的控制事件，以及盒子的拖拽模型，还有就是布局的知识，在以后会加上在移动端的控制。 最后附上两个模型的源代码： 键盘控制3D盒子旋转： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;style type=\"text/css\"&gt;*&#123;margin: 0;padding: 0;&#125;#div1&#123;position: relative;width: 200px;height: 200px;margin: 100px auto;line-height: 200px;text-align: center;font-size: 30px; transform: perspective(800px) rotateX(0deg) rotateY(0deg); transform-style: preserve-3d; /*transition: 3s all ease;*/&#125;#div1 div&#123;position: absolute;left: 0;top: 0;width: 198px;height: 198px;border: 1px solid #000;background: yellow;&#125;#div1 .front&#123;transform: translateZ(100px);background: green;&#125;#div1 .back&#123;transform: translateZ(-100px);background: blue;&#125;#div1 .left&#123;transform: rotateY(-90deg) translateZ(100px);background: pink;&#125;#div1 .right&#123;transform: rotateY(90deg) translateZ(100px);background: red;&#125;#div1 .top&#123;transform: rotateX(90deg) translateZ(100px);background: yellow;&#125;#div1 .bottom&#123;transform: rotateX(-90deg) translateZ(100px);background:orange;&#125;/*#div1:hover&#123;transform: perspective(800px) rotateX(-15deg) rotateY(360deg)&#125;*/&lt;/style&gt;&lt;script type=\"text/javascript\"&gt;window.onload=function()&#123; var oDiv=document.querySelector(\"#div1\") var bTop=bBotton=bLeft=bRight=false; //左右 y var y=0; //上下 var x=0; setInterval(function()&#123; if(bLeft)&#123; y-=10; &#125; if(bRight)&#123; y+=10; &#125; if(bTop)&#123; x-=10; &#125; if(bBotton)&#123; x+=10; &#125; console.log(1) oDiv.style.transform=\"perspective(800px) rotateX(\"+-x+\"deg) rotateY(\"+y+\"deg)\" &#125;,30) document.onkeydown=function(ev)&#123; if(ev.keyCode==37)&#123; bLeft=true; &#125; if(ev.keyCode==38)&#123; bTop=true; &#125; if(ev.keyCode==39)&#123; bRight=true; &#125; if(ev.keyCode==40)&#123; bBotton=true; &#125; &#125; document.onkeyup=function(ev)&#123; if(ev.keyCode==37)&#123; bLeft=false; &#125; if(ev.keyCode==38)&#123; bTop=false; &#125; if(ev.keyCode==39)&#123; bRight=false; &#125; if(ev.keyCode==40)&#123; bBotton=false; &#125; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"div1\"&gt; &lt;div class=\"front\"&gt;前面&lt;/div&gt; &lt;div class=\"back\"&gt;后面&lt;/div&gt; &lt;div class=\"left\"&gt;左面&lt;/div&gt; &lt;div class=\"right\"&gt;右面&lt;/div&gt; &lt;div class=\"top\"&gt;上面&lt;/div&gt; &lt;div class=\"bottom\"&gt;下面&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 鼠标控制3D盒子旋转： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;style type=\"text/css\"&gt;*&#123;margin: 0;padding: 0;&#125;#div1&#123;position: relative;width: 200px;height: 200px;margin: 100px auto;line-height: 200px;text-align: center;font-size: 30px; transform: perspective(800px) rotateX(45deg) rotateY(0deg); transform-style: preserve-3d; /*transition: 3s all ease;*/&#125;#div1 div&#123;position: absolute;left: 0;top: 0;width: 198px;height: 198px;border: 1px solid #000;background: yellow;&#125;#div1 .front&#123;transform: translateZ(100px);background: green;&#125;#div1 .back&#123;transform: translateZ(-100px);background: blue;&#125;#div1 .left&#123;transform: rotateY(-90deg) translateZ(100px);background: pink;&#125;#div1 .right&#123;transform: rotateY(90deg) translateZ(100px);background: red;&#125;#div1 .top&#123;transform: rotateX(90deg) translateZ(100px);background: yellow;&#125;#div1 .bottom&#123;transform: rotateX(-90deg) translateZ(100px);background:orange;&#125;/*#div1:hover&#123;transform: perspective(800px) rotateX(-15deg) rotateY(360deg)&#125;*/&lt;/style&gt;&lt;script type=\"text/javascript\"&gt;window.onload=function()&#123; var oDiv=document.querySelector(\"#div1\") //左右 y var y=0; //上下 var x=0; document.onmousedown=function(ev)&#123; var disX=ev.clientX-y; var disY=ev.clientY-x; document.onmousemove=function(ev)&#123; y=ev.clientX-disX; x=ev.clientY-disY; oDiv.style.transform=\"perspective(800px) rotateX(\"+-x+\"deg) rotateY(\"+y+\"deg)\" &#125; document.onmouseup=function()&#123; document.onmousemove=document.onmouseup=null; &#125; return false; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"div1\"&gt; &lt;div class=\"front\"&gt;前面&lt;/div&gt; &lt;div class=\"back\"&gt;后面&lt;/div&gt; &lt;div class=\"left\"&gt;左面&lt;/div&gt; &lt;div class=\"right\"&gt;右面&lt;/div&gt; &lt;div class=\"top\"&gt;上面&lt;/div&gt; &lt;div class=\"bottom\"&gt;下面&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://www.chenqiangyi.cn/categories/HTML5/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://www.chenqiangyi.cn/tags/CSS3/"},{"name":"HTML5","slug":"HTML5","permalink":"http://www.chenqiangyi.cn/tags/HTML5/"}]},{"title":"简单粗暴地理解js原型链–js面向对象编程(转)","slug":"简单粗暴地理解js原型链–js面向对象编程","date":"2016-05-11T14:19:10.000Z","updated":"2017-06-14T07:32:42.000Z","comments":true,"path":"2016/05/11/简单粗暴地理解js原型链–js面向对象编程/","link":"","permalink":"http://www.chenqiangyi.cn/2016/05/11/简单粗暴地理解js原型链–js面向对象编程/","excerpt":"","text":"今天在前端大全上看到一篇关于原型与原型链的文章，诙谐的语言加上逗逼的比喻，最重要的是讲的特别的透彻，于是就忍不住转载过来，充当学习的资料。本文内容转自微信公众号：前端大全。链接：http://www.cnblogs.com/qieguo/archive/2016/05/03/5451626.html。接下来就是逗逼的文章了。 原型链理解起来有点绕了，网上资料也是很多，每次晚上睡不着的时候总喜欢在网上找点原型链和闭包的文章看，效果极好。 不要纠结于那一堆术语了，那除了让你脑筋拧成麻花，真的不能帮你什么。简单粗暴点看原型链吧，想点与代码无关的事，比如人、妖以及人妖。 1）人是人他妈生的，妖是妖他妈生的。人和妖都是对象实例，而人他妈和妖他妈就是原型。原型也是对象，叫原型对象。 2）人他妈和人他爸啪啪啪能生出一堆人宝宝、妖他妈和妖他爸啪啪啪能生出一堆妖宝宝，啪啪啪就是构造函数，俗称造人。 3）人他妈会记录啪啪啪的信息，所以可以通过人他妈找到啪啪啪的信息，也就是说能通过原型对象找到构造函数。 4）人他妈可以生很多宝宝，但这些宝宝只有一个妈妈，这就是原型的唯一性。 5）人他妈也是由人他妈他妈生的，通过人他妈找到人他妈他妈，再通过人他妈他妈找到人他妈他妈……，这个关系叫做原型链。 5 6）原型链并不是无限的，当你通过人他妈一直往上找，最后发现你会发现人他妈他妈他妈……的他妈都不是人，也就是原型链最终指向null。 7）人他妈生的人会有人的样子，妖他妈生的妖会有妖的丑陋，这叫继承。 8）你继承了你妈的肤色，你妈继承了你妈他妈的肤色，你妈他妈……，这就是原型链的继承。 9）你谈对象了，她妈让你带上房产证去提货，你若没有，那她妈会问你妈有没有，你妈没有那她妈会问你妈她妈有没有……这就是原型链的向上搜索。 10）你会继承你妈的样子，但是你也可以去染发洗剪吹，就是说对象的属性可以自定义，会覆盖继承得到的属性。 11）虽然你洗剪吹了染成黄毛了，但你不能改变你妈的样子，你妈生的弟弟妹妹跟你的黄毛洗剪吹没一点关系，就是说对象实例不能改动原型的属性。 12）但是你家被你玩火烧了的话，那就是说你家你妈家你弟们家都被烧了，这就是原型属性的共享。 13）你妈外号阿珍，邻居大娘都叫你阿珍儿，但你妈头发从飘柔做成了金毛狮王后，隔壁大婶都改口叫你包租仔，这叫原型的动态性。 14）你妈爱美，又跑到韩国整形，整到你妈他妈都认不出来，即使你妈头发换回飘柔了，但隔壁邻居还是叫你金毛狮王子。因为没人认出你妈，整形后的你妈已经回炉再造了，这就是原型的整体重写。 尼玛！你特么也是够了！ Don’t BB！ Show me the code！ 1234567function Person (name) &#123; this.name = name; &#125;function Mother () &#123; &#125;Mother.prototype = &#123; //Mother的原型 age: 18, home: [&apos;Beijing&apos;, &apos;Shanghai&apos;]&#125;;Person.prototype = new Mother(); //Person的原型为Mother 用chrome调试工具查看，提供了proto接口查看原型，这里有两层原型，各位还是直接看chrome好一点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475var p1 = new Person(&apos;Jack&apos;); //p1:&apos;Jack&apos;; __proto__:&#123;__proto__:18,[&apos;Beijing&apos;,&apos;Shanghai&apos;]&#125;var p2 = new Person(&apos;Mark&apos;); //p2:&apos;Mark&apos;; __proto__:&#123;__proto__:18,[&apos;Beijing&apos;,&apos;Shanghai&apos;]&#125;p1.age = 20; /* 实例不能改变原型的基本值属性，正如你洗剪吹染黄毛跟你妈无关 * 在p1实例下增加一个age属性的普通操作，与原型无关。跟var o=&#123;&#125;; o.age=20一样。 * p1：下面多了个属性age，而__proto__跟 Mother.prototype一样，age=18。 * p2：只有属性name，__proto__跟 Mother.prototype一样 */p1.home[0] = &apos;Shenzhen&apos;;/* 原型中引用类型属性的共享，正如你烧了你家，就是烧了你全家的家 * 这个先过，下文再仔细唠叨一下可好？ * p1：&apos;Jack&apos;,20; __proto__:&#123;__proto__:18,[&apos;Shenzhen&apos;,&apos;Shanghai&apos;]&#125; * p2：&apos;Mark&apos;; __proto__:&#123;__proto__:18,[&apos;Shenzhen&apos;,&apos;Shanghai&apos;]&#125; */p1.home = [&apos;Hangzhou&apos;, &apos;Guangzhou&apos;];/* 其实跟p1.age=20一样的操作。换成这个理解: var o=&#123;&#125;; o.home=[&apos;big&apos;,&apos;house&apos;] * p1：&apos;Jack&apos;,20,[&apos;Hangzhou&apos;,&apos;Guangzhou&apos;]; __proto__:&#123;__proto__:18,[&apos;Shenzhen&apos;,&apos;Shanghai&apos;]&#125; * p2：&apos;Mark&apos;; __proto__:&#123;__proto__:18,[&apos;Shenzhen&apos;,&apos;Shanghai&apos;]&#125; */delete p1.age; /* 删除实例的属性之后，原本被覆盖的原型值就重见天日了。正如你剃了光头，遗传的迷人小卷发就长出来了。 * 这就是向上搜索机制，先搜你，然后你妈，再你妈他妈，所以你妈的改动会动态影响你。 * p1：&apos;Jack&apos;,[&apos;Hangzhou&apos;,&apos;Guangzhou&apos;]; __proto__:&#123;__proto__:18,[&apos;Shenzhen&apos;,&apos;Shanghai&apos;]&#125; * p2：&apos;Mark&apos;; __proto__:&#123;__proto__:18,[&apos;Shenzhen&apos;,&apos;Shanghai&apos;]&#125; */Person.prototype.lastName = &apos;Jin&apos;;/* 改写原型，动态反应到实例中。正如你妈变新潮了，邻居提起你都说你妈真潮。 * 注意，这里我们改写的是Person的原型，就是往Mother里加一个lastName属性，等同于Mother.lastName=&apos;Jin&apos; * 这里并不是改Mother.prototype，改动不同的层次，效果往往会有很大的差异。 * p1：&apos;Jack&apos;,[&apos;Hangzhou&apos;,&apos;Guangzhou&apos;]; __proto__:&#123;&apos;jin&apos;,__proto__:18,[&apos;Shenzhen&apos;,&apos;Shanghai&apos;]&#125; * p2：&apos;Mark&apos;; __proto__:&#123;&apos;jin&apos;,__proto__:18,[&apos;Shenzhen&apos;,&apos;Shanghai&apos;]&#125; */Person.prototype = &#123; age: 28, address: &#123; country: &apos;USA&apos;, city: &apos;Washington&apos; &#125;&#125;;var p3 = new Person(&apos;Obama&apos;);/* 重写原型！这个时候Person的原型已经完全变成一个新的对象了，也就是说Person换了个妈，叫后妈。 * 换成这样理解：var a=10; b=a; a=20; c=a。所以b不变，变得是c，所以p3跟着后妈变化，与亲妈无关。 * p1：&apos;Jack&apos;,[&apos;Hangzhou&apos;,&apos;Guangzhou&apos;]; __proto__:&#123;&apos;jin&apos;,__proto__:18,[&apos;Shenzhen&apos;,&apos;Shanghai&apos;]&#125; * p2：&apos;Mark&apos;; __proto__:&#123;&apos;jin&apos;,__proto__:18,[&apos;Shenzhen&apos;,&apos;Shanghai&apos;]&#125; * p3:&apos;Obama&apos;;__proto__: 28 &#123;country: &apos;USA&apos;, city: &apos;Washington&apos;&#125; */Mother.prototype.no = 9527;/* 改写原型的原型，动态反应到实例中。正如你妈他妈变新潮了，邻居提起你都说你丫外婆真潮。 * 注意，这里我们改写的是Mother.prototype，p1p2会变，但上面p3跟亲妈已经了无瓜葛了，不影响他。 * p1：&apos;Jack&apos;,[&apos;Hangzhou&apos;,&apos;Guangzhou&apos;]; __proto__:&#123;&apos;jin&apos;,__proto__:18,[&apos;Shenzhen&apos;,&apos;Shanghai&apos;],9527&#125; * p2：&apos;Mark&apos;; __proto__:&#123;&apos;jin&apos;,__proto__:18,[&apos;Shenzhen&apos;,&apos;Shanghai&apos;],9527&#125; * p3:&apos;Obama&apos;;__proto__: 28 &#123;country: &apos;USA&apos;, city: &apos;Washington&apos;&#125; */Mother.prototype = &#123; car: 2, hobby: [&apos;run&apos;,&apos;walk&apos;]&#125;;var p4 = new Person(&apos;Tony&apos;);/* 重写原型的原型！这个时候Mother的原型已经完全变成一个新的对象了！人他妈换了个后妈！ * 由于上面Person与Mother已经断开联系了，这时候Mother怎么变已经不影响Person了。 * p4:&apos;Tony&apos;;__proto__: 28 &#123;country: &apos;USA&apos;, city: &apos;Washington&apos;&#125; */Person.prototype = new Mother(); //再次绑定var p5 = new Person(&apos;Luffy&apos;);// 这个时候如果需要应用这些改动的话，那就要重新将Person的原型绑到mother上了// p5:&apos;Luffy&apos;;__proto__:&#123;__proto__: 2, [&apos;run&apos;,&apos;walk&apos;]&#125;p1.__proto__.__proto__.__proto__.__proto__ //null，你说原型链的终点不是null？Mother.__proto__.__proto__.__proto__ //null，你说原型链的终点不是null？ 看完基本能理解了吧？ 现在再来说说 p1.age = 20、p1.home = [‘Hangzhou’, ‘Guangzhou’] 和 p1.home[0] = ‘Shenzhen’ 的区别。 p1.home[0] = ‘Shenzhen’; 总结一下是 p1.object.method，p1.object.property 这样的形式。 p1.age = 20; p1.home = [‘Hangzhou’, ‘Guangzhou’];这两句还是比较好理解的，先忘掉原型吧，想想我们是怎么为一个普通对象增加属性的： 123var obj = new Object();obj.name=&apos;xxx&apos;;obj.num = [100, 200]; 这样是不是就理解了呢？一样一样的呀。 那为什么 p1.home[0] = ‘Shenzhen’ 不会在 p1 下创建一个 home 数组属性，然后将其首位设为 ‘Shenzhen’呢？ 我们还是先忘了这个，想想上面的obj对象，如果写成这样： var obj.name = ‘xxx’, obj.num = [100, 200]，能得到你要的结果吗？ 显然，除了报错你什么都得不到。因为obj还未定义，又怎么能往里面加入东西呢？同理，p1.home[0]中的 home 在 p1 下并未被定义，所以也不能直接一步定义 home[0] 了。如果要在p1下创建一个 home 数组，当然是这么写了： 12p1.home = [];p1.home[0] = &apos;Shenzhen&apos;; 这不就是我们最常用的办法吗？ 而之所以 p1.home[0] = ‘Shenzhen’ 不直接报错，是因为在原型链中有一个搜索机制。当我们输入 p1.object 的时候，原型链的搜索机制是先在实例中搜索相应的值，找不到就在原型中找，还找不到就再往上一级原型中搜索……一直到了原型链的终点，就是到null还没找到的话，就返回一个 undefined。当我们输入 p1.home[0] 的时候，也是同样的搜索机制，先搜索 p1 看有没有名为 home 的属性和方法，然后逐级向上查找。最后我们在Mother的原型里面找到了，所以修改他就相当于修改了 Mother 的原型啊。 1Mother.prototype.home[0] = ‘Shenzhen’。 由上面的分析可以知道，原型链继承的主要问题在于属性的共享，很多时候我们只想共享方法而并不想要共享属性，理想中每个实例应该有独立的属性。因此，原型继承就有了下面的两种改良方式： 1）组合继承 123456789101112131415161718192021function Mother (age) &#123; this.age = age; this.hobby = [&apos;running&apos;,&apos;football&apos;]&#125;Mother.prototype.showAge = function () &#123; console.log(this.age);&#125;;function Person (name, age) &#123; Mother.call(this, age); //第二次执行 this.name = name;&#125;Person.prototype = new Mother(); //第一次执行Person.prototype.constructor = Person;Person.prototype.showName = function () &#123; console.log(this.name);&#125;var p1 = new Person(&apos;Jack&apos;, 20);p1.hobby.push(&apos;basketball&apos;); //p1:&apos;Jack&apos;; __proto__:20,[&apos;running&apos;,&apos;football&apos;]var p2 = new Person(&apos;Mark&apos;, 18); //p2:&apos;Mark&apos;; __proto__:18,[&apos;running&apos;,&apos;football&apos;] 结果是酱紫的： 这里第一次执行的时候，得到 Person.prototype.age = undefined, Person.prototype.hobby = [‘running’,’football’]，第二次执行也就是 var p1 = new Person(‘Jack’, 20) 的时候，得到 p1.age =20, p1.hobby = [‘running’,’football’]，push后就变成了 p1.hobby = [‘running’,’football’, ‘basketball’]。其实分辨好 this 的变化，理解起来也是比较简单的，把 this 简单替换一下就能得到这个结果了。 如果感觉理解起来比较绕的话，试着把脑子里面的概念扔掉吧，把自己当浏览器从上到下执行一遍代码，结果是不是就出来了呢？ 通过第二次执行原型的构造函数 Mother()，我们在对象实例中复制了一份原型的属性，这样就做到了与原型属性的分离独立。细心的你会发现，我们第一次调用 Mother()，好像什么用都没有呢，能不调用他吗？可以，就有了下面的寄生组合式继承。 2）寄生组合式继承 12345678910111213141516171819202122232425262728293031323334function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(Person, Mother)&#123; var prototype = object(Mother.prototype); prototype.constructor = Person; Person.prototype = prototype; &#125;function Mother (age) &#123; this.age = age; this.hobby = [&apos;running&apos;,&apos;football&apos;]&#125;Mother.prototype.showAge = function () &#123; console.log(this.age);&#125;;function Person (name, age) &#123; Mother.call(this, age); this.name = name;&#125;inheritPrototype(Person, Mother);Person.prototype.showName = function () &#123; console.log(this.name);&#125;var p1 = new Person(&apos;Jack&apos;, 20);p1.hobby.push(&apos;basketball&apos;);//p1:&apos;Jack&apos;; __proto__:20,[&apos;running&apos;,&apos;football&apos;]var p2 = new Person(&apos;Mark&apos;, 18); //p2:&apos;Mark&apos;; __proto__:18,[&apos;running&apos;,&apos;football&apos;] 结果是酱紫的： 原型中不再有 age 和 hobby 属性了，只有两个方法，正是我们想要的结果！ 关键点在于 object(o) 里面，这里借用了一个临时对象来巧妙避免了调用new Mother()，然后将原型为 o 的新对象实例返回，从而完成了原型链的设置。很绕，对吧，那是因为我们不能直接设置 Person.prototype = Mother.prototype 啊。 小结 说了这么多，其实核心只有一个：属性共享和独立的控制，当你的对象实例需要独立的属性，所有做法的本质都是在对象实例里面创建属性。若不考虑太多，你大可以在Person里面直接定义你所需要独立的属性来覆盖掉原型的属性。总之，使用原型继承的时候，要对于原型中的属性要特别注意，因为他们都是牵一发而动全身的存在。 下面简单罗列下js中创建对象的各种方法，现在最常用的方法是组合模式，熟悉的同学可以跳过到文章末尾点赞了。 1）原始模式 1.原始模式，对象字面量方式 123456789101112var person = &#123; name: &apos;Jack&apos;, age: 18, sayName: function () &#123; alert(this.name); &#125;&#125;;//1.原始模式，Object构造函数方式var person = new Object();person.name = &apos;Jack&apos;;person.age = 18;person.sayName = function () &#123; alert(this.name);&#125;; 2）工厂模式 2.工厂模式，定义一个函数创建对象 123456789function creatPerson (name, age) &#123; var person = new Object(); person.name = name; person.age = age; person.sayName = function () &#123; alert(this.name); &#125;; return person;&#125; 工厂模式就是批量化生产，简单调用就可以进入造人模式 （ 啪啪啪……）。指定姓名年龄就可以造一堆小宝宝啦，解放双手。但是由于是工厂暗箱操作的，所以你不能识别这个对象到底是什么类型、是人还是狗傻傻分不清（instanceof 测试为 Object），另外每次造人时都要创建一个独立的temp对象，代码臃肿，雅蠛蝶啊。 3）构造函数 3.构造函数模式，为对象定义一个构造函数 123456789function Person (name, age) &#123; this.name = name; this.age = age; this.sayName = function () &#123; alert(this.name); &#125;; &#125;var p1 = new Person(&apos;Jack&apos;, 18); //创建一个p1对象Person(&apos;Jack&apos;, 18); //属性方法都给window对象，window.name=&apos;Jack&apos;，window.sayName()会输出Jack 构造函数与C++、JAVA中类的构造函数类似，易于理解，另外Person可以作为类型识别（instanceof 测试为 Person 、Object）。但是所有实例依然是独立的，不同实例的方法其实是不同的函数。这里把函数两个字忘了吧，把sayName当做一个对象就好理解了，就是说张三的 sayName 和李四的 sayName是不同的存在，但显然我们期望的是共用一个 sayName 以节省内存。 4）原型模式 4.原型模式，直接定义prototype属性 123456function Person () &#123;&#125;Person.prototype.name = &apos;Jack&apos;;Person.prototype.age = 18;Person.prototype.sayName = function () &#123; alert(this.name);&#125;; 4.原型模式，字面量定义方式 12345678function Person () &#123;&#125;Person.prototype = &#123; name: &apos;Jack&apos;, age: 18, sayName: function () &#123; alert(this.name); &#125;&#125;;var p1 = new Person(); //name=&apos;Jack&apos;var p2 = new Person(); //name=&apos;Jack&apos; 这里需要注意的是原型属性和方法的共享，即所有实例中都只是引用原型中的属性方法，任何一个地方产生的改动会引起其他实例的变化。 5）混合模式（构造+原型） 5.原型构造组合模式 12345678910111213function Person (name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype = &#123; hobby: [&apos;running&apos;,&apos;football&apos;]; sayName: function () &#123; alert(this.name); &#125;, sayAge: function () &#123; alert(this.age); &#125;&#125;;var p1 = new Person(&apos;Jack&apos;, 20);//p1:&apos;Jack&apos;,20; __proto__: [&apos;running&apos;,&apos;football&apos;],sayName,sayAgevar p2 = new Person(&apos;Mark&apos;, 18);//p1:&apos;Mark&apos;,18;__proto__: [&apos;running&apos;,&apos;football&apos;],sayName,sayAge 做法是将需要独立的属性方法放入构造函数中，而可以共享的部分则放入原型中，这样做可以最大限度节省内存而又保留对象实例的独立性。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenqiangyi.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.chenqiangyi.cn/tags/JavaScript/"},{"name":"原型与原型链","slug":"原型与原型链","permalink":"http://www.chenqiangyi.cn/tags/原型与原型链/"}]},{"title":"HTML5头图切换效果","slug":"HTML5头图切换效果","date":"2016-05-10T16:58:16.000Z","updated":"2017-06-14T13:45:15.000Z","comments":true,"path":"2016/05/11/HTML5头图切换效果/","link":"","permalink":"http://www.chenqiangyi.cn/2016/05/11/HTML5头图切换效果/","excerpt":"","text":"HTML5配合上CSS3可以做出很炫的效果，这也是为什么越来越多的人学习H5的原因，话不多说，先放图 从图中就可以看出大概的效果，当点击next或prev按钮是，图片向前或向后旋转切换拨动，并且是以立体的效果切换的，链接：http://www.chenqiangyi.com/demo/switch/ 接下来就来分享一下制作的方法 页面布局 首先需要有一个大盒子包裹着所有的元素，并且需要其为绝对定位relative，方便对其子元素的位置的控制; 需要增加一个ul包含这一堆li，在每个li中包含一张图片，并且是撑满li的，而且需要对li进行绝对定位absolute 在图中可以看到每次显示三张图片，哦~不对，应该是五张图片，还有两张图片在盒子的最边缘，在切换的时候就会隐掉，从左到右暂时规定图片的class为l2,l1,cur,r1,r2,当我们切换的时候只需改变每一张图片的class即可 csstransition和transform控制 当页面刚开始加载的时候我们需要布局呈先如图的样式，这句需要运用transform的知识了，首先在刚开始的时候所有图片都平铺在最中间，对于最中间的图片的位置没有变，我们暂时不考虑，只需考虑两边的图片，右一图片r1可以看做是原来的图片向右移动了一段距离，然后沿着Y轴旋转一定角度得到的，那么问题来了，是如何旋转的，需要旋转多少度呢？这里有一个方法，就是人站在朝向y轴的正方向，如果顺时针旋转就为正角度，逆时针旋转就为负角度。就如图中的图片，如果要按照y轴旋转，你需要站在图片的正下方看图片，此时你看到的只是图片的一条棱，那么就可以看到图片逆时针旋转得到了图中的样式。如此一来，右二图l2就可以知道他是先向右移动一定距离，然后逆时针旋转了一个更大的角度。如此轮推就可以知道前面的两张图片是按照向左平移一定距离，然后顺时针旋转了一定的角度得到的，只是角度大小不同而已。 五张图片的初始样式的css代码： 12345#ul1 li.l2&#123;opacity: 0;z-index: 1;transform: perspective(800px) translateX(-300px) rotateY(45deg);&#125;#ul1 li.l1&#123;opacity: 1;z-index: 3;transform: perspective(800px) translateX(-200px) rotateY(60deg);&#125;#ul1 li.cur&#123;opacity: 1;z-index: 5;&#125;#ul1 li.r1&#123;opacity: 1;z-index: 3;transform: perspective(800px) translateX(200px) rotateY(-60deg);&#125;#ul1 li.r2&#123;opacity: 0;z-index: 1;transform: perspective(800px) translateX(300px) rotateY(-45deg);&#125; transform的初始化transform: perspective(800px) rotateY(0) 在添加css的3D效果的时候要想看到立体的效果，需要添加一个视距的属性，这个属性的值越大类似站在比较远的地方看东西，可能会比较小，如果太近的话，就会看到物体特别大，所以合适的视距值很重要，一般perspective的值为800px的时候看到的物体的效果最佳。此时我们还需要初始化transform，否则的话在运动的时候会出现晃动的现象，初始化只需要在要添加运动的元素添加初始值transform: perspective(800px) rotateY(0); 初始化代码： 1#ul1 li&#123;position: absolute;left: 0;top: 0;width: 100%;height: 100%;opacity: 0;transform: perspective(800px) rotateY(0);transition: 1s all ease;&#125; js控制图片的切换一般的思路就是对每一张图片的class挨个更换，这样可以达到效果，就是代码太冗余了，这里提供一个比较简便的用法： 当点击next的按钮时，原本前一张图片往后退一步，加上class即可;因为同样是给下一张图片添加class，我们可以把所有的图片的存成一个数组，当切换下一张的时候，我们只需把第一张图片拿出来，添加到图片集合的尾部，这样图片他们原有的class就添加到了下一张图片上，这样下一张图片就有了图片原先的样式，再加上运动时间，这样运动的效果就做出来了，点击prev同样的方法，只是把最后一张添加到图片集的头部，这样同样实现了图片的切换。 解决next和prev连续点击出现的bug出现这样的bug是因为当图片本次的运动还没有完成时，继续点击按钮，出现了运动的凌乱，要解决这个bug，此时js刚好有一个叫transformend的事件，真是要风得风，要雨得雨，不禁感叹js的功能的强大，从字面上就可以看出这个事件的意思，就是当运动完成的时候出现的这个事件。因为每五张图片都是同时完成的，此时我们只需监听一张图片的运动结果即可。我们可以先定义一个变量aReady=true;当他的值为false时，不执行切换的函数，此时直接返回即可，然后设置aReady=false，当每一个的运动完成时再令aReady=true,这样就可以在一次运动完成之后再点击按钮才会执行下一次运动，这样这个H5的效果就基本完成了。 总结 先运用css对几行图片进项初始化布局 transform的初始化 js的控制，每一次删除数组中最后一个，添加到最前面或者删除最前面的一个，添加到数组的最后面，然后更换图片的class 解决bug，运用transformend函数。 反思运用H5和css3做出更多比较炫的东西 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;*&#123;margin: 0;padding: 0;list-style: none;&#125;.container&#123;background: #aee2d9;width: 800px;margin: 100px auto;overflow: hidden;&#125;#ul1&#123;position: relative;width: 400px;height: 200px;background: #ccc;margin: 100px auto;&#125;#ul1 li&#123;position: absolute;left: 0;top: 0;width: 100%;height: 100%;opacity: 0;transform: perspective(800px) rotateY(0);transition: 1s all ease;&#125;#ul1 li img&#123;width: 400px;&#125;#ul1 li.l2&#123;opacity: 0;z-index: 1;transform: perspective(800px) translateX(-300px) rotateY(45deg);&#125;#ul1 li.l1&#123;opacity: 1;z-index: 3;transform: perspective(800px) translateX(-200px) rotateY(60deg);&#125;#ul1 li.cur&#123;opacity: 1;z-index: 5;&#125;#ul1 li.r1&#123;opacity: 1;z-index: 3;transform: perspective(800px) translateX(200px) rotateY(-60deg);&#125;#ul1 li.r2&#123;opacity: 0;z-index: 1;transform: perspective(800px) translateX(300px) rotateY(-45deg);&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload=function()&#123; var oUl=document.getElementById(&quot;ul1&quot;); var oPrev=document.getElementById(&quot;prev&quot;); var oNext=document.getElementById(&quot;next&quot;); var aLi=oUl.children; var bReady=true; var aClass=[]; for(var i=0;i&lt;aLi.length;i++)&#123; aClass.push(aLi[i].className) &#125; //下一张 oNext.onclick=function()&#123; if(!bReady) return; bReady=false; aClass.unshift(aClass.pop()); tab() &#125;; //上一张 oPrev.onclick=function()&#123; if(!bReady) return; bReady=false; aClass.push(aClass.shift()); tab() &#125;; function tab()&#123; for(var i=0;i&lt;aLi.length;i++)&#123; aLi[i].className=aClass[i]; &#125; var oCur=oUl.querySelector(&quot;.cur&quot;); oCur.addEventListener(&quot;transitionend&quot;,function()&#123; bReady=true; &#125;,false) &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;input type=&quot;button&quot; name=&quot;btn1&quot; id=&quot;prev&quot; value=&quot;上一张&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;btn1&quot; id=&quot;next&quot; value=&quot;下一张&quot; /&gt; &lt;ul id=&quot;ul1&quot;&gt; &lt;li class=&quot;l2&quot;&gt;&lt;img src=&quot;images/1.jpg&quot;/&gt;&lt;/li&gt; &lt;li class=&quot;l1&quot;&gt;&lt;img src=&quot;images/2.jpg&quot;/&gt;&lt;/li&gt; &lt;li class=&quot;cur&quot;&gt;&lt;img src=&quot;images/3.jpg&quot;/&gt;&lt;/li&gt; &lt;li class=&quot;r1&quot;&gt;&lt;img src=&quot;images/4.jpg&quot;/&gt;&lt;/li&gt; &lt;li class=&quot;r2&quot;&gt;&lt;img src=&quot;images/5.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/6.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/7.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/8.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/9.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/10.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/11.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/12.jpg&quot;/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; over","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://www.chenqiangyi.cn/categories/HTML5/"}],"tags":[{"name":"3D切换","slug":"3D切换","permalink":"http://www.chenqiangyi.cn/tags/3D切换/"},{"name":"CSS3","slug":"CSS3","permalink":"http://www.chenqiangyi.cn/tags/CSS3/"},{"name":"HTML5","slug":"HTML5","permalink":"http://www.chenqiangyi.cn/tags/HTML5/"}]},{"title":"用css写一个时钟","slug":"用css写一个时钟","date":"2016-05-08T15:42:54.000Z","updated":"2017-06-14T07:05:22.000Z","comments":true,"path":"2016/05/08/用css写一个时钟/","link":"","permalink":"http://www.chenqiangyi.cn/2016/05/08/用css写一个时钟/","excerpt":"","text":"HTML5以及CSS3能做出许多特别炫的东西，这也是为什么越来越多人喜欢学习H5和CSS3了，今天来分享一个通过CSS3和原生js写出的时钟。先放链接：http://chenqiangyi.com/demo/cssClock.html,上面的时钟刻度以及指针的旋转都用了CSS3的tranform的rotate属性，接下来将主要方法吧。 布局css玩的就是布局，首先需要一个大盒子作为钟表的圆盘，然后就是三个指针，因为三个指针都需要摆动，所以指针需要是绝对定位的。可以先设置指针的top和left为50%，然后通过margin-top和margin-left分别为负的宽高的一半就会调整到中心位置最终可以把三个点固定到中心的cap位置上。 js控制 现获取时间对象，获取每一刻的时iH、分iM、秒iS，然后通过修改每一个指针的每一刻旋转的角度来，控制钟表时间的转动；其中当时针每走一个刻度转动的角度是iH30+iM/6030,分针每走一个刻度转动的角度是iH6+iM/606,秒针每走一个刻度转动的角度是iH6+iMs/10006,其中不能忘了当时针转一定角度的时候分针也转动了一定角度，需要在加上时针转动的角度时时针转动的相应的角度 123oH.style.transform=&quot;rotate(&quot;+(iH*30+iM/60*30)+&quot;deg)&quot;;oM.style.transform=&quot;rotate(&quot;+(iM*6+iS/60*6)+&quot;deg)&quot;;oS.style.transform=&quot;rotate(&quot;+(iS*6+iMs/1000*6)+&quot;deg)&quot;; 然后给钟表添加一个定时器，就会看到钟表开始跑了，此时你会发现转动的角度乱七八糟，这是因为转动的旋转中心没有设定，需要把指针的旋转中心设置为tranform-origin:center bottom;也就是圆盘的正中心，这时就会看到指针正常了，如果你看到了秒针每次跳动几格，那是因为你的时分秒没有加上分秒毫秒转动时他们转动的角度。 添加钟表是时刻针 如果手工添加的话就太笨重了，作为一名程序员当然是自动添加的，这时就有一个问题了：怎么让指针每隔五个刻度变大一次，这需要对刻度遍历，因为只有60个刻度，只需循环60次即可把指针创建出来。这时需要创建span标签，然后添加到表盘中，此时会看到所有的刻度针都挤在了12刻度出，这时需要对每一个刻度进行旋转一定角度，并且旋转的中心也是中心点就像： 1oSpan.style.transform=&quot;rotate(&quot;+i*6+&quot;deg)&quot; 然后再对5取余刚好正除的添加一个长一点的样式，此时就连时钟的刻度表也会出来了，此时你可能会感觉怪怪的，那是因为刻度数字也被旋转了，此时就需要对刻度数次重新调整方向： 1oSpan.children[0].style.transform=&quot;rotate(&quot;+(-i*6)+&quot;deg)&quot; 让span的第一个子元素，也就是时刻度数归位，此时就会看到时钟的模型已经出来了。 添加拖拽效果 通过鼠标的拖拽实时改动盒子的left和top值就完成了拖拽 总结 通过钟表的制作自己对CSS3有了更多的认识，也感觉到了CSS3的强大，以后将会做出更多的CSS效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; #div1&#123;width: 300px;height: 300px;position: absolute;border: 10px solid #0099ff;box-shadow: 1px 2px 2px #0099ff; border-radius: 50%;margin:auto;&#125; #cap&#123;position: absolute;width: 20px;height: 20px;border-radius: 50%;background: #0099ff;top: 50%;left: 50%;margin-left: -10px;margin-top: -10px;&#125; #div1 div&#123;transform-origin: center bottom&#125; #hour&#123;width: 10px;height: 80px;position: absolute;left: 50%;top: 50%;margin-left: -5px;background: #000;margin-top: -80px;&#125; #minute&#123;width: 8px;height: 100px;top: 50%;left: 50%;margin-left: -4px;margin-top: -100px;position: absolute;background: #000;&#125; #second&#123;width: 6px;height: 120px;left: 50%;top: 50%;margin-left: -3px;margin-top: -120px;position: absolute;background: red;&#125; #div1 span&#123;position: absolute;left: 50%;top: 0px;background: #000;width: 2px;margin-left: -2px;height: 8px;transform-origin: center 150px;&#125; #div1 span.on&#123;width: 4px;height: 12px;margin-left: -2px;&#125; #div1 span strong&#123;position: absolute;left: 50%;top: 10px;width: 40px;margin-left: -20px;text-align: center;font-weight: normal;&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload=function()&#123; var oDiv=document.getElementById(&quot;div1&quot;); var oH=document.getElementById(&quot;hour&quot;); var oM=document.getElementById(&quot;minute&quot;); var oS=document.getElementById(&quot;second&quot;); var oSpan=document.getElementById(&quot;span&quot;); var oCap=document.getElementById(&quot;cap&quot;); function click()&#123; var oDate=new Date(); var iH=oDate.getHours(); var iM=oDate.getMinutes(); var iS=oDate.getSeconds(); var iMs=oDate.getMilliseconds(); oH.style.transform=&quot;rotate(&quot;+(iH*30+iM/60*30)+&quot;deg)&quot;; oM.style.transform=&quot;rotate(&quot;+(iM*6+iS/60*6)+&quot;deg)&quot;; oS.style.transform=&quot;rotate(&quot;+(iS*6+iMs/1000*6)+&quot;deg)&quot;; &#125; click(); setInterval(click,30); //创建刻度 for(var i=0;i&lt;60;i++)&#123; var oSpan=document.createElement(&quot;span&quot;); oDiv.appendChild(oSpan); if(i%5==0)&#123; oSpan.className=&quot;on&quot;; oSpan.innerHTML=&quot;&lt;strong&gt;&quot;+(i==0?12:i/5)+&quot;&lt;/strong&gt;&quot;; oSpan.children[0].style.transform=&quot;rotate(&quot;+(-i*6)+&quot;deg)&quot; &#125; oSpan.style.transform=&quot;rotate(&quot;+i*6+&quot;deg)&quot; &#125; oDiv.onmousedown=function(ev)&#123; var oEvt=ev||event; var disX=oEvt.clientX-oDiv.offsetLeft; var disY=oEvt.clientY-oDiv.offsetTop; document.onmousemove=function(ev)&#123; var oEvt=ev||event; oDiv.style.left=oEvt.clientX-disX+&quot;px&quot;; oDiv.style.top=oEvt.clientY-disY+&quot;px&quot;; &#125; document.onmouseup=function()&#123; document.onmousemove=document.onmouseup=null; oDiv.releaseCapture &amp;&amp; oDiv.releaseCapture(); &#125; oDiv.setCapture &amp;&amp; oDiv.setCapture(); return false; &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;div1&quot;&gt; &lt;div id=&quot;hour&quot;&gt;&lt;/div&gt; &lt;div id=&quot;minute&quot;&gt;&lt;/div&gt; &lt;div id=&quot;second&quot;&gt;&lt;/div&gt; &lt;div id=&quot;cap&quot;&gt;&lt;/div&gt;&lt;!-- &lt;span&gt;&lt;strong&gt;12&lt;/strong&gt;&lt;/span&gt;--&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://www.chenqiangyi.cn/categories/CSS/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://www.chenqiangyi.cn/tags/CSS3/"},{"name":"HTML5","slug":"HTML5","permalink":"http://www.chenqiangyi.cn/tags/HTML5/"}]},{"title":"gulp学习笔记","slug":"gulp学习笔记","date":"2016-05-05T15:43:03.000Z","updated":"2017-06-14T13:36:48.000Z","comments":true,"path":"2016/05/05/gulp学习笔记/","link":"","permalink":"http://www.chenqiangyi.cn/2016/05/05/gulp学习笔记/","excerpt":"","text":"最近学习了一下代码构建工具中的gulp和grunt,两者的操作基本相似，在整个流程中配置部分容易出错，稍有一点错误，则项目就无法构建，在学习中前前后后装了几遍才得到gulp的正确姿势，现在来回顾一下gulp学习中用到的知识，用以复习和加深印象 简介：gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 gulp是基于Nodejs的自动任务运行器， 她能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。通过本文，我们将学习如何使用Gulp来改变开发流程，从而使开发更加快速高效。 gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的流操作，能更快地更便捷地完成构建工作。 安装nodejs说明：gulp是基于nodejs，理所当然需要安装nodejs； 安装：打开官网https://nodejs.org/en/，目前node.js有两个版本，4.0版本和6.0版本，其中4.0版本是比较稳定的版本，6.0版本是刚增加上去的版本，之前的5.0版本已经被遗弃，4.0版本官网持续更新到明年，用来使各公司的项目有个过渡的升级。其中直接有Windows的版本，直接下载即可，然后就是安装node.js. 使用命令行简单介绍gulp在使用过程中常用命令，打开命令提示符执行下列命令（打开方式：window + r 输入cmd回车）： node -v 查看安装的nodejs版本，出现版本号，说明刚刚已正确安装nodejs。PS：未能出现版本号，请尝试注销电脑重试； npm -v 查看npm的版本号，npm是在安装nodejs时一同安装的nodejs包管理器; cd 定位到目录，用法：cd + 路径 ； dir 列出文件列表； cls 清空命令提示符窗口内容。 npm介绍说明：npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）； 使用npm安装插件：命令提示符执行npm install &amp;lt;name&amp;gt; [-g] [--save-dev]； &lt;name&gt;：node插件名称。例：npm install gulp-less --save-dev -g：全局安装。将会安装在C:\\Users\\Administrator\\AppData\\Roaming\\npm，并且写入系统环境变量； 非全局安装：将会安装在当前定位目录； 全局安装可以通过命令行在任何地方调用它，本地安装将安装在定位目录的node_modules文件夹下，通过require()调用； --save：将保存配置信息至package.json（package.json是node.js的配置文件）； -dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点； 为什么要保存至package.json？因为node插件包相对来说非常庞大，所以不加入版本管理，将配置信息写入package.json并将其加入版本管理，其他开发者对应下载即可（命令提示符执行npm install，则会根据package.json下载所有需要的包）。 使用npm卸载插件：npm uninstall &amp;lt;name&amp;gt; [-g] [--save-dev] PS：不要直接删除本地插件包 使用npm更新插件：npm update &lt;name&gt; [-g] [--save-dev] 更新全部插件：npm update[--save-dev] 查看npm帮助：npm help 当前目录已安装插件：npm list 选装cnpm说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。32个！来自官网： “这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”； 官方网址：http://npm.taobao.org； 安装：命令提示符执行npm install cnpm -g --registry=https://registry.npm.taobao.org； 注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误； 注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm（以下操作将以cnpm代替npm）。 全局安装gulp说明：全局安装gulp目的是为了通过她执行gulp任务； 安装：命令提示符执行cnpm install gulp -g； 查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。 新建package.json文件说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件 它是这样一个json文件12345678910111213141516171819&#123; “name”: “test”, //项目名称（必须） “version”: “1.0.0”, //项目版本（必须） “description”: “This is for study gulp project !”, //项目描述（必须） “homepage”: “”, //项目主页 “repository”: &#123; //项目资源库 “type”: “git”, “url”: “https://git.oschina.net/xxxx” &#125;, “author”: &#123; //项目作者信息 “name”: “surging”, “email”: “surging2@qq.com” &#125;, “license”: “ISC”, //项目许可协议 “devDependencies”: &#123; //项目依赖的插件 “gulp”: “^3.8.11”, “gulp-less”: “^3.0.0” &#125;&#125; 当然我们可以手动新建这个配置文件，我们应该使用更为效率的方法：命令提示符执行cnpm init gulp-3 本地安装gulp插件安装：定位目录命令后提示符执行cnpm install --save-dev； 本示例以gulp-less为例（编译less文件），命令提示符执行cnpm install gulp-less --save-dev gulp-less-2 将会安装在node_modules的gulp-less目录下，该目录下有一个gulp-less的使用帮助文档README.md； 为了能正常使用，我们还得本地安装gulp：cnpm install gulp --save-dev*； PS：细心的你可能会发现，我们全局安装了gulp，项目也安装了gulp，全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能。 新建gulpfile.js文件（重要）说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件（其实将gulpfile.js放入其他文件夹下亦可）。 它大概是这样一个js文件：12345678910111213//导入工具包 require(‘node_modules里对应模块’)var gulp = require(‘gulp’), //本地安装gulp所用到的地方 less = require(‘gulp-less’);//定义一个testLess任务（自定义任务名称）gulp.task(‘testLess’, function () &#123; gulp.src(‘src/less/index.less’) //该任务针对的文件 .pipe(less()) //该任务调用的模块 .pipe(gulp.dest(‘src/css’)); //将会在src/css下生成index.css&#125;);gulp.task(‘default’,[‘testLess’, ‘elseTask’]); //定义默认任务//gulp.task(name[, deps], fn) 定义任务 name：任务名称 deps：依赖任务名称 fn：回调函数//gulp.src(globs[, options]) 执行任务处理的文件 globs：处理的文件路径(字符串或者字符串数组)//gulp.dest(path[, options]) 处理完后文件生成路径 运行gulp说明：命令提示符执行gulp 任务名称； 编译less：命令提示符执行gulp testLess； 当执行gulp default或gulp将会调用default任务里的所有任务[‘testLess’,’elseTask’] 其中gulp的安装顺序应该为： 运行环境 npm install gulp-cli -g 初始化 package.json文件 npm init 执行环境 npm install gulp –save-dev 然后在你创建项目的目录里出现node_modules文件夹，并且里面需要有gulp文件夹，否则后面的操作不能用 安装插件 npm install –save-dev gulp-uglify 可以在github上面找到相应的插件功能介绍 创建gulpfile.js文件，并且一个项目中只有一个gulpfile.js文件，而且系统只认这个文件，如果要进行不同的工程操作就需要修改里面的配置文件了 压缩文件的配置：1234567891011121314//1 请求一个模块var gulp = require(&quot;gulp&quot;);var uglify = require(&quot;gulp-uglify&quot;);//2 配置任务gulp.task(&quot;yasjs&quot;,function()&#123;return gulp.src(&quot;src/*.js&quot;).pipe(uglify()).pipe(gulp.dest(&quot;dest&quot;));//.pipe(gulp.dest(&quot;dest/all.min.js&quot;));//不能写文件名 只能是目录&#125;);//3 注册任务gulp.task(&quot;defalut&quot;,[&quot;yasjs&quot;]); 其中请求模块和注册任务基本是不变的，只需要修改配置任务即可，例子中的*.js代表的是src目录下的所有js文件，后面的.pipe(gulp.dest(“dest”));只能是目录，dest中不能包含文件名。 压缩合并1234567891011121314151617181920//1 请求一个模块var gulp = require(&quot;gulp&quot;);var uglify = require(&quot;gulp-uglify&quot;);var rename = require(&quot;gulp-rename&quot;);//concat 使用的时候必有文件名称var concat = require(&quot;gulp-concat&quot;);var cssmin = require(&quot;gulp-cssmin&quot;);//2 配置任务gulp.task(&quot;cssmin&quot;,function()&#123;return gulp.src(&quot;src/*.css&quot;).pipe(concat(&quot;all.css&quot;)).pipe(cssmin())//不要重名 没有参数.pipe(rename(&quot;all.min.css&quot;)).pipe(gulp.dest(&quot;dest&quot;));&#125;);//3 注册任务gulp.task(&quot;default&quot;,[&quot;cssmin&quot;]); 请求模块和注册模块基本不变，配置部分的cssmin()中没有参数，不要重名，他们的顺序是先合并，再压缩 总结 安装nodejs； 新建package.json文件； 全局和本地安装gulp； 安装gulp插件； 新建gulpfile.js文件； 通过命令提示符运行gulp任务。","categories":[{"name":"构建工具","slug":"构建工具","permalink":"http://www.chenqiangyi.cn/categories/构建工具/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://www.chenqiangyi.cn/tags/gulp/"}]},{"title":"第一篇blog","slug":"第一篇blog","date":"2016-04-29T08:39:06.000Z","updated":"2017-06-14T07:06:06.000Z","comments":true,"path":"2016/04/29/第一篇blog/","link":"","permalink":"http://www.chenqiangyi.cn/2016/04/29/第一篇blog/","excerpt":"","text":"折腾了好久，个人博客终于上线了，以前在CSDN上面写一些学习上的感悟，总是需要审核，最后想了想还是自己搭建一个个人博客来写点生活学习上的点点滴滴，一方面是对学习成果的复习以及反思，另一方面是对人生的每个阶段的总结。刚开始学习前端的时候每次遇到问题都会在网上看一些大牛的技术博客，都讲解的特别清晰，从他们的博客中可以看出他们的技术积累。诚然，学习每一样东西都是不断地积累，在积累中不断成长，以后就在这里记录自己学习的历程，不断地积累自己的技术栈。","categories":[{"name":"blog","slug":"blog","permalink":"http://www.chenqiangyi.cn/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://www.chenqiangyi.cn/tags/blog/"}]}]}